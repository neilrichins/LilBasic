LILBASIC        LilBasic (c)2002                                                                              PAGE 1

                       1    ;
                       2    ;
                       3    ;           LIL'BASIC INTERPRETER
                       4    ;       LIL'BASIC INTERPRETER PROGRAM
                       5    ;       ==============================
  0030                 6    VERS    EQU     30H
                       7    
                       8    $MOD51                          ;8051 Registers
                       9    $NODEBUG                        ;No Emulateion code
                      10    $TITLE(LilBasic (c)2002)
                      11    
                      12    ;======================================================================================
                      13    ;                          Macros!
                      14    ;======================================================================================
                      15    ;IJMP   (LBL)
                      16    ;       Jump to the (potentially distant) IL instruction at location LBL.
                      17    ;Note:  In this implementation IL addresses are equivalent to machine
                      18    ;       language addresses, so IJMP performs a generic JMP.
                      19    ;
                      20    ;
                      21    ;===============
                      22    ;
                      23    ;HOP    (LBL)
                      24    ;       Perform a branch to the IL instruction at (nearby) location LBL.
                      25    ;Note:  In this implementation IL addresses are equivalent to machine
                      26    ;       language addresses, so HOP performs a simple relative SJMP.
                      27    ;
                      28    ;
                      29    ;===============
                      30    ;
                      31    ;ICALL  (LBL)
                      32    ;       Call the IL subroutine starting at instruction LBL.
                      33    ;       Save the location of the next IL instruction on the control stack.
                      34    ;Note:  In this implementation, IL addresses are identical with
                      35    ;       machine language addresses, and are saved on the MCS-51 hardware stack.
                      36    ;
                      37    ;
                      38    ;===============
                      39    ;
                      40    ;IRET
                      41    ;       Return from IL subroutine to location on top of control stack.
                      42    ;Note:  In this implementation, IL addresses are identical with machine
                      43    ;       language addresses, which are saved on the hardware stack.
                      44    ;
                      45    ;
                =1    46    $INCLUDE(MACROS\MACROS.ASM)
                =1    47    PFILE   MACRO   NAME
                =1    48            DB      029H,0EEH,0F1H,0F2H,'P',NAME,00H
                =1    49            ENDM
                =1    50    DFILE   MACRO   NAME
                =1    51            DB      029H,0EEH,0F1H,0F2H,'D',NAME,00H
                =1    52            ENDM
                =1    53    
                =1    54    PAGE    MACRO   PG
                =1    55            MOV     P2,PG
                =1    56            ENDM
                =1    57    
                =1    58    
LILBASIC        LilBasic (c)2002                                                                              PAGE 2

                =1    59    LIT_    MACRO   K
                =1    60            CALL    LIT
                =1    61            DB      K
                =1    62            ENDM
                =1    63    
                =1    64    TSTV_   MACRO   LBL
                =1    65            CALL    TSTV
                =1    66            JNC     LBL
                =1    67            ENDM
                =1    68    
                =1    69    TSTN_   MACRO   LBL
                =1    70            CALL    TSTN
                =1    71            JNC     LBL
                =1    72            ENDM
                =1    73    
                =1    74    TSTL_   MACRO   LBL
                =1    75            CALL    TSTN
                =1    76            JNC     LBL
                =1    77            ENDM
                =1    78    
                =1    79    TSTS_   MACRO   LBL
                =1    80            CALL    TSTS
                =1    81            JC      LBL
                =1    82            ENDM
                =1    83    
                =1    84    IFDONE_ MACRO   LBL
                =1    85            CALL    IFDONE
                =1    86            JNC     LBL
                =1    87            ENDM
                =1    88    
                =1    89    LINIT_  MACRO
                =1    90            CALL   L_INIT
                =1    91            JC      ERRENT
                =1    92            ENDM
                =1    93    
                =1    94    COND_   MACRO   LBL
                =1    95            CALL   COND
                =1    96            JNC    LBL
                =1    97            ENDM
                =1    98    
                =1    99    NEXT_LOOP_       MACRO   LBL
                =1   100            CALL   LOOP
                =1   101            JC     LBL
                =1   102            ENDM
                =1   103    
                =1   104    IJMP_   MACRO   LBL
                =1   105            JMP     LBL
                =1   106            ENDM
                =1   107    
                =1   108    HOP_    MACRO   LBL
                =1   109            SJMP    LBL
                =1   110            ENDM
                =1   111    
                =1   112    ICALL_  MACRO   LBL
                =1   113            CALL    LBL
                =1   114            ENDM
                =1   115    
                =1   116    MLCALL_ MACRO
LILBASIC        LilBasic (c)2002                                                                              PAGE 3

                =1   117            CALL    MLCALL
                =1   118            ANL     PSW,#11100111B
                =1   119            ENDM
                     120    
                     121    
                     122    ;======================================================================================
                     123    ;       GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
                     124    ;======================================================================================;
                     125    ;               Intended System Configuration Constants:
                     126    
  0000               127    AESRAM  EQU     0000H           ;AES STACK 256 Bytes... BIG stack !
  0100               128    STRRAM  EQU     0100H           ;String memory 26vars * 256 bytes = 6656 or 1A00
  1C00               129    VARRAM  EQU     1C00H           ;Start of memory for INT Variables
  2000               130    EXTRAM  EQU     2000H           ;Start of program buffer.
  7FFF               131    RAMLIM  EQU     7FFFH           ;Top of Program ram = 32K.
  8000               132    XTOP    EQU     8000H           ;Address of 2 byte pointer to top of XRAM
  8002               133    XRAM    EQU     8002H           ;Start of MFS ram Area
  0008               134    TABSIZ  EQU     8               ;Formatted column spacing.
  00FF               135    AESLEN  EQU     0FFH            ;AES Length = 256 bytes!!!!
                     136    
                     137    ;===========================================================================================
                                                                               ========
                     138    
                     139    ;       Working Register Definitions.
                     140    ;
                     141    PNTR_L  EQU     R0              ;Program buffer pointer.
                     142    DEST_L  EQU     R1              ;Destination pointer for line insertion.
                     143    PNTR_H  EQU     R2              ;High-order pointer byte (temp. cursor)
                     144    DEST_H  EQU     R3
                     145    CHAR    EQU     R4              ;BASIC source string character being parsed.
                     146    LP_CNT  EQU     R5
                     147    TOS_L   EQU     R6              ;Variable popped from stack for math routines.
                     148    TOS_H   EQU     R7
                     149    
                     150    ; First 8 bytes reserved for R1 to R8
                     151    ;                               START OF DATA SEGMENT  128 Bytes !!!
                     152    
                     153    
                     154    ;
----                 155            DSEG
0008                 156            ORG     08H
                     157    ;
                     158    ;       Temporary variables used in MUL,DIV and other routines.
                     159    ;
0008                 160    TMP0:   DS      1
0009                 161    TMP1:   DS      1
000A                 162    TMP2:   DS      1
000B                 163    TMP3:   DS      1
000C                 164    TMP4:   DS      1
000D                 165    TMP5:   DS      1
000E                 166    TMP6:   DS      1               ; Not used in MUL or DIV reserved for use in basic commands.
                                                                               
000F                 167    TMP7:   DS      1               ; Not used in MUL or DIV reserved for use in basic commands.
                                                                               
                     168    
0010                 169    SEED_L: DS      1               ;Random number key.
0011                 170    SEED_H: DS      1
                     171    
LILBASIC        LilBasic (c)2002                                                                              PAGE 4

                     172    
0012                 173    STRLEN: DS      1               ;Length of text string in L_BUF.
                     174    
0013                 175    L_CURS: DS      1               ;Cursor for line buffer.
                     176    
0014                 177    TABCNT: DS      1               ;Column formatting count.
                     178    
0015                 179    CURS_L: DS      1               ;CURSOR Source line cursor.
0016                 180    CURS_H: DS      1
0017                 181    C_SAVE: DS      1               ;CHAR saved during SAVE_PNTR.
                     182    
0018                 183    LABL_L: DS      1               ;BASIC program source line counter.
0019                 184    LABL_H: DS      1               ;  "       "       "     high byte.
                     185    
001A                 186    ERROR:  DS      1               ;Error Code
001B                 187    ELN_L:  DS      1               ;Error Line number Low byte
001C                 188    ELN_H:  DS      1               ;Error Line number Low byte
001D                 189    AESP:   DS      1               ;AES Stack Pointer
                     190    
001E                 191    TIMER0: DS      1               ;Timer counter passed to basic
001F                 192    TIMER1: DS      1
                     193    
0020                 194    PWM0:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 1
0021                 195    PWM1:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 1
0022                 196    PWM2:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 2
0023                 197    PWM3:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 3
0024                 198    PWM4:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 4
0025                 199    PWM5:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 5
0026                 200    PWM6:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 6
0027                 201    PWM7:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 7
                     202    
                     203    ;===========================================================================================
                                                                               ========
0028                 204    PRT_MSK:DS      1               ;Port Mask (enabled pins for PWM )  (MUST BE AFTER ADDR 32 d
                                                                               ec/ 20 HEX)
                     205    
  0040               206    PWM_E0          BIT     PRT_MSK.0          ;Pin 0
  0041               207    PWM_E1          BIT     PRT_MSK.1          ;Pin 1
  0042               208    PWM_E2          BIT     PRT_MSK.2          ;pin 2
  0043               209    PWM_E3          BIT     PRT_MSK.3          ;Pin 3
  0044               210    PWM_E4          BIT     PRT_MSK.4          ;Pin 4
  0045               211    PWM_E5          BIT     PRT_MSK.5          ;Pin 5
  0046               212    PWM_E6          BIT     PRT_MSK.6          ;Pin 6
  0047               213    PWM_E7          BIT     PRT_MSK.7          ;Pin 7
                     214    
                     215    ;===========================================================================================
                                                                               ========
0029                 216    TMP_MSK:DS      1               ;Temporary mask for bit manulipation
                     217    
  0048               218    TMP_0          BIT     TMP_MSK.0
  0049               219    TMP_1          BIT     TMP_MSK.1
  004A               220    TMP_2          BIT     TMP_MSK.2
  004B               221    TMP_3          BIT     TMP_MSK.3
  004C               222    TMP_4          BIT     TMP_MSK.4
  004D               223    TMP_5          BIT     TMP_MSK.5
  004E               224    TMP_6          BIT     TMP_MSK.6
  004F               225    TMP_7          BIT     TMP_MSK.7
                     226    
LILBASIC        LilBasic (c)2002                                                                              PAGE 5

                     227    ;===========================================================================================
                                                                               ========
002A                 228    MODE:   DS      1               ;Operating mode bits.
                     229    
  0050               230    UNUSED          BIT     MODE.0          ;
  0051               231    AUTO            BIT     MODE.1          ; Set when BASIC programs auto executed.
  0052               232    XAUTO           BIT     MODE.2          ; Set when BASIC programs auto executed from XMEM.
  0053               233    RUNMOD          BIT     MODE.3          ; Set when stored BASIC program is running.
  0054               234    HEXMOD          BIT     MODE.4          ; Set when operations should use HEX radix.
                     235    
                     236    
                     237    ;===========================================================================================
                                                                               ========
002B                 238    FLAGS:  DS      1               ;Interroutine communication flags.  ;
                     239    
  0058               240    ZERSUP          BIT     FLAGS.0         ; If set, suppress printing leading zeroes.
  0059               241    CHAR_FLG        BIT     FLAGS.1         ; Set when CHAR has not been processed.
  005A               242    SGN_FLG         BIT     FLAGS.2         ; Keeps track of operand(s) sign during math.
  005B               243    SEQ_FLG         BIT     FLAGS.3         ;
  005C               244    MOD_FLG         BIT     FLAGS.4         ; Set if divide routine should return MOD value.
  005D               245    H_FLG           BIT     FLAGS.5         ; Used to sense allow 'H' suffix in HEX mode.
  005E               246    RAMROM          BIT     FLAGS.6         ; Set when moving program from ROM to RAM Clear = Fr
                                                                               om Ram to Ram
                     247    
                     248    ;===========================================================================================
                                                                               ========
                     249    ;
                     250    ;                       Start of Code Segment
                     251    ;
                     252    ;       Line Buffer Variables:
                     253    ;
  002B               254    SP_BASE EQU     $-1             ;Initialization value for hardware SP.   ( STACK = 34 TO 128
                                                                               )
                     255    ;
  000D               256    CR      EQU     0DH             ;ASCII CODE FOR <CARRIAGE RETURN>.
  000A               257    LF      EQU     0AH             ;  "    "    "  <LINE FEED>.
  0007               258    BEL     EQU     07H             ;  "    "    "  <BELL>.
  001B               259    ESC     EQU     1BH             ;  "    "    "  <ESC>
  0008               260    BS      EQU     08H             ;  "    "    "  <BS>
  0020               261    SPACE   EQU     20H             ;  "    "    "  <SPACE>
  0012               262    CTRL_R  EQU     12H             ;  "    "    "  <CTRL> <R>
  007F               263    DEL     EQU     7FH             ;  "    "    "  <DEL>
                     264    ;
                     265    ;$SAVE NOGEN
                     266    ;===========================================================================================
                                                                               ========
                     267    ;
                     268    ;       Interrupt routine expansion hooks:
                     269    ;
                     270    ;===========================================================================================
                                                                               ========
                     271    
----                 272            CSEG
0000                 273            ORG     0000H           ;System initialization / reset routine.
0000 02008C          274            JMP     S_INIT
                     275    
0003                 276            ORG     0003H           ;External interrupt 0 service routine.
0003 32              277            RETI
LILBASIC        LilBasic (c)2002                                                                              PAGE 6

                     278    
000B                 279            ORG     000BH           ;Timer 0 service routine.
000B 020024          280            JMP    TIMER_0
                     281    
0013                 282            ORG     0013H           ;External interrupt 1 service routine.
0013 32              283            RETI
                     284    
001B                 285            ORG     001BH           ;Timer 1 service routine.
001B 32              286            RETI
                     287    
0023                 288            ORG     0023H           ;Serial port interrupt service routine.
0023 32              289            RETI
                     290    
                =1   291    $INCLUDE(INT\TIMER0.ASM)  ;Timer 0  Auto reload timer used for PWM
                =1   292    ;===================================================================
                =1   293    ;I          TIMER 0 INTERRUPT VECTOR --> PWM   9216.Hz/255
                =1   294    ;===================================================================
0024            =1   295    TIMER_0:
0024 C0D0       =1   296            PUSH    PSW                     ;Save Flags
0026 C0E0       =1   297            PUSH    Acc                     ;Save Acc so we can use it
0028 D51E32     =1   298            DJNZ    TIMER0,TO_CHK           ;Bump counter, if TIMER not 0 then Check to see if t
                                                                               ime to toggle PWM
002B 051F       =1   299            INC     TIMER1                  ;Else increase timer 1
002D 751E64     =1   300            MOV     TIMER0,#100             ;Reset Timer0 back to 100 (1% to 99% threshold)
                =1   301    
                =1   302    ; Toggle all pins being used for PWM to 'reset' them
0030            =1   303    TO_CLR:
0030 7464       =1   304            MOV     A,#100                  ;Preload A with FF for easy compairson
                =1   305    
0032            =1   306    TCLR0:
0032 B52002     =1   307            CJNE    A,PWM0,TCLR1            ;Skip if not used
0035 B280       =1   308            cpl     P0.0                    ;Else set bit
                =1   309    
0037            =1   310    TCLR1:
0037 B52102     =1   311            CJNE    A,PWM1,TCLR2           ;Skip if not used
003A B281       =1   312            cpl     P0.1                   ;Toggle pin 1
                =1   313    
                =1   314    
003C            =1   315    TCLR2:
003C B52202     =1   316            CJNE    A,PWM2,TCLR3           ;Skip if not used
003F B282       =1   317            cpl     P0.2                   ;Toggle pin 2
                =1   318    
                =1   319    
0041            =1   320    TCLR3:
0041 B52302     =1   321            CJNE    A,PWM3,TCLR4           ;Skip if not used
0044 B283       =1   322            cpl     P0.3                   ;Toggle pin 3
                =1   323    
0046            =1   324    TCLR4:
0046 B52402     =1   325            CJNE    A,PWM4,TCLR5            ;Skip if not used
0049 B284       =1   326            cpl     P0.4                    ;Toggle pin 4
                =1   327    
004B            =1   328    TCLR5:
004B B52502     =1   329            CJNE    A,PWM5,TCLR6            ;Skip if not used
004E B285       =1   330            cpl     P0.5                    ;Toggle pin 6
                =1   331    
0050            =1   332    TCLR6:
0050 B46402     =1   333            CJNE    A,#100,TCLR7            ;Skip if not used
0053 B286       =1   334            cpl     P0.6                    ;Toggle pin 6
LILBASIC        LilBasic (c)2002                                                                              PAGE 7

                =1   335    
0055            =1   336    TCLR7:
0055 B4642F     =1   337            CJNE    A,#100,T0_EXIT           ;Skip if not used
0058 B287       =1   338            cpl     P0.7                    ;Toggle pin 7
005A 020087     =1   339            JMP     T0_EXIT                 ;Restore vars & exit
                =1   340    
                =1   341    ; Check all 8 pins to see if they need toggled.
005D            =1   342    TO_CHK:
005D E51E       =1   343            MOV     A,TIMER0                ;Copy TIMER0 to A for eazy access
                =1   344    
005F            =1   345    TCHK0:
005F B52002     =1   346            CJNE    A,PWM0,TCHK1            ;Skip if not at threshold
0062 B280       =1   347            cpl     P0.0                    ;Else set bit
                =1   348    
0064            =1   349    TCHK1:
0064 B52102     =1   350            CJNE    A,PWM1,TCHK2            ;Skip if not at threshold
0067 B281       =1   351            cpl     P0.1                    ;Toggle pin 1
                =1   352    
                =1   353    
0069            =1   354    TCHK2:
0069 B52202     =1   355            CJNE    A,PWM2,TCHK3            ;Skip if not at threshold
006C B282       =1   356            cpl     P0.2                    ;Toggle pin 2
                =1   357    
006E            =1   358    TCHK3:
006E B52302     =1   359            CJNE    A,PWM3,TCHK4            ;Skip if not at threshold
0071 B283       =1   360            cpl     P0.3                    ;Toggle pin 3
                =1   361    
0073            =1   362    TCHK4:
0073 B52402     =1   363            CJNE    A,PWM4,TCHK5            ;Skip if not at threshold
0076 B284       =1   364            cpl     P0.4                    ;Toggle pin 4
                =1   365    
0078            =1   366    TCHK5:
0078 B52502     =1   367            CJNE    A,PWM5,TCHK6            ;Skip if not at threshold
007B B285       =1   368            cpl     P0.5                    ;Toggle pin 6
                =1   369    
007D            =1   370    TCHK6:
007D B52602     =1   371            CJNE    A,PWM6,TCHK7            ;Skip if not at threshold
0080 B286       =1   372            cpl     P0.6                    ;Toggle pin 6
                =1   373    
0082            =1   374    TCHK7:
0082 B52702     =1   375            CJNE    A,PWM7,T0_EXIT          ;Skip if not at threshold
0085 B287       =1   376            cpl     P0.7                    ;Toggle pin 7
                =1   377    
0087            =1   378    T0_EXIT:
0087 D0E0       =1   379            POP     Acc                     ;Restore Acc
0089 D0D0       =1   380            POP     PSW                     ;Restore Flags
008B 32         =1   381            RETI                            ;Exit
                =1   382    $INCLUDE(INT\RESET.ASM)   ;Power Up and Reset
                =1   383    ;===================================================================
                =1   384    ;I                 RESET INTERRUPT VECTOR                          I
                =1   385    ;===================================================================
008C            =1   386    S_INIT:
                =1   387    
008C 758C0F     =1   388            MOV     TH0,#0FH        ;Load Timer0 overload value for timer 0 (1/120 th sec)
008F D2AF       =1   389            SETB    EA              ;Enable interupts
0091 D2A9       =1   390            SETB    ET0             ;Enable Timer0 Interupt for TIMER
0093 D28C       =1   391            SETB    TR0             ;Enable Timer0 interrupt
                =1   392    
LILBASIC        LilBasic (c)2002                                                                              PAGE 8

0095 D252       =1   393            SETB    XAUTO           ;Default run program from shared Xmem
                =1   394    
0097 908002     =1   395            MOV     DPTR,#XRAM       ;Set DPTR to start of XRAM heap
009A 121172     =1   396            CALL    IS_TAG
009D 4008       =1   397            JC      TRAM_OK         ;If Tag at start of Xram, don't reset HEAP
009F 908002     =1   398            MOV     DPTR,#XRAM      ;No Program, so default NVram
00A2 12125B     =1   399            CALL    SAVE_XTOP       ;Reset Xtop to start of XRAM heap
00A5 C252       =1   400            CLR     XAUTO           ;If no program in Xmem run from ROM
                =1   401    
                =1   402    
                =1   403    
00A7            =1   404     TRAM_OK:
                =1   405    
00A7 E4         =1   406            CLR     A
00A8 F5D0       =1   407            MOV     PSW,A
00AA F528       =1   408            MOV     PRT_MSK,A       ;Clear Port bit mask
00AC C253       =1   409            CLR     RUNMOD          ;Execution set to command line
00AE C254       =1   410            CLR     HEXMOD          ;Default I/O to Decimal
00B0 75812B     =1   411            MOV     SP,#SP_BASE     ;Initialize hardware stack.
00B3 751D00     =1   412            MOV     AESP,#0H        ;Initialize Arithmatic Expression Stack.
                =1   413    
                =1   414    
00B6            =1   415    SP_INI:
00B6 7890       =1   416            MOV     R0,#144
00B8 752B00     =1   417            MOV     FLAGS,#0         ;Interroutine flags.
                =1   418    
                =1   419    
00BB C28E       =1   420            CLR     TR1             ;
00BD 75985A     =1   421            MOV     SCON,#01011010B ;TI set indicates transmitter ready.
00C0 758922     =1   422            MOV     TMOD,#00100010B ;Timer 0 & 1 Set to auto-reload timer mode.
00C3 758DFD     =1   423            MOV     TH1,#0FDH       ;9600 bps.
00C6 D28E       =1   424            SETB    TR1
                =1   425    
00C8 E51F       =1   426            MOV     A,TIMER1        ; If timer =0 then must be a powerup , Else Just a reset
00CA 600A       =1   427            JZ      AUTORUN
                =1   428    
                =1   429    
                =1   430    ;======================================================================================
                =1   431    ;
00CC            =1   432    START_COMMAND_SEG:
                =1   433    
00CC 120D2A     =1   434            CALL    VER_MSG
00CF C251       =1   435            CLR     AUTO            ;Don't Auto Rum program
00D1 C252       =1   436            CLR     XAUTO           ;Don't Run program from shared Xmem
00D3 020A7B     =1   437            JMP     START
                =1   438    
                =1   439    ;======================================================================================
                =1   440    ;
00D6            =1   441    AUTORUN:
                =1   442                                            ;Clear Program in RAM space
00D6 758200     =1   443            MOV     DPL,#LOW(EXTRAM)        ;Move DPTR to beginning of program
00D9 758320     =1   444            MOV     DPH,#HIGH(EXTRAM)
00DC 74FF       =1   445            MOV     A,#0FFH                 ;Token for end of basic program
00DE F0         =1   446            MOVX    @DPTR,A                 ;Put END token at start of program
                =1   447    
00DF D251       =1   448            SETB    AUTO            ;Auto Rum program
00E1 D252       =1   449            SETB    XAUTO           ;Default run program from shared Xmem
00E3 020AB7     =1   450            JMP     XEC
LILBASIC        LilBasic (c)2002                                                                              PAGE 9

                     451    ;===========================================================================================
                                                                               ========
                     452    ;                       Basic Input / Output Routines
                     453    ;===========================================================================================
                                                                               ========;
                     454    ;ISALPHANUM
                     455    ;       Evaluates A
                     456    ;               C is 0 if in  Alphanumeric range
                     457    ;               C is 1 if not
                     458    ;ISALPHA
                     459    ;       Evaluates A
                     460    ;               C is 0 if  'A' to 'Z' or 'a' to 'z'
                     461    ;               C is 1 if not
                     462    ;ISLOWER
                     463    ;       Evaluates A
                     464    ;               C is 0 if Lowercase
                     465    ;               C is 1 if not
                     466    ;
                     467    ; USES: nothing
                =1   468    $INCLUDE(BIOS\ALPHANUM.ASM)
                =1   469    ;ISALPHANUM
                =1   470    ;       Evaluates A
                =1   471    ;               C is 1 if in  Alphanumeric range
                =1   472    ;               C is 0 if not
                =1   473    ;ISALPHA
                =1   474    ;       Evaluates A
                =1   475    ;               C is 1 if  'A' to 'Z' or 'a' to 'z'
                =1   476    ;               C is 0 if not
                =1   477    ;ISLOWER
                =1   478    ;       Evaluates A
                =1   479    ;               C is 1 if Lowercase
                =1   480    ;               C is 0 if not
                =1   481    ;
                =1   482    ; USES: nothing
                =1   483    
                =1   484    
                =1   485    
00E6            =1   486    ISALPHANUM:
                =1   487    
00E6 B43000     =1   488            CJNE    A,#'0',$+3                                      ; Is A < '0'
00E9 401F       =1   489            JC      ISALPHANUM_NO                                   ;
                =1   490    
00EB B43A1A     =1   491            CJNE    A,#'9'+1,ISALPHANUM_YES                         ; IS A > '9'
00EE 5002       =1   492            JNC     ISALPHA                                         ; Yes, then check if it is a
                                                                                letter
00F0 8016       =1   493            SJMP     ISALPHANUM_YES                                  ; No, must be a number '0' 
                                                                               to '9'
00F2            =1   494    ISALPHA:
00F2 B44100     =1   495            CJNE    A,#'A',$+3                                      ; Is A < 'A'
00F5 4013       =1   496            JC      ISALPHANUM_NO                                   ;
                =1   497    
00F7 B45B0E     =1   498            CJNE    A,#'Z'+1,ISALPHANUM_YES                         ; IS A > 'Z'
00FA 5002       =1   499            JNC     ISLOWER                                         ; Yes, then check if it is l
                                                                               owercase
00FC 800A       =1   500            SJMP     ISALPHANUM_YES                                  ; No, must be a Letter 'A' 
                                                                               to 'Z'
                =1   501    
00FE            =1   502    ISLOWER:
LILBASIC        LilBasic (c)2002                                                                              PAGE 10

00FE B46100     =1   503            CJNE    A,#'a',$+3                                      ; Is A < 'z'
0101 4007       =1   504            JC      ISALPHANUM_NO                                   ;
                =1   505    
0103 B47B04     =1   506            CJNE    A,#'z'+1,ISALPHANUM_NO                         ; IS A > 'z'
0106 5002       =1   507            JNC     ISALPHANUM_NO                                  ; Yes, then not in range.
                =1   508            ;SJMP     ISALPHANUM_YES                                 ; No, must be a Letter 'A' 
                                                                               to 'Z'
                =1   509    
0108            =1   510    ISALPHANUM_YES:
0108 D3         =1   511            SETB    C
0109 22         =1   512            RET
                =1   513    
010A            =1   514    ISALPHANUM_NO:
010A C3         =1   515            CLR     C
010B 22         =1   516            RET
                     517    
                     518    ;=======
                     519    
                     520    ;UPPER:
                     521    ;       Convert CHAR in Acc to uppercase !
                     522    ;
                =1   523    $INCLUDE(BIOS\UPPER.ASM)
                =1   524    
010C            =1   525    UPPER:                          ;Convert CHAR in ACC to uppercase !
010C B46100     =1   526            CJNE    A,#'a',$+3      ;Check for lower-case alphabetics.
010F 4007       =1   527            JC      UPPER_EXIT
0111 B47B00     =1   528            CJNE    A,#'z'+1,$+3
0114 5002       =1   529            JNC     UPPER_EXIT
0116 54DF       =1   530            ANL     A,#11011111B    ;Force to upper-case.
0118            =1   531    UPPER_EXIT:
0118 22         =1   532            RET
                     533    ;=======
                     534     ;C_IN:
                     535    ;       Console character input routine.
                     536    ;       Waits for next input from console device and returns with character
                     537    ;       code in accumulator.
                =1   538     $INCLUDE(BIOS\C_IN.ASM)
0119            =1   539    C_IN:
                =1   540    ;       Console character input routine.
                =1   541    ;       Waits for next input from console device and returns with character
                =1   542    ;       code in accumulator.
                =1   543    ;
                =1   544    ;
                =1   545    ;
0119 3098FD     =1   546            JNB     RI,$            ;Wait until character received.
011C E599       =1   547            MOV     A,SBUF          ;Read input character.
011E C298       =1   548            CLR     RI              ;Clear reception flag.
0120 547F       =1   549            ANL     A,#7FH          ;Mask off data bits.
0122 B40A02     =1   550            CJNE    A,#LF,C_IN_END  ;Proceee Linefeeds as Spaces
0125 7400       =1   551            MOV     A,#0
0127            =1   552    C_IN_END:
0127 22         =1   553            RET                     ;Return to calling routine.
                =1   554    ;
                     555    ;=======
                     556    ;NLINE: Transmit <CR><LF> sequence to console device.
                     557    ;C_OUT:
                     558    ;       Console character output routine.
                     559    ;       Outputs character received in accumulator to console output device.
LILBASIC        LilBasic (c)2002                                                                              PAGE 11

                =1   560    $INCLUDE(BIOS\C_OUT.ASM)
0128            =1   561    NLINE:
                =1   562    ;       Transmit <CR><LF> sequence to console device.
                =1   563    ;
0128 740D       =1   564            MOV     A,#CR
012A            =1   565    C_OUT:
                =1   566    ;       Console character output routine.
                =1   567    ;       Outputs character received in accumulator to console output device.
                =1   568    ;
012A 3099FD     =1   569    DD006:  JNB     TI,$            ;Wait until transmission completed.
012D C299       =1   570    DD007:  CLR     TI              ;Clear interrupt flag.
012F F599       =1   571            MOV     SBUF,A          ;Write out character.
0131 B40D0A     =1   572            CJNE    A,#CR,COUT_2
0134 3099FD     =1   573    DD008:  JNB     TI,$
0137 C299       =1   574    DD009:  CLR     TI
0139 75990A     =1   575            MOV     SBUF,#LF        ;Output linefeed.
013C 8004       =1   576            SJMP    COUT_3
                =1   577    ;
013E C3         =1   578    COUT_2: CLR     C
013F D51404     =1   579            DJNZ    TABCNT,COUT_1   ;Monitor output field position.
0142 751408     =1   580    COUT_3: MOV     TABCNT,#TABSIZ  ;Reload field counter.
0145 D3         =1   581            SETB    C
0146 22         =1   582    COUT_1: RET
                     583    ;=======
                     584    ;
                     585    ;
0147 30980A          586    CNTRL:  JNB     RI,CNTRET       ;Poll whether character has been typed.
014A 3119            587            CALL    C_IN
014C B41305          588            CJNE    A,#13H,CNTRET   ;Check if char. is <CNTRL-S>.
014F 3119            589    CNTR_2: CALL    C_IN            ;If so, hang up...
0151 B411FB          590            CJNE    A,#11H,CNTR_2   ;    ...until <CNTRL-Q> received.
0154 22              591    CNTRET: RET
                     592    ;
                     593    ;=======
                     594    ;SPC:
                     595    ;       Transmit one or more space characters to console to move console
                     596    ;       cursor to start of next field.
                =1   597    $INCLUDE(BIOS\TAB.ASM)
                =1   598    
0155            =1   599    SPC:
                =1   600    ;       Transmit one or more space characters to console to move console
                =1   601    ;       cursor to start of next field.
                =1   602    ;
0155 7420       =1   603            MOV     A,#SPACE         ;Load ASCII code for space character.
0157 312A       =1   604            CALL    C_OUT
0159 50FA       =1   605            JNC     SPC             ;Repeat until at TAB boundary.
015B 22         =1   606            RET
                =1   607    ;
                     608    ;===============
                     609    ;NIBOUT:
                     610    ;       If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
                     611    ;       output the corresponding ASCII value and clear ZERSUP flag.
                     612    ;       Otherwise return without affecting output or ZERSUP.
                =1   613    $INCLUDE(BIOS\NIBOUT.ASM)       ;USES C_OUT
                =1   614    ;
                =1   615    ;NIBOUT
                =1   616    ;       If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
                =1   617    ;       output the corresponding ASCII value and clear ZERSUP flag.
LILBASIC        LilBasic (c)2002                                                                              PAGE 12

                =1   618    ;       Otherwise return without affecting output or ZERSUP.
                =1   619    ;
015C 540F       =1   620    NIBOUT: ANL     A,#0FH          ;Mask out low-order bits.
015E 7003       =1   621            JNZ     NIBO_2          ;Output ASCII code for Acc contents.
0160 205807     =1   622            JB      ZERSUP,NIBO_3
0163 C258       =1   623    NIBO_2: CLR     ZERSUP          ;Mark that non-zero character encountered.
0165 2403       =1   624            ADD     A,#(ASCTBL-(NIBO_1+1))  ;Offset to start of table.
0167 83         =1   625    NIBO_1: MOVC    A,@A+PC         ;Look up corresponding code.
0168 312A       =1   626            CALL    C_OUT           ;Output character.
016A 22         =1   627    NIBO_3: RET
                =1   628    ;
016B 30313233   =1   629    ASCTBL: DB      '0123456789ABCDEF'
016F 34353637   
0173 38394142   
0177 43444546   
                =1   630    ;
                     631    
                     632    ;
                     633    ;HEXOUT:
                     634    ;       Output Hexdecimal value in ACC
                     635    ;       USES   TMP0
                     636    ;       CALLS   NIBOUT
                =1   637    $INCLUDE(BIOS\HEXOUT.ASM)
                =1   638    ;
                =1   639    ;HEXOUT:
                =1   640    ;       Output Hexdecimal value in ACC
                =1   641    ;USES   TMP0
                =1   642    
017B            =1   643    HEXOUT:
017B F508       =1   644            MOV TMP0,A              ;Save ACC
017D C258       =1   645            CLR     ZERSUP
017F 315C       =1   646            CALL    NIBOUT          ;Send 1st nib
0181 E508       =1   647            MOV A,TMP0
0183 C4         =1   648            SWAP A                  ;Xchange HI & LOW nibbs in A
0184 C258       =1   649            CLR     ZERSUP
0186 315C       =1   650            CALL    NIBOUT          ;Send 2nt nib
0188 E508       =1   651            MOV A,TMP0              ;Restore A
018A 22         =1   652            RET
                =1   653    
                     654    
                     655    ;=======
                     656    ;STROUT
                     657    ;       Copy in-line character string to console output device.
                     658    ;       Maximum Lenght is 254 Chars + 2 for return addr !!!!
                     659    ;       (8 bit INC to DPTR)
                =1   660    $INCLUDE(BIOS\STROUT.ASM)       ;USES C_OUT
                =1   661    ;STROUT
                =1   662    ;       Copy in-line character string to console output device.
                =1   663    ;       Maximum Lenght is 254 Chars + 2 for return addr !!!!
                =1   664    ;
                =1   665    ;
018B D083       =1   666    STROUT: POP     DPH             ;Access in-line string.
018D D082       =1   667            POP     DPL
018F E4         =1   668    STRO_1: CLR     A
0190 93         =1   669            MOVC    A,@A+DPTR       ;Read next byte.
0191 A3         =1   670            INC     DPTR            ;Bump pointer.
0192 10E704     =1   671            JBC     ACC.7,STRO_2    ;Escape after last character.
0195 312A       =1   672            CALL    C_OUT           ;Output character.
LILBASIC        LilBasic (c)2002                                                                              PAGE 13

0197 80F6       =1   673            SJMP    STRO_1          ;Loop until done.
                =1   674    ;
0199 312A       =1   675    STRO_2: CALL    C_OUT           ;Output Last character.
019B E4         =1   676            CLR     A
019C 73         =1   677            JMP     @A+DPTR         ;Return to program.
                =1   678    ;
                     679    ;=======
                     680    ;STROUT2
                     681    ;       Copy character string to console output device.
                     682    ;       Start @ DPTR
                     683    ;       Stop at char  00H
                     684    ;       255 char limit on length of text!
                =1   685    $INCLUDE(BIOS\STROUT2.ASM)      ;USES C_OUT
                =1   686    ;STROUT2
                =1   687    ;       Copy character string to console output device.
                =1   688    ;       Start @ DPTR
                =1   689    ;       Stop at char  00H
                =1   690    ;       255 char limit on length of text!
                =1   691    ;
019D            =1   692    STROUT2:
019D E4         =1   693            CLR     A
019E 93         =1   694            MOVC    A,@A+DPTR       ;Read next byte.
019F 312A       =1   695            CALL    C_OUT           ;Output character.
01A1 A3         =1   696            INC     DPTR            ;Get next char.
01A2 B400F8     =1   697            CJNE    a,#00H,STROUT2
01A5 22         =1   698            RET                     ;Return To Program
                     699    ;=======
                     700    ;wait1ms
                     701    ;       Wait one MS and exit with out changing anything!!!!
                     702    ;       Assumes:  Clock fq=11.0592mhz
                     703    ;                 1.089us per mcycle  (1us if 12mhz xtal)
                     704    ;                 1ms = 1000us
                     705    ;                 918.2736 mcycles = 1ms
                =1   706    $INCLUDE(BIOS\1ms.ASM)      ;USES C_OUT
                =1   707    
01A6            =1   708    WAIT1MS:
                =1   709    ;         ÿÿÿÿWait one MS and exit with out changing anything!!!!
                =1   710    ;       Assumes:  Clock fq=11.0592mhz
                =1   711    ;                 1.089us per mcycle  (1us if 12mhz xtal)
                =1   712    ;                 1ms = 1000us
                =1   713    ;                 918.2736 mcycles = 1ms
                =1   714    ;                2754.8209 mcycles = 3ms
                =1   715    ;                4591.3680 mcycles = 5ms
                =1   716    
                =1   717                                    ;(2) Two cycles required to call this subroutine
                =1   718    
01A6 00         =1   719            nop                     ;(1) Total of 10 Overhead cycles
01A7 00         =1   720            nop                     ;(1)
01A8            =1   721    WAITMS:
01A8 00         =1   722            nop                     ;(1)
                =1   723    
01A9 C0E0       =1   724            PUSH ACC                ;(2) Save Registers    ( A --> stack)
01AB CA         =1   725            XCH A,R2                ;(1)                   (R2 --> A)
                =1   726    
01AC 7AE4       =1   727            MOV R2,#228             ;(1) wait (226 *4)+14 = 918 mcycles
                =1   728    
                =1   729    
01AE            =1   730    WAIT1MS_LOOP2:                  ;    wait 4 * R2 mcycles
LILBASIC        LilBasic (c)2002                                                                              PAGE 14

01AE 00         =1   731            nop                     ;    (1)
01AF 00         =1   732            nop                     ;    (1)
01B0 DAFC       =1   733            DJNZ R2,wait1ms_loop2   ;    (2)
                =1   734    
                =1   735    
01B2 CA         =1   736            XCH A,R2                ;(1) Restore Registers (R2 <-- A)
01B3 D0E0       =1   737            POP ACC                 ;(2)                   (A <-- Stack)
                =1   738    
01B5 22         =1   739            RET                     ;(2)
                =1   740    
                =1   741    
                =1   742    
01B6            =1   743    WAIT5MS:                       ; 4591 mcycles =  4.9996ms
01B6 31A8       =1   744            CALL waitms ;(2)+916ms
01B8 31A8       =1   745            CALL waitms ;(2)+916ms
01BA            =1   746    WAIT3MS:                       ; 2755 mcycles =  3.0002ms
01BA 00         =1   747            nop         ;(1)
01BB 31A8       =1   748            CALL waitms ;(2)+916ms
01BD 31A8       =1   749            CALL waitms ;(2)+916ms
01BF 80E7       =1   750            sjmp waitms ;(2)+916ms
                =1   751    ;
                     752    ;=======
                     753    ;
                     754    ;       ARITHMETIC SUBROUTINE PACKAGE
                     755    ;
                     756    ;=======
                     757    ;POP_TOS:
                     758    ;       Verify that stack holds at least on (16-bit) entry.
                     759    ;       (Call AES_ER otherwise.)
                     760    ;       Pop TOS into registers TOS_H and TOS_L,
                     761    ;       update AESP,
                     762    ;       and return with R1 pointing to low-order byte of previous NOS.
                     763    ;       Do not affect accumulator contents.
                =1   764    $INCLUDE(AES\POP_TOS.ASM)
01C1            =1   765    POP_TOS:
                =1   766    ;       Verify that stack holds at least on (16-bit) entry.
                =1   767    ;       (Call AES_ER otherwise.)
                =1   768    ;       Pop TOS into registers TOS_H and TOS_L,
                =1   769    ;       update AESP,
                =1   770    ;       and return with R1 pointing to low-order byte of previous NOS.
                =1   771    ;       Do not affect accumulator contents.
                =1   772    ;
                =1   773 +1         PAGE    #0H             ;ZERO PAGE for AES
01C1 75A000     =1   774 +1         MOV     P2,#0H
01C4 A91D       =1   776            MOV     R1,AESP         ;Get current stack pos.
01C6 B90100     =1   777            CJNE    R1,#01H,$+3     ;Compare pointer with min. legal level.
01C9 4027       =1   778            JC      STK_ER          ;If <1 goto error
01CB FE         =1   779            MOV     TOS_L,A         ;Save Tos
01CC E3         =1   780            MOVX    A,@R1           ;Get High Byte
01CD FF         =1   781            MOV     TOS_H,A
01CE 19         =1   782            DEC     R1
01CF E3         =1   783            MOVX    A,@R1           ;Get Low Byte
01D0 CE         =1   784            XCH     A,TOS_L         ;Store byte and reload ACC.
01D1 19         =1   785            DEC     R1
01D2 891D       =1   786            MOV     AESP,R1
01D4 19         =1   787            DEC     R1              ; ?????? whaddup?
01D5 22         =1   788            RET
                =1   789    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 15

                     790    ;=======
                     791    ;POP_ACC:
                     792    ;       Pop TOS into accumulator and update AESP.
                =1   793    $INCLUDE(AES\POP_ACC.ASM)
01D6            =1   794    POP_ACC:
                =1   795    ;       Pop TOS into accumulator and update AESP.
                =1   796    ;
                =1   797 +1         PAGE    #0H             ;ZERO PAGE for AES
01D6 75A000     =1   798 +1         MOV     P2,#0H
01D9 A91D       =1   800            MOV     R1,AESP
01DB E3         =1   801            MOVX    A,@R1
01DC 151D       =1   802            DEC     AESP
01DE 22         =1   803            RET
                =1   804    ;
                     805    ;=======
                     806    ;PUSH_TOS:
                     807    ;       Verify that the AES is not full,
                     808    ;       push registers TOS_H and TOS_L onto AES,
                     809    ;       and update AESP.
                =1   810    $INCLUDE(AES\PUSH_TOS.ASM)
01DF            =1   811    PUSH_TOS:
                =1   812    ;       Verify that the AES is not full,
                =1   813    ;       push registers TOS_H and TOS_L onto AES,
                =1   814    ;       and update AESP.
                =1   815    ;
                =1   816 +1         PAGE    #0H             ;ZERO PAGE for AES
01DF 75A000     =1   817 +1         MOV     P2,#0H
01E2 A91D       =1   819            MOV     R1,AESP
01E4 B9FD00     =1   820            CJNE    R1,#0FDH,$+3    ;Compare pointer with max. legal level.
01E7 5009       =1   821            JNC     STK_ER
01E9 09         =1   822            INC     R1
01EA EE         =1   823            MOV     A,TOS_L         ;Push low-order byte.
01EB F3         =1   824            MOVX    @R1,A
01EC 09         =1   825            INC     R1
01ED EF         =1   826            MOV     A,TOS_H         ;Push high-order byte.
01EE F3         =1   827            MOVX    @R1,A
01EF 891D       =1   828            MOV     AESP,R1
01F1 22         =1   829            RET
                =1   830    ;
01F2 120FDD     =1   831    STK_ER: CALL    AES_ER
01F5 0F         =1   832            DB      0FH
                =1   833    ;
                     834    ;=======
                     835    ;DUP:   (K)
                     836    ;       Verify that the AES is not full,
                     837    ;       then duplicate the top element and update AESP.
                =1   838    $INCLUDE(AES\DUP.ASM)
01F6            =1   839    DUP:
                =1   840    ;       Verify that the AES is not full,
                =1   841    ;       then duplicate the top element and update AESP.
                =1   842    ;
                =1   843 +1         PAGE    #0H             ;ZERO PAGE for AES
01F6 75A000     =1   844 +1         MOV     P2,#0H
01F9 A91D       =1   846            MOV     R1,AESP
01FB B9FD00     =1   847            CJNE    R1,#0FDH,$+3    ;Compare pointer with max. legal level.
01FE 50F2       =1   848            JNC     STK_ER
                =1   849    
0200 D082       =1   850            POP     DPL
LILBASIC        LilBasic (c)2002                                                                              PAGE 16

0202 D083       =1   851            POP     DPH
0204 E4         =1   852            CLR     A
0205 93         =1   853            MOVC    A,@A+DPTR       ;Read next character from in-line code.
                =1   854    
0206 29         =1   855            ADD     A,R1            ;Compute offset
0207 F9         =1   856            MOV     R1,A            ;save in register
0208 E3         =1   857            MOVX    A,@R1           ;copy byte
0209 A91D       =1   858            MOV     R1,AESP         ;Get current Pos
020B 09         =1   859            INC     R1              ;Bump pointer to next #.
020C F3         =1   860            MOVX    @R1,A           ;Store Byte
020D 891D       =1   861            MOV     AESP,R1         ;Save stack pointer.
020F 22         =1   862            RET
                =1   863    ;
                     864    ;=======
                     865    ;LIT:    (K)
                     866    ;       Report error if arithmetic expression stack is full.
                     867    ;       Otherwise push the one-byte constant K onto AES.
                     868    ;       Return with carry=1, since LIT marks a successful match.
                =1   869    $INCLUDE(AES\LIT.ASM)
                =1   870    ;LIT:    (K)
                =1   871    ;       Report error if arithmetic expression stack is full.
                =1   872    ;       Otherwise push the one-byte constant K onto AES.
                =1   873    ;       Return with carry=1, since LIT marks a successful match.
                =1   874    ;
                =1   875 +1 LIT:    PAGE    #0H             ;ZERO PAGE for AES
0210 75A000     =1   876 +1         MOV     P2,#0H
                =1   878    
0213 D083       =1   879            POP     DPH             ;Get parameter address.
0215 D082       =1   880            POP     DPL
                =1   881    
0217 E4         =1   882            CLR     A
0218 93         =1   883            MOVC    A,@A+DPTR       ;Read literal value.
0219 051D       =1   884            INC     AESP            ;Reserve storage on top of AES.
021B A91D       =1   885            MOV     R1,AESP         ;Point to free entry on stack.
021D B9FF03     =1   886            CJNE    R1,#0FFH,LIT_1
0220 020FDD     =1   887            JMP     AES_ER
                =1   888    ;
0223 F3         =1   889    LIT_1:  MOVX    @R1,A           ;Store literal.
0224 7401       =1   890            MOV     A,#1            ;Branch over constant on return.
0226 D3         =1   891            SETB    C
0227 73         =1   892            JMP     @A+DPTR         ;Return to IL program.
                =1   893    ;
                     894    ;=======
                     895    
                     896    ;
                     897    ;       BASIC VARIABLE ACCESSING OPERATIONS
                     898    ;       ===== ======== ========= ==========
                     899    ;=======
                     900    ;Special Function Register Table
                =1   901    $INCLUDE(AES\SFR_TBL.ASM)
                =1   902    ;       Direct address mode emulation tables:
                =1   903    ;
0228 80         =1   904    SFRTBL: DB      80H
0229 90         =1   905            DB      90H
022A A0         =1   906            DB      0A0H
022B B0         =1   907            DB      0B0H
022C 88         =1   908            DB      88H
022D 98         =1   909            DB      98H
LILBASIC        LilBasic (c)2002                                                                              PAGE 17

022E A8         =1   910            DB      0A8H
022F B8         =1   911            DB      0B8H
0230 89         =1   912            DB      89H
0231 8A         =1   913            DB      8AH
0232 8B         =1   914            DB      8BH
0233 8C         =1   915            DB      8CH
0234 8D         =1   916            DB      8DH
0235 99         =1   917            DB      99H
  000E          =1   918    NO_SFR  EQU     $-SFRTBL
                =1   919    ;
                =1   920    ;===
                =1   921    ;
0236 8E80       =1   922    STRTBL: MOV     80H,TOS_L
0238 22         =1   923            RET
0239 8E90       =1   924            MOV     90H,TOS_L
023B 22         =1   925            RET
023C 8EA0       =1   926            MOV     0A0H,TOS_L
023E 22         =1   927            RET
023F 8EB0       =1   928            MOV     0B0H,TOS_L
0241 22         =1   929            RET
0242 8E88       =1   930            MOV     88H,TOS_L
0244 22         =1   931            RET
0245 8E98       =1   932            MOV     98H,TOS_L
0247 22         =1   933            RET
0248 8EA8       =1   934            MOV     0A8H,TOS_L
024A 22         =1   935            RET
024B 8EB8       =1   936            MOV     0B8H,TOS_L
024D 22         =1   937            RET
024E 8E89       =1   938            MOV     89H,TOS_L
0250 22         =1   939            RET
0251 8E8A       =1   940            MOV     8AH,TOS_L
0253 22         =1   941            RET
0254 8E8B       =1   942            MOV     8BH,TOS_L
0256 22         =1   943            RET
0257 8E8C       =1   944            MOV     8CH,TOS_L
0259 22         =1   945            RET
025A 8E8D       =1   946            MOV     8DH,TOS_L
025C 22         =1   947            RET
025D 8E99       =1   948            MOV     99H,TOS_L
025F 22         =1   949            RET
                =1   950    ;
                =1   951    ;===
                =1   952    ;
0260 E580       =1   953    INDTBL: MOV     A,80H
0262 22         =1   954            RET
0263 E590       =1   955            MOV     A,90H
0265 22         =1   956            RET
0266 E5A0       =1   957            MOV     A,0A0H
0268 22         =1   958            RET
0269 E5B0       =1   959            MOV     A,0B0H
026B 22         =1   960            RET
026C E588       =1   961            MOV     A,88H
026E 22         =1   962            RET
026F E598       =1   963            MOV     A,98H
0271 22         =1   964            RET
0272 E5A8       =1   965            MOV     A,0A8H
0274 22         =1   966            RET
0275 E5B8       =1   967            MOV     A,0B8H
LILBASIC        LilBasic (c)2002                                                                              PAGE 18

0277 22         =1   968            RET
0278 E589       =1   969            MOV     A,89H
027A 22         =1   970            RET
027B E58A       =1   971            MOV     A,8AH
027D 22         =1   972            RET
027E E58B       =1   973            MOV     A,8BH
0280 22         =1   974            RET
0281 E58C       =1   975            MOV     A,8CH
0283 22         =1   976            RET
0284 E58D       =1   977            MOV     A,8DH
0286 22         =1   978            RET
0287 E599       =1   979            MOV     A,99H
0289 22         =1   980            RET
                =1   981    ;
                     982    ;=======
                     983    ;SFR_ID:
                     984    ;       Identify which SFR is indicated by the contents of R1.
                     985    ;       Return with acc holding (Index of said register)*3.
                     986    ;       Call error routine if register number not found.
                =1   987    $INCLUDE(AES\SFR_ID.ASM)
028A            =1   988    SFR_ID:
                =1   989    ;       Identify which SFR is indicated by the contents of R1.
                =1   990    ;       Return with acc holding (Index of said register)*3.
                =1   991    ;       Call error routine if register number not found.
                =1   992    ;
028A 900228     =1   993            MOV     DPTR,#SFRTBL
028D E4         =1   994            CLR     A
028E FD         =1   995            MOV     LP_CNT,A
028F ED         =1   996    SFID_1: MOV     A,LP_CNT
0290 93         =1   997            MOVC    A,@A+DPTR
0291 69         =1   998            XRL     A,R1
0292 7004       =1   999            JNZ     SFID_2
0294 ED         =1  1000            MOV     A,LP_CNT
0295 23         =1  1001            RL      A
0296 2D         =1  1002            ADD     A,LP_CNT
0297 22         =1  1003            RET
                =1  1004    ;
0298 0D         =1  1005    SFID_2: INC     LP_CNT
0299 ED         =1  1006            MOV     A,LP_CNT
029A B40EF2     =1  1007            CJNE    A,#NO_SFR,SFID_1
029D 020FBD     =1  1008    ADR_ER: JMP     EXP_ER
                =1  1009    ;
                    1010    ;=======
                    1011    ;STRDIR:
                    1012    ;       Store data byte in ACC into direct on-chip RAM (and SFR) address held in R1.
                =1  1013    $INCLUDE(AES\STR_DIR.ASM)
02A0            =1  1014    STRDIR:
                =1  1015    ;       Store data byte in ACC into direct on-chip RAM address held in R1.
                =1  1016    ;
02A0 FE         =1  1017            MOV     TOS_L,A
02A1 E9         =1  1018            MOV     A,R1
02A2 20E703     =1  1019            JB      ACC.7,STRSFR    ;Direct addresses above 7FH are SFRs.
02A5 EE         =1  1020            MOV     A,TOS_L
02A6 F7         =1  1021            MOV     @R1,A           ;Store low-order byte in RAM.
02A7 22         =1  1022            RET
                =1  1023    ;
02A8 518A       =1  1024    STRSFR: CALL    SFR_ID
02AA 900236     =1  1025            MOV     DPTR,#STRTBL
LILBASIC        LilBasic (c)2002                                                                              PAGE 19

02AD 73         =1  1026            JMP     @A+DPTR         ;Jump into store sequence.
                    1027    ;=======
                    1028    ;FETDIR:
                    1029    ;       Fetch on-chip directly addressed byte (and SFR)indicated by R1 into Acc.
                =1  1030    $INCLUDE(AES\FET_DIR.ASM)
02AE            =1  1031    FETDIR:
                =1  1032    ;       Fetch on-chip directly addressed byte indicated by R1 into Acc.
                =1  1033    ;       and return.
                =1  1034    ;
                =1  1035    
02AE E9         =1  1036            MOV     A,R1
02AF 20E702     =1  1037            JB      ACC.7,FETSFR
02B2 E7         =1  1038            MOV    A,@R1
02B3 22         =1  1039            RET
                =1  1040    ;
02B4 518A       =1  1041    FETSFR: CALL    SFR_ID
02B6 900260     =1  1042            MOV     DPTR,#INDTBL
02B9 73         =1  1043            JMP     @A+DPTR
                =1  1044    ;
                    1045    ;=======
                    1046    ;SPLIT_DBA:
                    1047    ;       Called with TOS_L containing a direct on-chip bit address.
                    1048    ;       Return the direct &byte& address of encompassing
                    1049    ;       register in R1, and load B with a mask containing a single 1
                    1050    ;       corresponding to the bit's position in a field of zeroes.
                =1  1051    $INCLUDE(AES\SPL_DBA.ASM)
                =1  1052    ;
02BA            =1  1053    SPLIT_DBA:
                =1  1054    ;       Called with TOS_L containing a direct on-chip bit address.
                =1  1055    ;       Return the direct &byte& address of encompassing
                =1  1056    ;       register in R1, and load B with a mask containing a single 1
                =1  1057    ;       corresponding to the bit's position in a field of zeroes.
                =1  1058    ;
02BA EE         =1  1059            MOV     A,TOS_L
02BB 54F8       =1  1060            ANL     A,#11111000B
02BD 20E704     =1  1061            JB      ACC.7,SPLSFR
02C0 23         =1  1062            RL      A
02C1 C4         =1  1063            SWAP    A
02C2 2420       =1  1064            ADD     A,#20H          ;Address of bit-address space.
02C4 F9         =1  1065    SPLSFR: MOV     R1,A
02C5 EE         =1  1066            MOV     A,TOS_L
02C6 5407       =1  1067            ANL     A,#07H          ;Mask off bit-displacement field.
02C8 2403       =1  1068            ADD     A,#MSKTBL-MSK_PC
02CA 83         =1  1069            MOVC    A,@A+PC         ;Read mask byte.
02CB            =1  1070    MSK_PC:
02CB F5F0       =1  1071            MOV     B,A
02CD 22         =1  1072            RET
                    1073    ;=======
                    1074    ;MSKTBL:
                    1075    ;       Mask Table for 2^x
                =1  1076    $INCLUDE(AES\MSK_TBL.ASM)
02CE            =1  1077    MSKTBL:
02CE 01         =1  1078            DB      00000001B
02CF 02         =1  1079            DB      00000010B
02D0 04         =1  1080            DB      00000100B
02D1 08         =1  1081            DB      00001000B
02D2 10         =1  1082            DB      00010000B
02D3 20         =1  1083            DB      00100000B
LILBASIC        LilBasic (c)2002                                                                              PAGE 20

02D4 40         =1  1084            DB      01000000B
02D5 80         =1  1085            DB      10000000B
                    1086    ;=======
                    1087    ;SEQ_STORE:
                    1088    ;       Same as STORE, below, except that index is retained
                    1089    ;       rather than being popped.
                    1090    ;STORE:
                    1091    ;       When STORE is called, AES contains
                    1092    ;       (TOS:)  2 byte VALUE to be stored,
                    1093    ;               2 byte INDEX of destination variable,
                    1094    ;               1 byte TYPE code for variable space.
                    1095    ;                       (0=BASIC variable,
                    1096    ;                        1=DBYTE,
                    1097    ;                        2=RBIT,
                    1098    ;                        3=XBYTE,
                    1099    ;                        4=CBYTE.)
                    1100    ;       Store (VAR_1) into appropriate variable memory at location of (INDEX).
                =1  1101    $INCLUDE(AES\STORE.ASM)
                =1  1102    ;
                =1  1103    ;
02D6            =1  1104    SEQ_STORE:
                =1  1105    ;       Same as STORE, below, except that index is retained
                =1  1106    ;       rather than being popped.
02D6 D25B       =1  1107            SETB    SEQ_FLG
02D8 8002       =1  1108            SJMP    STOR_0
                =1  1109    
                =1  1110    
02DA            =1  1111    STORE:
                =1  1112    ;       When STORE is called, AES contains
                =1  1113    ;       (TOS:)  2 byte VALUE to be stored,
                =1  1114    ;               2 byte INDEX of destination variable,
                =1  1115    ;               1 byte TYPE code for variable space.
                =1  1116    ;                       (0=BASIC variable,
                =1  1117    ;                        1=DBYTE,
                =1  1118    ;                        2=RBIT,
                =1  1119    ;                        3=XBYTE,
                =1  1120    ;                        4=CBYTE.)
                =1  1121    ;       Store (VAR_1) into appropriate variable memory at location of (INDEX).
                =1  1122    ;
02DA C25B       =1  1123            CLR     SEQ_FLG
02DC 31C1       =1  1124    STOR_0: CALL    POP_TOS
02DE 8E08       =1  1125            MOV     TMP0,TOS_L
02E0 8F09       =1  1126            MOV     TMP1,TOS_H
02E2 31C1       =1  1127            CALL    POP_TOS
02E4 31D6       =1  1128            CALL    POP_ACC         ;Load TYPE code.
02E6 305B06     =1  1129            JNB     SEQ_FLG,STOR_1  ;Jump forward if simple store.
02E9 051D       =1  1130            INC     AESP
02EB 051D       =1  1131            INC     AESP
02ED 051D       =1  1132            INC     AESP
                =1  1133    
                =1  1134    
02EF 9002F4     =1  1135    STOR_1: MOV     DPTR,#STRJTB
02F2 93         =1  1136            MOVC    A,@A+DPTR
02F3 73         =1  1137            JMP     @A+DPTR
                =1  1138    ;
02F4 05         =1  1139    STRJTB: DB      STRVAR-STRJTB
02F5 1E         =1  1140            DB      STRDBY-STRJTB
02F6 24         =1  1141            DB      STRRBI-STRJTB
LILBASIC        LilBasic (c)2002                                                                              PAGE 21

02F7 39         =1  1142            DB      STRXBY-STRJTB
02F8 39         =1  1143            DB      STRCBY-STRJTB
                =1  1144    ;
                =1  1145    ;=======
                =1  1146    ;
                =1  1147    ;       All of the following routines are called with
                =1  1148    ;       TOS_L holding the low-order address of the destination,
                =1  1149    ;       TOS_H holding the high-order address (if necessary),
                =1  1150    ;       and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
                =1  1151    ;
02F9 EE         =1  1152    STRVAR: MOV     A,TOS_L         ;Get Low byte of Variable number 0 to 25
02FA C3         =1  1153            CLR     C               ;Clear carry bit.
02FB 33         =1  1154            RLC     A               ;Multiply by two for 2 byte wide variables.  (0 - 50)
02FC F9         =1  1155            MOV     R1,A            ;Move A into R1
02FD EF         =1  1156            MOV     A,TOS_H         ;Get High byte of Variable number.
02FE 33         =1  1157            RLC     A               ;Multiply by 2 also
                =1  1158    
02FF C3         =1  1159            CLR     C               ;Clear carry bit again before adding offset
0300 C9         =1  1160            XCH     A,R1            ;Swap bytes to get low byte again
                =1  1161    
0301 3400       =1  1162            ADDC    A,#LOW(VARRAM)  ;Add offset to variable table in ram
0303 F582       =1  1163            MOV     DPL,A           ;Save low byte of data pointer
                =1  1164    
0305 E9         =1  1165            MOV     A,R1            ;Get Highbyte
0306 341C       =1  1166            ADDC    A,#HIGH(VARRAM) ;Add offset (with carry bit) to var. table
0308 F583       =1  1167            MOV     DPH,A           ;Save High byte of data pointer
                =1  1168    
                =1  1169    
030A E508       =1  1170            MOV     A,TMP0          ;Get lowbyte of value
                =1  1171    
030C F0         =1  1172            MOVX    @DPTR,A         ;Store into variable array
030D A3         =1  1173            INC     DPTR            ;Bump pointer to next byte.
030E E509       =1  1174            MOV     A,TMP1          ;Move high-order byte into variable array.
0310 F0         =1  1175            MOVX    @DPTR,A
0311 22         =1  1176            RET
                =1  1177    ;
                =1  1178    ;===
                =1  1179    ;
0312 EE         =1  1180    STRDBY: MOV     A,TOS_L         ;Load acc. with low-order dest. addr.
0313 F9         =1  1181            MOV     R1,A
0314 E508       =1  1182            MOV     A,TMP0
0316 8088       =1  1183            JMP     STRDIR
                =1  1184    ;
                =1  1185    ;===
                =1  1186    ;
0318 51BA       =1  1187    STRRBI: CALL    SPLIT_DBA
031A 51AE       =1  1188            CALL    FETDIR
031C FE         =1  1189            MOV     TOS_L,A
031D E508       =1  1190            MOV     A,TMP0
031F 20E006     =1  1191            JB      ACC.0,SETRBI
                =1  1192    ;
                =1  1193    ;       Clear RBIT.
                =1  1194    ;
0322 E5F0       =1  1195            MOV     A,B
0324 F4         =1  1196            CPL     A
0325 5E         =1  1197            ANL     A,TOS_L
0326 41A0       =1  1198            JMP     STRDIR
                =1  1199    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 22

0328 E5F0       =1  1200    SETRBI: MOV     A,B
032A 4E         =1  1201            ORL     A,TOS_L
032B 41A0       =1  1202            JMP     STRDIR
                =1  1203    ;
                =1  1204    ;===
                =1  1205    ;
032D            =1  1206    STRXBY:
032D 8F83       =1  1207    STRCBY: MOV     DPH,TOS_H
032F 8E82       =1  1208            MOV     DPL,TOS_L
0331 E508       =1  1209            MOV     A,TMP0
0333 F0         =1  1210            MOVX    @DPTR,A
0334 22         =1  1211            RET
                =1  1212    ;
                    1213    ;===============
                    1214    ;SEQ_FETCH:
                    1215    ;       Same as FETCH, below, except that index is retained
                    1216    ;       rather than being popped.
                    1217    ;FETCH:
                    1218    ;       When FETCH is called, AES contains
                    1219    ;       (TOS:)  2 byte INDEX of source variable,
                    1220    ;               1 byte TYPE code for variable space.
                    1221    ;                       (0=BASIC variable,
                    1222    ;                        1=DBYTE,
                    1223    ;                        2=RBIT,
                    1224    ;                        3=XBYTE,
                    1225    ;                        4=CBYTE.)
                    1226    ;       Read 8- or 16-bit variable from the appropriate variable
                    1227    ;       memory at location of (INDEX) and return on AES.
                =1  1228    $INCLUDE(AES\FETCH.ASM)
0335            =1  1229    SEQ_FETCH:
                =1  1230    ;       Same as FETCH, below, except that index is retained
                =1  1231    ;       rather than being popped.
0335 D25B       =1  1232            SETB    SEQ_FLG
0337 8002       =1  1233            SJMP    FET_0
                =1  1234    ;
                =1  1235    ;
0339            =1  1236    FETCH:
                =1  1237    ;       When FETCH is called, AES contains
                =1  1238    ;       (TOS:)  2 byte INDEX of source variable,
                =1  1239    ;               1 byte TYPE code for variable space.
                =1  1240    ;                       (0=BASIC variable,
                =1  1241    ;                        1=DBYTE,
                =1  1242    ;                        2=RBIT,
                =1  1243    ;                        3=XBYTE,
                =1  1244    ;                        4=CBYTE.)
                =1  1245    ;       Read 8- or 16-bit variable from the appropriate variable
                =1  1246    ;       memory at location of (INDEX) and return on AES.
                =1  1247    ;
0339 C25B       =1  1248            CLR     SEQ_FLG
033B 31C1       =1  1249    FET_0:  CALL    POP_TOS
033D 31D6       =1  1250            CALL    POP_ACC
033F 305B06     =1  1251            JNB     SEQ_FLG,FET_1   ;Jump forward if simple store.
0342 051D       =1  1252            INC     AESP
0344 051D       =1  1253            INC     AESP
0346 051D       =1  1254            INC     AESP
0348 90034D     =1  1255    FET_1:  MOV     DPTR,#FETJTB
034B 93         =1  1256            MOVC    A,@A+DPTR
034C 73         =1  1257            JMP     @A+DPTR
LILBASIC        LilBasic (c)2002                                                                              PAGE 23

                =1  1258    ;
034D 05         =1  1259    FETJTB: DB      FETVAR-FETJTB
034E 1F         =1  1260            DB      FETDBY-FETJTB
034F 25         =1  1261            DB      FETRBI-FETJTB
0350 31         =1  1262            DB      FETXBY-FETJTB
0351 38         =1  1263            DB      FETCBY-FETJTB
                =1  1264    ;
                =1  1265    ;=======
                =1  1266    ;
                =1  1267    ;       All of the following routines are called with
                =1  1268    ;       TOS_L holding the low-order index of the desired variable,
                =1  1269    ;       and TOS_H holding the high-order index (if necessary).
                =1  1270    ;
0352 EE         =1  1271    FETVAR: MOV     A,TOS_L         ;Get Low Byte of var #
0353 C3         =1  1272            CLR     C               ;Clear carry bit
0354 33         =1  1273            RLC     A               ;Multiply by 2 for 16bit vars.
0355 F9         =1  1274            MOV     R1,A            ;Save in R1.
                =1  1275    
0356 EF         =1  1276            MOV     A,TOS_H         ;Get High byte
0357 33         =1  1277            RLC     A               ;Multiply High byte.
                =1  1278    
0358 C3         =1  1279            CLR     C               ;Clear carry bit again for 16bit add
0359 C9         =1  1280            XCH     A,R1            ;Swap bytes to get high byte again
                =1  1281    
035A 3400       =1  1282            ADDC    A,#LOW(VARRAM)  ;Add offset to low byte
035C F582       =1  1283            MOV     DPL,A           ;Save low byte address of pointer
                =1  1284    
035E E9         =1  1285            MOV     A,R1            ;Get high byte
035F 341C       =1  1286            ADDC    A,#HIGH(VARRAM) ;Add offset
0361 F583       =1  1287            MOV     DPH,A           ;Save high byte address of pointer
                =1  1288    
0363 E0         =1  1289            MOVX    A,@DPTR         ;Load low-order byte of variable.
0364 FE         =1  1290            MOV     TOS_L,A         ;And store on AES.
0365 A3         =1  1291            INC     DPTR            ;bump data pointer.
0366 E0         =1  1292            MOVX    A,@DPTR         ;Transfer high-order byte of variable.
0367 FF         =1  1293            MOV     TOS_H,A
0368 21DF       =1  1294            JMP     PUSH_TOS
                =1  1295    ;
036A 419D       =1  1296    FETERR: JMP     ADR_ER
                =1  1297    ;
                =1  1298    ;===
                =1  1299    ;
036C EE         =1  1300    FETDBY: MOV     A,TOS_L
036D F9         =1  1301            MOV     R1,A
036E 51AE       =1  1302            CALL    FETDIR
0370 8019       =1  1303            SJMP    FETBDN          ;Byte fetch done.
                =1  1304    ;
                =1  1305    ;===
                =1  1306    ;
0372 51BA       =1  1307    FETRBI: CALL    SPLIT_DBA
0374 51AE       =1  1308            CALL    FETDIR
0376 55F0       =1  1309            ANL     A,B
0378 24FF       =1  1310            ADD     A,#0FFH
037A E4         =1  1311            CLR     A
037B 33         =1  1312            RLC     A
037C 800D       =1  1313            SJMP    FETBDN
                =1  1314    ;
                =1  1315    ;===
LILBASIC        LilBasic (c)2002                                                                              PAGE 24

                =1  1316    ;
037E 8F83       =1  1317    FETXBY: MOV     DPH,TOS_H
0380 8E82       =1  1318            MOV     DPL,TOS_L
0382 E0         =1  1319            MOVX    A,@DPTR
0383 8006       =1  1320            SJMP    FETBDN
                =1  1321    ;
                =1  1322    ;===
                =1  1323    ;
0385 8F83       =1  1324    FETCBY: MOV     DPH,TOS_H
0387 8E82       =1  1325            MOV     DPL,TOS_L
0389 E4         =1  1326            CLR     A
038A 93         =1  1327            MOVC    A,@A+DPTR
038B 7F00       =1  1328    FETBDN: MOV     TOS_H,#00H      ;FETCH sequence for Bytes Done.
038D FE         =1  1329            MOV     TOS_L,A         ;FETCH sequence for words done.
038E 21DF       =1  1330            JMP     PUSH_TOS
                =1  1331    ;
                    1332    ;=======
                    1333    ;CREATE
                    1334    ;       Test the contents of Acc.
                    1335    ;       If CHAR holds the ASCII code for a legitimate decimal digit,
                    1336    ;       create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
                    1337    ;       and return with CY set.
                    1338    ;       Otherwise, return with CY cleared.
                =1  1339    $INCLUDE(AES\CREATE.ASM)
                =1  1340    ;CREATE
                =1  1341    ;       Test the contents of Acc.
                =1  1342    ;       If CHAR holds the ASCII code for a legitimate decimal digit,
                =1  1343    ;       create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
                =1  1344    ;       and return with CY set.
                =1  1345    ;       Otherwise, return with CY cleared.
                =1  1346    ;
0390 24D0       =1  1347    CREATE: ADD     A,#-'0'         ;Correct for ASCII digit offset.
0392 B40A00     =1  1348            CJNE    A,#10,$+3       ;Compare to maximum legal digit.
0395 5005       =1  1349            JNC     CREA_1          ;Abort if first char is not decimal digit.
0397 FE         =1  1350            MOV     TOS_L,A         ;Save initial digit read.
0398 7F00       =1  1351            MOV     TOS_H,#0        ;Clear high-order bits.
039A C25D       =1  1352            CLR     H_FLG
039C 22         =1  1353    CREA_1: RET
                =1  1354    ;
                    1355    ;===============
                    1356    ;APPEND
                    1357    ;       Test ASCII code in Acc.
                    1358    ;       If it is a legal digit in the current radix,
                    1359    ;       modify <TOS_H><TOS_L> to include this digit and return with CY set.
                    1360    ;       Otherwise leave AES and CHAR unchanged and return with CY cleared.
                    1361    ;       Operating mode determined by HEXMOD flag (1=Hex).
                =1  1362    $INCLUDE(AES\APPEND.ASM)
                =1  1363    ;APPEND
                =1  1364    ;       Test ASCII code in Acc.
                =1  1365    ;       If it is a legal digit in the current radix,
                =1  1366    ;       modify <TOS_H><TOS_L> to include this digit and return with CY set.
                =1  1367    ;       Otherwise leave AES and CHAR unchanged and return with CY cleared.
                =1  1368    ;       Operating mode determined by HEXMOD flag (1=Hex).
                =1  1369    ;
039D 205D3E     =1  1370    APPEND: JB      H_FLG,APND_2    ;Nothing allowed after trailing 'H' received.
03A0 24D0       =1  1371            ADD     A,#-'0'         ;Correct for ASCII offset.
03A2 B40A00     =1  1372            CJNE    A,#10,$+3       ;Verify whether legal digit.
03A5 4013       =1  1373            JC      APND_1          ;Insert decimal digit as is.
LILBASIC        LilBasic (c)2002                                                                              PAGE 25

03A7 305434     =1  1374            JNB     HEXMOD,APND_2   ;If in decimal mode, character isn't legal.
03AA 24EF       =1  1375            ADD     A,#'0'-'A'      ;Acc now equals 0 if 'A' received.
03AC B40600     =1  1376            CJNE    A,#6,$+3
03AF 4007       =1  1377            JC      APND_4          ;Process Hex digit.
                =1  1378    ;
                =1  1379    ;       Char was not hexidecimal digit, but if it was the first 'H', that's OK.
                =1  1380    ;
03B1 B4072A     =1  1381            CJNE    A,#'H'-'A',APND_2       ;Compare original input with 'H'.
03B4 D25D       =1  1382            SETB    H_FLG           ;Mark that 'H' was detected but don't process.
03B6 D3         =1  1383            SETB    C
03B7 22         =1  1384            RET
                =1  1385    ;
03B8 240A       =1  1386    APND_4: ADD     A,#10           ;Value of lowest hex digit.
03BA CE         =1  1387    APND_1: XCH     A,TOS_L         ;Save nibble to be appended.
03BB 75F00A     =1  1388            MOV     B,#10           ;(Assuming radix=decimal.)
03BE 305403     =1  1389            JNB     HEXMOD,XRAD_1   ;Skip ahead if assumption correct.
03C1 75F010     =1  1390            MOV     B,#16           ;If mode is actually hex.
03C4 C0F0       =1  1391    XRAD_1: PUSH    B               ;Save for re-use.
03C6 A4         =1  1392            MUL     AB              ;Multiply by radix.
03C7 2E         =1  1393            ADD     A,TOS_L         ;Append new digit.
03C8 FE         =1  1394            MOV     TOS_L,A         ;Save low-order shifted value.
03C9 E4         =1  1395            CLR     A
03CA 35F0       =1  1396            ADDC    A,B             ;Incremented high-order product if carry.
03CC CF         =1  1397            XCH     A,TOS_H
03CD D0F0       =1  1398            POP     B
03CF A4         =1  1399            MUL     AB
03D0 2F         =1  1400            ADD     A,TOS_H
03D1 FF         =1  1401            MOV     TOS_H,A
03D2 72E7       =1  1402            ORL     C,ACC.7         ;Detect if most significant bit set.
03D4 E5F0       =1  1403            MOV     A,B
03D6 34FF       =1  1404            ADDC    A,#0FFH         ;Simulate "ORL  C,NZ" instruction.
03D8 B054       =1  1405            ANL     C,/HEXMOD       ;Overflow only relevent in decimal mode.
03DA 4004       =1  1406            JC      APN_ER          ;Error if bit 7 overflow occurred.
03DC D3         =1  1407            SETB    C               ;CHAR processed as legal character.
03DD 22         =1  1408            RET
                =1  1409    ;
03DE C3         =1  1410    APND_2: CLR     C
03DF 22         =1  1411            RET
                =1  1412    ;
                =1  1413    ;
03E0 120FBD     =1  1414    APN_ER: CALL    EXP_ER          ;Indicate illegal entry.
03E3 02         =1  1415            DB      2
                =1  1416    ;
                =1  1417    
                =1  1418    ;
03E4            =1  1419    OV_TST:
                =1  1420    ;       If OV is set and operation is BCD mode then call EXP_ER routine.
                =1  1421    ;
03E4 A2D2       =1  1422            MOV     C,OV
03E6 B054       =1  1423            ANL     C,/HEXMOD
03E8 4001       =1  1424            JC      EXP_OV
03EA 22         =1  1425            RET
                =1  1426    ;
03EB 120FBD     =1  1427    EXP_OV: CALL    EXP_ER
03EE 06         =1  1428            DB      6
                =1  1429    ;
                    1430    ;=======
                    1431    ;IADD:
LILBASIC        LilBasic (c)2002                                                                              PAGE 26

                    1432    ;       Pop VAR from AES (two bytes).
                    1433    ;       TOS <= TOS + VAR
                =1  1434    $INCLUDE(AES\IADD.ASM)
03EF            =1  1435    IADD:
                =1  1436    ;       Pop VAR from AES (two bytes).
                =1  1437    ;       TOS <= TOS + VAR
                =1  1438    ;
03EF 31C1       =1  1439            CALL    POP_TOS
03F1 1203F6     =1  1440            CALL    ADD_16
03F4 80EE       =1  1441            JMP     OV_TST
                =1  1442    
                =1  1443 +1 ADD_16: PAGE    #0H             ;ZERO PAGE for AES
03F6 75A000     =1  1444 +1         MOV     P2,#0H
03F9 E3         =1  1446            MOVX    A,@R1           ;Add low-order bytes.
03FA 2E         =1  1447            ADD     A,TOS_L
03FB F3         =1  1448            MOVX    @R1,A           ;Save sum.
03FC 09         =1  1449            INC     R1
03FD E3         =1  1450            MOVX    A,@R1           ;Add high-order bytes.
03FE 3F         =1  1451            ADDC    A,TOS_H
03FF F3         =1  1452            MOVX    @R1,A           ;Save sum.
0400 22         =1  1453            RET
                    1454    ;===============
                    1455    ;ISUB
                    1456    ;       Pop VAR from AES (two bytes).
                    1457    ;       TOS <= TOS - VAR
                =1  1458    $INCLUDE(AES\ISUB.ASM)
                =1  1459    ;ISUB
                =1  1460    ;       Pop VAR from AES (two bytes).
                =1  1461    ;       TOS <= TOS - VAR
                =1  1462    ;
                =1  1463    ;
                =1  1464 +1 ISUB:   PAGE    #0H             ;ZERO PAGE for AES
0401 75A000     =1  1465 +1         MOV     P2,#0H
0404 31C1       =1  1467            ACALL   POP_TOS
0406 C3         =1  1468            CLR     C               ;Set up for subtraction with borrow.
0407 E3         =1  1469            MOVX    A,@R1           ;Subtract low-order bytes.
0408 9E         =1  1470            SUBB    A,TOS_L
0409 F3         =1  1471            MOVX    @R1,A           ;Save difference.
040A 09         =1  1472            INC     R1              ;Bump pointers.
040B E3         =1  1473            MOVX    A,@R1           ;Subtract high-order bytes.
040C 9F         =1  1474            SUBB    A,TOS_H
040D F3         =1  1475            MOVX    @R1,A           ;Save difference.
040E 80D4       =1  1476            JMP     OV_TST
                =1  1477    ;
                    1478    ;=======
                    1479    ;IAND:
                    1480    ;       Pop VAR from AES (two bytes).
                    1481    ;       TOS <= TOS AND VAR
                =1  1482    $INCLUDE(AES\IAND.ASM)
0410            =1  1483    IAND:
                =1  1484    ;       Pop VAR from AES (two bytes).
                =1  1485    ;       TOS <= TOS AND VAR
                =1  1486    ;
                =1  1487 +1         PAGE    #0H             ;ZERO PAGE for AES
0410 75A000     =1  1488 +1         MOV     P2,#0H
0413 31C1       =1  1490            CALL    POP_TOS
0415 E3         =1  1491            MOVX    A,@R1           ;AND low-order bytes.
0416 5E         =1  1492            ANL     A,TOS_L
LILBASIC        LilBasic (c)2002                                                                              PAGE 27

0417 F3         =1  1493            MOVX    @R1,A           ;Save result.
0418 09         =1  1494            INC     R1
0419 E3         =1  1495            MOVX    A,@R1           ;AND high-order bytes.
041A 5F         =1  1496            ANL     A,TOS_H
041B F3         =1  1497            MOVX    @R1,A           ;Save result.
041C 22         =1  1498            RET
                =1  1499    ;
                    1500    ;=======
                    1501    ;IOR:
                    1502    ;       Pop VAR from AES (two bytes).
                    1503    ;       TOS <= TOS OR VAR
                =1  1504    $INCLUDE(AES\IOR.ASM)
041D            =1  1505    IOR:
                =1  1506    ;       Pop VAR from AES (two bytes).
                =1  1507    ;       TOS <= TOS OR VAR
                =1  1508    ;
                =1  1509 +1         PAGE    #0H             ;ZERO PAGE for AES
041D 75A000     =1  1510 +1         MOV     P2,#0H
0420 31C1       =1  1512            CALL    POP_TOS
0422 E3         =1  1513            MOVX    A,@R1           ;OR low-order bytes.
0423 4E         =1  1514            ORL     A,TOS_L
0424 F3         =1  1515            MOVX    @R1,A           ;Save result.
0425 09         =1  1516            INC     R1
0426 E3         =1  1517            MOVX    A,@R1           ;OR high-order bytes.
0427 4F         =1  1518            ORL     A,TOS_H
0428 F3         =1  1519            MOVX    @R1,A           ;Save result.
0429 22         =1  1520            RET
                =1  1521    ;
                    1522    ;=======
                    1523    ;IXOR:
                    1524    ;       Pop VAR from AES (two bytes).
                    1525    ;       TOS <= TOS XOR VAR
                =1  1526    $INCLUDE(AES\IXOR.ASM)
042A            =1  1527    IXOR:
                =1  1528    ;       Pop VAR from AES (two bytes).
                =1  1529    ;       TOS <= TOS XOR VAR
                =1  1530    ;
                =1  1531 +1         PAGE    #0H             ;ZERO PAGE for AES
042A 75A000     =1  1532 +1         MOV     P2,#0H
042D 31C1       =1  1534            CALL    POP_TOS
042F E3         =1  1535            MOVX    A,@R1           ;XOR low-order bytes.
0430 6E         =1  1536            XRL     A,TOS_L
0431 F3         =1  1537            MOVX    @R1,A           ;Save result.
0432 09         =1  1538            INC     R1
0433 E3         =1  1539            MOVX    A,@R1           ;XOR high-order bytes.
0434 6F         =1  1540            XRL     A,TOS_H
0435 F3         =1  1541            MOVX    @R1,A           ;Save result.
0436 22         =1  1542            RET
                =1  1543    ;
                    1544    ;===============
                    1545    ;ICPL:
                    1546    ;       TOS <= /TOS  (ones complement)
                    1547    ;IABS:
                    1548    ;       If in decimal mode and TOS < 0
                    1549    ;       then complement SGN_FLG and negate TOS.
                    1550    ;NEG_IF_NEG:
                    1551    ;       If SGN_FLG is set then negate TOS and complement SGN_FLG,
                    1552    ;       else return with TOS unchanged.
LILBASIC        LilBasic (c)2002                                                                              PAGE 28

                =1  1553    $INCLUDE(AES\NEG.ASM)
0437            =1  1554    IABS:
                =1  1555    ;       If in decimal mode and TOS < 0
                =1  1556    ;       then complement SGN_FLG and negate TOS.
                =1  1557    ;
                =1  1558 +1         PAGE    #0H             ;ZERO PAGE for AES
0437 75A000     =1  1559 +1         MOV     P2,#0H
043A A91D       =1  1561            MOV     R1,AESP
043C E3         =1  1562            MOVX    A,@R1
043D A2E7       =1  1563            MOV     C,ACC.7
043F B054       =1  1564            ANL     C,/HEXMOD
0441 4008       =1  1565            JC      NEG
0443 22         =1  1566            RET
                =1  1567    ;
                =1  1568    ;=======
                =1  1569    ;
0444            =1  1570    NEG_IF_NEG:
                =1  1571    ;       If SGN_FLG is set then negate TOS and complement SGN_FLG,
                =1  1572    ;       else return with TOS unchanged.
0444 205A04     =1  1573            JB      SGN_FLG,NEG
0447 22         =1  1574            RET
                =1  1575    ;
                =1  1576    
0448            =1  1577    ICPL:
                =1  1578    ;       TOS <= /TOS  (ones complement)
0448 D3         =1  1579            SETB    C
0449 8003       =1  1580            SJMP    NEG_0
                =1  1581    ;
                =1  1582    
044B            =1  1583    NEG:
                =1  1584    ;       TOS <= -TOS
                =1  1585    ;
044B C3         =1  1586            CLR     C
044C B25A       =1  1587            CPL     SGN_FLG
044E            =1  1588    NEG_0:
                =1  1589 +1         PAGE    #0H             ;ZERO PAGE for AES
044E 75A000     =1  1590 +1         MOV     P2,#0H
0451 A91D       =1  1592            MOV     R1,AESP         ;Compute variable address.
0453 19         =1  1593            DEC     R1              ;Index for low-order byte of VAR_1.
0454 E3         =1  1594            MOVX    A,@R1           ;Get low byte
0455 F5F0       =1  1595            MOV     B,A             ;Save in B
0457 E4         =1  1596            CLR     A               ;Subtract VAR_1 from 0000H.
0458 95F0       =1  1597            SUBB    A,B
045A F3         =1  1598            MOVX     @R1,A           ;Save difference.
045B 09         =1  1599            INC     R1              ;Bump pointer.
                =1  1600    
045C E3         =1  1601            MOVX    A,@R1           ;Get High byte
045D F5F0       =1  1602            MOV     B,A             ;Save in B
045F E4         =1  1603            CLR     A               ;Subtract VAR_1 from 0000H.
0460 95F0       =1  1604            SUBB    A,B
0462 F3         =1  1605            MOVX    @R1,A           ;Save difference.
0463 61E4       =1  1606            JMP     OV_TST
                =1  1607    ;
                    1608    ;===============
                    1609    ;IINC:
                    1610    ;       TOS <= TOS+1
                =1  1611    $INCLUDE(AES\IINC.ASM)
0465            =1  1612    IINC:
LILBASIC        LilBasic (c)2002                                                                              PAGE 29

                =1  1613    ;       TOS <= TOS+1
                =1  1614    ;
                =1  1615 +1         PAGE    #0H             ;ZERO PAGE for AES
0465 75A000     =1  1616 +1         MOV     P2,#0H
0468 A91D       =1  1618            MOV     R1,AESP         ;Compute variable address.
046A 19         =1  1619            DEC     R1              ;Index for low-order byte of VAR_1.
046B E3         =1  1620            MOVX    A,@R1           ;Get low byte
046C 04         =1  1621            INC     A               ;Add 1
046D F3         =1  1622            MOVX    @R1,A           ;Store
046E B40004     =1  1623            CJNE    A,#00,IINC_1    ;If not rollover FF -> 00 then Exit
0471 09         =1  1624            INC     R1              ;Bump pointer.
0472 E3         =1  1625            MOVX    A,@R1           ;Get high byte
0473 04         =1  1626            INC     A               ;Add 1
0474 F3         =1  1627            MOVX    @R1,A           ;Store
0475 22         =1  1628    IINC_1: RET
                =1  1629    ;
                    1630    ;=======
                    1631    ;IMUL:
                    1632    ;       Pop VAR from AES (two bytes).
                    1633    ;       TOS <= TOS * VAR
                =1  1634    $INCLUDE(AES\IMUL.ASM)
0476            =1  1635    MUL_16:
                =1  1636    ;       Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
                =1  1637    ;       on top of stack, and return with product on stack.
                =1  1638    ;       If product exceeds 16-bits, set OV flag.
                =1  1639    ;
                =1  1640    
0476 8F08       =1  1641            MOV     TMP0,TOS_H      ;Save first Part of equasion
0478 8E09       =1  1642            MOV     TMP1,TOS_L
047A 31C1       =1  1643            CALL    POP_TOS         ;Get other Part of equasion
                =1  1644    
                =1  1645                                    ;High-order byte of atleast one paramater must be 0.
047C E508       =1  1646            MOV     A,TMP0          ;Get High byte of first param
047E 6006       =1  1647            JZ      IMUL_SWAP       ;If 0 then reverse params before multipling
                =1  1648    
0480 EF         =1  1649            MOV     A,TOS_H         ;Get High byte of second param
0481 600D       =1  1650            JZ      IMUL_MUL        ;if 0 then pocede with multiply
                =1  1651                                    ;Error! Both values too large!
                =1  1652    
0483            =1  1653    IMUL_ERR:                       ;Jump to overflow erroe handeler
0483 02100E     =1  1654            JMP     OV_ER
                =1  1655    
0486            =1  1656    IMUL_SWAP:                      ;Swap paramaters so that TOS_H is ALLWAYS zero!
0486 E508       =1  1657            MOV     A,TMP0          ;Swap high bytes
0488 8F08       =1  1658            MOV     TMP0,TOS_H
048A FF         =1  1659            MOV     TOS_H,A
                =1  1660    
048B E509       =1  1661            MOV     A,TMP1          ;Swap low bytes
048D 8E09       =1  1662            MOV     TMP1,TOS_L
048F FE         =1  1663            MOV     TOS_L,A
                =1  1664    
0490            =1  1665    IMUL_MUL:                       ;16 bit multiply
                =1  1666    
0490 E509       =1  1667            MOV     A,TMP1
0492 8EF0       =1  1668            MOV     B,TOS_L
0494 A4         =1  1669            MUL     AB              ;multiply low order bytes
0495 85F00A     =1  1670            MOV     TMP2,B          ;Save High Byte
0498 F50B       =1  1671            MOV     TMP3,A          ;Save Low Byte
LILBASIC        LilBasic (c)2002                                                                              PAGE 30

                =1  1672    
049A EE         =1  1673            MOV     A,TOS_L
049B 8508F0     =1  1674            MOV     B,TMP0
049E A4         =1  1675            MUL     AB              ;Multiply high bytes.
                =1  1676    
049F 10D2E1     =1  1677            JBC    OV,IMUL_ERR      ;Overflow Error! Somthing in B!; answer will be 3 bytes wide
                                                                                !
                =1  1678    
04A2 C3         =1  1679            CLR     C               ;Clear carry flag
04A3 350A       =1  1680            ADDC    A,TMP2          ;Add high bytes
04A5 40DC       =1  1681            JC      IMUL_ERR        ;Error! answer is 3 bytes wide !
                =1  1682    
04A7 FF         =1  1683            MOV     TOS_H,A         ;Get High byte of answer
04A8 AE0B       =1  1684            MOV     TOS_L,TMP3      ;Get Low byte of answer
                =1  1685    
04AA 31DF       =1  1686            CAll    PUSH_TOS        ;Push answer into stack
                =1  1687    
                =1  1688    
                =1  1689    
04AC 22         =1  1690            RET
                =1  1691    ;
                =1  1692    ;=======
                =1  1693    ;
                =1  1694    ;
04AD            =1  1695    IMUL:
                =1  1696    ;       Pop VAR from AES (two bytes).
                =1  1697    ;       TOS <= TOS * VAR
                =1  1698    ;
04AD C25A       =1  1699            CLR     SGN_FLG         ;Initialize sign monitor flag.
04AF 9137       =1  1700            CALL    IABS            ;Take absolute value of TOS.
04B1 31C1       =1  1701            CALL    POP_TOS         ;Pop top entry.
04B3 9137       =1  1702            CALL    IABS            ;Take absolute value of NOS.
04B5 9176       =1  1703            CALL    MUL_16
04B7 71E4       =1  1704            CALL    OV_TST          ;Check if OV relevent.
04B9 9144       =1  1705            CALL    NEG_IF_NEG
04BB 22         =1  1706            RET
                =1  1707    ;
                    1708    ;===============
                    1709    ;IDIV:
                    1710    ;       Pop VAR from AES (two bytes).
                    1711    ;       TOS <= TOS / VAR
                    1712    ;       If divide-by-zero attempted report error.
                    1713    ;IMOD:
                    1714    ;       Pop VAR from AES (two bytes).
                    1715    ;       TOS <= TOS mod VAR        (remainder)
                    1716    ;       If divide-by-zero attempted report error.
                =1  1717    $INCLUDE(AES\IDIV.ASM)
                =1  1718    
04BC D25C       =1  1719    IMOD:   SETB    MOD_FLG         ;Indicate modulo entry point.
04BE 8002       =1  1720            SJMP    IDIV_0
                =1  1721    ;
                =1  1722    ;=======
                =1  1723    ;
                =1  1724    ;
04C0            =1  1725    IDIV:
                =1  1726    ;       Pop VAR from AES (two bytes).
                =1  1727    ;       TOS <= TOS / VAR
                =1  1728    ;       If divide-by-zero attempted report error.
LILBASIC        LilBasic (c)2002                                                                              PAGE 31

                =1  1729    ;
04C0 C25C       =1  1730            CLR     MOD_FLG         ;Indicate division entry point.
04C2 D25A       =1  1731    IDIV_0: SETB    SGN_FLG         ;Initialize sign monitor flag.
04C4 9137       =1  1732            CALL    IABS
04C6 914B       =1  1733            CALL    NEG
04C8 31C1       =1  1734            CALL    POP_TOS
04CA EE         =1  1735            mov     a,tos_l
04CB 4F         =1  1736            ORL     A,TOS_H
04CC 605C       =1  1737            JZ      DIV_NG
04CE A25A       =1  1738            MOV     C,SGN_FLG
04D0 B05C       =1  1739            ANL     C,/MOD_FLG      ;Clear SGN_FLG if MOD funtion being done.
04D2 925A       =1  1740            MOV     SGN_FLG,C
04D4 9137       =1  1741            CALL    IABS
04D6 F509       =1  1742            MOV     TMP1,A
04D8 19         =1  1743            DEC     R1
                =1  1744 +1         PAGE    #0H             ;ZERO PAGE for AES
04D9 75A000     =1  1745 +1         MOV     P2,#0H
04DC E3         =1  1747            MOVX     A,@R1
04DD F508       =1  1748            MOV     TMP0,A
04DF E4         =1  1749            CLR     A
04E0 F50B       =1  1750            MOV     TMP3,A
04E2 F50A       =1  1751            MOV     TMP2,A
04E4 7D11       =1  1752            MOV     LP_CNT,#17
04E6 C3         =1  1753            CLR     C
04E7 8017       =1  1754            SJMP    DIV_RP
                =1  1755    ;
04E9 E50A       =1  1756    DIV_LP: MOV     A,TMP2
04EB 33         =1  1757            RLC     A
04EC F50A       =1  1758            MOV     TMP2,A
04EE C50B       =1  1759            XCH     A,TMP3
04F0 33         =1  1760            RLC     A
04F1 C50B       =1  1761            XCH     A,TMP3
04F3 2E         =1  1762            ADD     A,TOS_L
04F4 F50C       =1  1763            MOV     TMP4,A
04F6 E50B       =1  1764            MOV     A,TMP3
04F8 3F         =1  1765            ADDC    A,TOS_H
04F9 5005       =1  1766            JNC     DIV_RP
04FB 850C0A     =1  1767            MOV     TMP2,TMP4
04FE F50B       =1  1768            MOV     TMP3,A
0500 E508       =1  1769    DIV_RP: MOV     A,TMP0
0502 33         =1  1770            RLC     A
0503 F508       =1  1771            MOV     TMP0,A
0505 E509       =1  1772            MOV     A,TMP1
0507 33         =1  1773            RLC     A
0508 F509       =1  1774            MOV     TMP1,A
050A DDDD       =1  1775            DJNZ    LP_CNT,DIV_LP
050C 205C0D     =1  1776            JB      MOD_FLG,DIV_1
050F F50D       =1  1777            MOV     TMP5,A                  ;SAVE A
0511 E508       =1  1778            MOV     A,TMP0                  ;Mov TMP0 X data
0513 F3         =1  1779            MOVX     @R1,A
0514 09         =1  1780            INC     R1
0515 E509       =1  1781            MOV     A,TMP1                  ;Mov TMP1 X data
0517 F3         =1  1782            MOVX     @R1,A
0518 E50D       =1  1783            MOV     A,TMP5                  ;Restore A
051A 800B       =1  1784            SJMP    DIV_2
                =1  1785    ;
051C F50D       =1  1786    DIV_1:  MOV     TMP5,A                  ;Save A
051E E50A       =1  1787            MOV     A,TMP2                  ;Store TMP2 in X data
LILBASIC        LilBasic (c)2002                                                                              PAGE 32

0520 F3         =1  1788            MOVX     @R1,A
0521 09         =1  1789            INC     R1
0522 E50B       =1  1790            MOV     A,TMP3
0524 F3         =1  1791            MOVX     @R1,A
0525 E50D       =1  1792            MOV     A,TMP5
0527 9144       =1  1793    DIV_2:  CALL    NEG_IF_NEG
0529 22         =1  1794            RET
                =1  1795    ;
052A 61EB       =1  1796    DIV_NG: AJMP    EXP_OV          ;Report expression overflow.
                =1  1797    ;
                    1798    ;===============
                    1799    ;RND:
                    1800    ;       TOS <= rnd(TOS)
                    1801    ;       Generate a new 16-bit random number from 1 to TOS,
                    1802    ;       and push onto the AES.
                =1  1803    $INCLUDE(AES\RND.ASM)
052C            =1  1804    RND:
                =1  1805    ;       Generate a new 16-bit random number from RND_KEY,
                =1  1806    ;       and push onto the AES.
052C AE10       =1  1807            MOV     TOS_L,SEED_L            ;Get seed
052E AF11       =1  1808            MOV     TOS_H,SEED_H
0530 31DF       =1  1809            CALL    PUSH_TOS
                =1  1810    
0532 7E55       =1  1811            MOV     TOS_L,#LOW(25173)       ;Multiply by 25173
0534 7F62       =1  1812            MOV     TOS_H,#HIGH(25173)
0536 9176       =1  1813            CALL    MUL_16
                =1  1814    
0538 7E19       =1  1815            MOV     TOS_L,#LOW(13849)       ;Add 13894
053A 7F36       =1  1816            MOV     TOS_H,#HIGH(13849)
053C A91D       =1  1817            MOV     R1,AESP
053E 19         =1  1818            DEC     R1
053F 71F6       =1  1819            CALL    ADD_16
                =1  1820    
0541 31C1       =1  1821            CALL    POP_TOS
                =1  1822    ;
                =1  1823    ;???
                =1  1824    ; The code from here to label no_problem to cure a extraneous overflow if seed=8000h.
                =1  1825    ;???
                =1  1826    ;
0543 BE0007     =1  1827            cjne    tos_l,#0,no_problem
0546 BF8004     =1  1828            cjne    tos_h,#80h,no_problem
0549            =1  1829    big_problem:                               ; tos=8000h will generate an overflow
0549 7E2A       =1  1830            mov     tos_l,#low(12586)          ; when control gets to iabs.
054B 7F31       =1  1831            mov     tos_h,#high(12586)         ; Load the precalculated seed.
054D            =1  1832    no_problem:
054D 8E10       =1  1833            MOV     SEED_L,TOS_L
054F 8F11       =1  1834            MOV     SEED_H,TOS_H
0551 31DF       =1  1835            CALL    PUSH_TOS
0553 22         =1  1836            RET
                =1  1837    ;
                    1838    ;===============
                    1839    ;CMPR:
                    1840    ;       When CMPR is called, AES contains:
                    1841    ;       (TOS:)  VAR_2 (two bytes),
                    1842    ;               C_CODE (one byte),
                    1843    ;               VAR_1 (two bytes).
                    1844    ;       Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
                    1845    ;           If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
LILBASIC        LilBasic (c)2002                                                                              PAGE 33

                    1846    ;           If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
                    1847    ;           If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
                    1848    ;           If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
                    1849    ;           If C_CODE=001 then test whether (VAR_1) >  (VAR_2);           If C_CODE=011 then
                                                                                test whether (VAR_1) >= (VAR_2)
                    1850    ;       If true then return 0001H on AES;
                    1851    ;       otherwise return 0000H.
                =1  1852    $INCLUDE(AES\CMPR.ASM)
0554            =1  1853    CMPR:
                =1  1854    ;       When CMPR is called, AES contains:
                =1  1855    ;       (TOS:)  VAR_2 (two bytes),
                =1  1856    ;               C_CODE (one byte),
                =1  1857    ;               VAR_1 (two bytes).
                =1  1858    ;       Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
                =1  1859    ;           If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
                =1  1860    ;           If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
                =1  1861    ;           If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
                =1  1862    ;           If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
                =1  1863    ;           If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
                =1  1864    ;           If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
                =1  1865    ;       If true then return 0001H on AES;
                =1  1866    ;       otherwise return 0000H.
                =1  1867    ;
0554 31C1       =1  1868            CALL    POP_TOS
0556 31D6       =1  1869            CALL    POP_ACC
                =1  1870 +1         PAGE    #0H             ;ZERO PAGE for AES
0558 75A000     =1  1871 +1         MOV     P2,#0H
055B F5F0       =1  1873            MOV     B,A
055D A91D       =1  1874            MOV     R1,AESP
055F 19         =1  1875            DEC     R1
0560 C3         =1  1876            CLR     C               ;...in preparation for string subtract.
0561 E3         =1  1877            MOVX     A,@R1           ;Compare low-order parameter bytes.
0562 9E         =1  1878            SUBB    A,TOS_L
0563 09         =1  1879            INC     R1              ;Bump pointer.
                =1  1880    
0564 F50D       =1  1881            MOV     TMP5,A          ;Save difference and exchange A with @R1
0566 E3         =1  1882            MOVX    A,@R1
0567 C50D       =1  1883            XCH     A,TMP5
0569 F3         =1  1884            MOVX    @R1,A
056A C50D       =1  1885            XCH     A,TMP5
                =1  1886    
056C 205406     =1  1887            JB      HEXMOD,CMPR_4
056F 6480       =1  1888            XRL     A,#80H          ;Offset variable by 80H for unsigned compare.
0571 CF         =1  1889            XCH     A,TOS_H
0572 6480       =1  1890            XRL     A,#80H
0574 CF         =1  1891            XCH     A,TOS_H
0575 9F         =1  1892    CMPR_4: SUBB    A,TOS_H
                =1  1893    
                =1  1894    
0576 450D       =1  1895            ORL     A,TMP5           ;Add any non-zero high-order bits to acc.
0578 7004       =1  1896            JNZ     CMPR_1          ;Jump ahead VAR_1 <> VAR_2.
                =1  1897    ;
                =1  1898    ;       VAR_1 = VAR_2:
                =1  1899    ;
057A A2F1       =1  1900            MOV     C,B.1           ;Load VAR_1 = VAR_2 test flag.
057C 8008       =1  1901            SJMP    PUSH_C
                =1  1902    ;
057E 4004       =1  1903    CMPR_1: JC      CMPR_2          ;Jump ahead if VAR_1 < VAR_2.
LILBASIC        LilBasic (c)2002                                                                              PAGE 34

                =1  1904    ;
                =1  1905    ;       VAR_1 > VAR_2:
                =1  1906    ;
0580 A2F0       =1  1907            MOV     C,B.0           ;Load VAR_1 > VAR_2 test flag.
0582 8002       =1  1908            SJMP    PUSH_C
                =1  1909    ;
                =1  1910    ;       VAR_1 < VAR_2:
                =1  1911    ;
0584 A2F2       =1  1912    CMPR_2: MOV     C,B.2           ;Load VAR_1 < VAR_2 test flag.
0586 E4         =1  1913    PUSH_C: CLR     A
                =1  1914 +1         PAGE    #0H             ;ZERO PAGE for AES
0587 75A000     =1  1915 +1         MOV     P2,#0H
058A F3         =1  1917            MOVX     @R1,A
058B 33         =1  1918            RLC     A
058C 19         =1  1919            DEC     R1
058D F3         =1  1920            MOVX    @R1,A
058E 22         =1  1921            RET
                =1  1922    ;
                    1923    ;===============
                    1924    
                    1925    
                    1926    ;       BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
                    1927    ;       ===== ====== ======= ==== ======= ==========
                    1928    ;
                    1929    ;       The general methodology of the various parsing routines is as follows:
                    1930    ;       The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
                    1931    ;       source character or string to be parsed
                    1932    ;       by routines TST, TSTV, TSTN, TSTL, and TSTS.
                    1933    ;       GET_C reads the indicated character from the appropriate
                    1934    ;       program buffer space into acc. and returns.
                    1935    ;       READ_CHAR reads the character into CHAR as well as acc. and
                    1936    ;       increments the 16-bit pointer.
                    1937    ;       When done, each routine calls D_BLANK to remove any trailing spaces,
                    1938    ;       and leaves READ_CHAR ready to fetch the next non-blank character.
                    1939    ;
                    1940    ;=======
                    1941    ;REWIND
                    1942    ;       Reset Cursor to start of current program buffer space.
                =1  1943    $INCLUDE(AES\REWIND.ASM)
                =1  1944    ;REWIND
                =1  1945    ;       Reset Cursor to start of current program buffer space.
                =1  1946    ;
058F C259       =1  1947    REWIND: CLR     CHAR_FLG
0591 205105     =1  1948            JB      AUTO,REWROM             ;If auto executing from ROM, jump to REWROM
0594 7A20       =1  1949            MOV     PNTR_H,#HIGH(EXTRAM)
0596 7800       =1  1950            MOV     PNTR_L,#LOW(EXTRAM)
0598 22         =1  1951            RET
                =1  1952    ;
0599 205205     =1  1953    REWROM: JB      XAUTO,RWXROM            ;If Auto executig form Shared eXternal memory jump t
                                                                               o RWXROM
059C 7A20       =1  1954            MOV     PNTR_H,#HIGH(DEMOPROG)
059E 78F6       =1  1955            MOV     PNTR_L,#LOW(DEMOPROG)
05A0 22         =1  1956            RET
                =1  1957    ;
05A1 908002     =1  1958    RWXROM: MOV     DPTR,#XRAM      ;Set pointer to start of Xmem
05A4            =1  1959    REWIND_FIND_FILE:
05A4 E0         =1  1960            MOVX    A,@DPTR                 ;Search through mem till first 00H is found
05A5 A3         =1  1961            INC     DPTR
LILBASIC        LilBasic (c)2002                                                                              PAGE 35

05A6 70FC       =1  1962            JNZ     REWIND_FIND_FILE
05A8 AA83       =1  1963            MOV     PNTR_H,DPH              ;Return with pointer to first program in Xmem
05AA A882       =1  1964            MOV     PNTR_L,DPL
                =1  1965    
05AC 22         =1  1966            RET                             ;
                =1  1967    ;
                    1968    ;=======
                    1969    ;SAVE_PNTR:
                    1970    ;       Save PNTR variables in cursor.
                =1  1971    $INCLUDE(AES\SAVPNTR.ASM)
05AD            =1  1972    SAVE_PNTR:
                =1  1973    ;       Save PNTR variables in cursor.
                =1  1974    ;
05AD 8815       =1  1975            MOV     CURS_L,PNTR_L
05AF 8A16       =1  1976            MOV     CURS_H,PNTR_H
05B1 8C17       =1  1977            MOV     C_SAVE,CHAR
05B3 22         =1  1978            RET
                =1  1979    ;
                    1980    ;=======
                    1981    ;LOAD_PNTR:
                    1982    ;       Reload pointer with value saved earlier by SAVE_PNTR.
                =1  1983    $INCLUDE(AES\LOADPNTR.ASM)
05B4            =1  1984    LOAD_PNTR:
                =1  1985    ;       Reload pointer with value saved earlier by SAVE_PNTR.
                =1  1986    ;
05B4 AA16       =1  1987            MOV     PNTR_H,CURS_H
05B6 A815       =1  1988            MOV     PNTR_L,CURS_L
05B8 AC17       =1  1989            MOV     CHAR,C_SAVE
05BA 22         =1  1990            RET
                =1  1991    ;
                    1992    ;=======
                    1993    ;GET_C:
                    1994    ;       Read character from logical buffer space into A and return.
                    1995    ;GET_BUF:
                    1996    ;       Read character from active program buffer space into A and return.
                    1997    ;REREAD:
                    1998    ;       Re-Read charcter into Acc from CHAR
                    1999    ;
                    2000    ;READ_CHAR:
                    2001    ;       READ_CHAR first tests the state of CHAR_FLG.
                    2002    ;       If it is still cleared, the character most recently read from the line
                    2003    ;       buffer or program buffer has been processed, so read the next
                    2004    ;       character, bump the buffer pointer, and return with the character
                    2005    ;       in both Acc. and CHAR and the CHAR_FLG cleared.
                    2006    ;       If CHAR_FLG has been set by the parsing routines,
                    2007    ;       then CHAR still holds a previously read character which has
                    2008    ;       not yet been processed.  Read this character into Acc. and return
                    2009    ;       with CHAR_FLG again cleared.
                =1  2010    $INCLUDE(AES\READCHAR.ASM)
05BB            =1  2011    GET_C:
                =1  2012    ;       Read character from logical buffer space into A and return.
                =1  2013    ;
05BB 205305     =1  2014            JB      RUNMOD,GET_BUF   ; If program running,  Get char from Program (Get_Buff)
                =1  2015 +1         PAGE    #0H              ;Set page to 0 For AES
05BE 75A000     =1  2016 +1         MOV     P2,#0H
05C1 E2         =1  2018            MOVX    A,@PNTR_L        ;Read char from AES stack. Note: this read is in reverse di
                                                                               rection from POP ACC
05C2 22         =1  2019            RET
LILBASIC        LilBasic (c)2002                                                                              PAGE 36

                =1  2020    ;
05C3            =1  2021    GET_BUF:
                =1  2022    ;       Read character from active program buffer space into A and return.
05C3 20520E     =1  2023            JB      XAUTO,GETROM             ;Choose to read char from ROM/RAM space
                =1  2024    
05C6 C082       =1  2025            PUSH    DPL                     ;Save Data Pointer
05C8 C083       =1  2026            PUSH    DPH
05CA 8A83       =1  2027            MOV     DPH,PNTR_H              ;Select Address
05CC 8882       =1  2028            MOV     DPL,PNTR_L
05CE E0         =1  2029            MOVX    A,@DPTR                 ;Read from external address space.
05CF D083       =1  2030            POP     DPH                     ;Restore Data pointer
05D1 D082       =1  2031            POP     DPL
05D3 22         =1  2032            RET
                =1  2033    ;
05D4 E8         =1  2034    GETROM: MOV     A,PNTR_L
05D5 C582       =1  2035            XCH     A,DPL
05D7 CA         =1  2036            XCH     A,PNTR_H
05D8 C583       =1  2037            XCH     A,DPH
05DA F8         =1  2038            MOV     PNTR_L,A
05DB E4         =1  2039            CLR     A
05DC 93         =1  2040            MOVC    A,@A+DPTR
05DD C8         =1  2041            XCH     A,PNTR_L                ;Save char. and load old DPH.
05DE C583       =1  2042            XCH     A,DPH
05E0 CA         =1  2043            XCH     A,PNTR_H
05E1 C582       =1  2044            XCH     A,DPL
05E3 C8         =1  2045            XCH     A,PNTR_L                ;Store DPL and reload byte read.
05E4 22         =1  2046            RET
                =1  2047    ;
                =1  2048    ;=======
                =1  2049    ;
05E5            =1  2050    READ_CHAR:
                =1  2051    ;       READ_CHAR first tests the state of CHAR_FLG.
                =1  2052    ;       If it is still cleared, the character most recently read from the line
                =1  2053    ;       buffer or program buffer has been processed, so read the next
                =1  2054    ;       character, bump the buffer pointer, and return with the character
                =1  2055    ;       in both Acc. and CHAR and the CHAR_FLG cleared.
                =1  2056    ;       If CHAR_FLG has been set by the parsing routines,
                =1  2057    ;       then CHAR still holds a previously read character which has
                =1  2058    ;       not yet been processed.  Read this character into Acc. and return
                =1  2059    ;       with CHAR_FLG again cleared.
                =1  2060    ;
05E5 105909     =1  2061            JBC     CHAR_FLG,REREAD         ;If CHAR_FLG cleared, reread char and exit!
05E8 B1BB       =1  2062            CALL    GET_C                   ;Get Char
05EA FC         =1  2063            MOV     CHAR,A
05EB 08         =1  2064            INC     PNTR_L
05EC B80001     =1  2065            CJNE    PNTR_L,#00,RDCHDN
05EF 0A         =1  2066            INC     PNTR_H
05F0 22         =1  2067    RDCHDN: RET
                =1  2068    ;
05F1 EC         =1  2069    REREAD: MOV     A,CHAR
05F2 22         =1  2070            RET
                =1  2071    ;
                    2072    ;=======
                    2073    ;PUT_BUF:
                    2074    ;       Put the contents of the acc. into program buffer space
                    2075    ;       currently active at the address held in <DEST_H><DEST_L>.
                    2076    ;WRITE_CHAR:
                    2077    ;       Converse of READ_CHAR.
LILBASIC        LilBasic (c)2002                                                                              PAGE 37

                    2078    ;       Write contents of acc. into appropriate memory space (@DEST),
                    2079    ;       increment DEST, and return.
                =1  2080    $INCLUDE(AES\WRITECHR.ASM)
05F3            =1  2081    PUT_BUF:
                =1  2082    ;       Put the contents of the acc. into program buffer space
                =1  2083    ;       currently active at the address held in <DEST_H><DEST_L>.
                =1  2084    ;
05F3 20510E     =1  2085            JB      AUTO,PUTROM           ;If Auto Run, read from ROM
                =1  2086    
05F6 C083       =1  2087            PUSH    DPH
05F8 C082       =1  2088            PUSH    DPL
05FA 8B83       =1  2089            MOV     DPH,DEST_H
05FC 8982       =1  2090            MOV     DPL,DEST_L
05FE F0         =1  2091            MOVX    @DPTR,A
05FF D082       =1  2092            POP     DPL
0601 D083       =1  2093            POP     DPH
                =1  2094    
0603 22         =1  2095            RET
                =1  2096    ;
0604 020FBD     =1  2097    PUTROM: JMP     EXP_ER
                =1  2098    ;
                =1  2099    ;=======
                =1  2100    ;
0607            =1  2101    WRITE_CHAR:
                =1  2102    ;       Converse of READ_CHAR.
                =1  2103    ;       Write contents of acc. into appropriate memory space (@DEST),
                =1  2104    ;       increment DEST, and return.
                =1  2105    ;
0607 B1F3       =1  2106            CALL    PUT_BUF
0609 09         =1  2107            INC     DEST_L
060A B90001     =1  2108            CJNE    DEST_L,#00H,WRCH_1
060D 0B         =1  2109            INC     DEST_H
060E 22         =1  2110    WRCH_1: RET
                =1  2111    ;
                    2112    ;=======
                    2113    ;D_BLNK:
                    2114    ;       Remove leading blanks from BASIC source line, update cursor,
                    2115    ;       load first non-blank character into CHAR,
                    2116    ;       and leave pointer loaded with its address.
                    2117    ;       (This routine is jumped to by parsing routines when successful,
                    2118    ;       so set C before returning to original routines.)
                =1  2119    $INCLUDE(AES\D_BLNK.ASM)
060F            =1  2120    D_BLNK:
                =1  2121    ;       Remove leading blanks from BASIC source line, update cursor,
                =1  2122    ;       load first non-blank character into CHAR,
                =1  2123    ;       and leave pointer loaded with its address.
                =1  2124    ;       (This routine is jumped to by parsing routines when successful,
                =1  2125    ;       so set C before returning to original routines.)
                =1  2126    ;
060F B1E5       =1  2127            CALL    READ_CHAR
0611 6420       =1  2128            XRL     A,#' '          ;Verify that it is non-blank.
0613 60FA       =1  2129            JZ      D_BLNK          ;Loop until non-blank leading character.
0615 D259       =1  2130            SETB    CHAR_FLG
0617 D3         =1  2131            SETB    C
0618 22         =1  2132            RET                     ;Return to scanning code.
                =1  2133    ;
                    2134    ;=======
                    2135    ;SKPLIN
LILBASIC        LilBasic (c)2002                                                                              PAGE 38

                    2136    ;       Skip Cursor over entire BASIC source line, leaving
                    2137    ;       cursor pointing to character after terminating <CR>.
                    2138    ;SKPTXT
                    2139    ;       Skip remainder of line in progress, assuming line number
                    2140    ;       has already been passed over.
                    2141    ;       (Note that either byte of binary line number could be
                    2142    ;       mis-interpreted as a CR.)
                =1  2143    $INCLUDE(AES\SKPLIN.ASM)
                =1  2144    ;
                =1  2145    ;SKPLIN
                =1  2146    ;       Skip Cursor over entire BASIC source line, leaving
                =1  2147    ;       cursor pointing to character after terminating <CR>.
                =1  2148    ;SKPTXT
                =1  2149    ;       Skip remainder of line in progress, assuming line number
                =1  2150    ;       has already been passed over.
                =1  2151    ;       (Note that either byte of binary line number could be
                =1  2152    ;       mis-interpreted as a CR.)
                =1  2153    ;
                =1  2154    ;
0619 B1E5       =1  2155    SKPLIN: CALL    READ_CHAR
061B B1E5       =1  2156            CALL    READ_CHAR
061D B1E5       =1  2157    SKPTXT: CALL    READ_CHAR
061F B40DFB     =1  2158            CJNE    A,#CR,SKPTXT    ;Verify that it is non-<CR>.
0622 22         =1  2159            RET                     ;Return to scanning code.
                =1  2160    ;
                    2161    ;===================================================================================
                    2162    ;       Token recognition and processing routines.
                    2163    ;===================================================================================
                    2164    ;TST:
                    2165    ;       If "TEMPLATE" matches the BASIC character string read by
                    2166    ;       READ_CHAR then move pointer over string and any trailing blanks
                    2167    ;       and continue with the following IL instruction.
                    2168    ;       Otherwise leave pointer unchanged and branch to IL instruction at LBL.
                =1  2169    $INCLUDE(AES\TST.ASM)
0623            =1  2170    TST:
                =1  2171    ;       If "TEMPLATE" matches the BASIC character string read by
                =1  2172    ;       READ_CHAR then move pointer over string and any trailing blanks
                =1  2173    ;       and continue with the following IL instruction.
                =1  2174    ;       Otherwise leave pointer unchanged and branch to IL instruction at LBL.
                =1  2175    ;
0623 D083       =1  2176            POP     DPH             ;Get in-line parameter base address from stack.
0625 D082       =1  2177            POP     DPL
0627 B1E5       =1  2178            CALL    READ_CHAR       ;Get Next Char to be parsed
                =1  2179    
0629 EC         =1  2180            MOV     A,CHAR
062A 310C       =1  2181            CALL    UPPER           ;Convert to uppercase
062C FC         =1  2182            MOV     CHAR,A
                =1  2183    
062D B1AD       =1  2184            CALL    SAVE_PNTR
062F E4         =1  2185    TST_1:  CLR     A
0630 93         =1  2186            MOVC    A,@A+DPTR       ;Read next character from template string.
0631 A2E7       =1  2187            MOV     C,ACC.7         ;Save terminator bit.
0633 547F       =1  2188            ANL     A,#7FH          ;Mask off terminator.
0635 6C         =1  2189            XRL     A,CHAR          ;Compare with template.
0636 700F       =1  2190            JNZ     T_BAD           ;Abort if first characters miscompare.
0638 A3         =1  2191            INC     DPTR            ;Pass over template character just checked.
0639 4008       =1  2192            JC      T_GOOD          ;Done if template character bit 7 set.
063B B1E5       =1  2193            CALL    READ_CHAR       ;Fetch next character for test.
LILBASIC        LilBasic (c)2002                                                                              PAGE 39

                =1  2194    
063D EC         =1  2195            MOV     A,CHAR
063E 310C       =1  2196            CALL    UPPER           ;Convert to uppercase
0640 FC         =1  2197            MOV     CHAR,A
                =1  2198    
0641 80EC       =1  2199            SJMP    TST_1           ;Continue
                =1  2200    ;        CJNE    CHAR,#'.',TST_1 ;Done if input string abbreviated at this point
                =1  2201    ;TST_2:  CLR     A               ;Fetch template characters until end of string
                =1  2202    ;        MOVC    A,@A+DPTR
                =1  2203    ;        INC     DPTR
                =1  2204    ;        JNB     ACC.7,TST_2     ;Loop until last character detected.
0643 D10F       =1  2205    T_GOOD: CALL    D_BLNK
0645 E4         =1  2206            CLR     A
0646 73         =1  2207            JMP     @A+DPTR         ;Return to next IL instruction
                =1  2208    ;
                =1  2209    ;       Strings do not match.  Leave cursor at start of string.
                =1  2210    ;
0647 E4         =1  2211    T_BAD:  CLR     A
0648 93         =1  2212            MOVC    A,@A+DPTR       ;Search for final template character.
0649 A3         =1  2213            INC     DPTR
064A 30E7FA     =1  2214            JNB     ACC.7,T_BAD     ;Loop until terminator found.
064D B1B4       =1  2215            CALL    LOAD_PNTR
064F D259       =1  2216            SETB    CHAR_FLG
0651 C3         =1  2217            CLR     C               ;Mark string not found.
0652 E4         =1  2218            CLR     A
0653 73         =1  2219            JMP     @A+DPTR         ;Return to mismatch branch instruction.
                =1  2220    ;
                    2221    ;=====
                    2222    ;TSTV   (LBL)
                    2223    ;
                    2224    ;       Test if first non-blank string is a legal variable symbol.
                    2225    ;       If so, move cursor over string and any trailing blanks,
                    2226    ;       compute variable index value,
                    2227    ;       push onto arithmetic expression stack,
                    2228    ;       and continue with following IL instruction.
                    2229    ;       Otherwise branch to IL instruction at LBL with cursor unaffected.
                    2230    ;       Contains PASVAL subrutines.
                =1  2231    $INCLUDE(AES\TSTV.ASM)
                =1  2232    ;TSTV   (LBL)
                =1  2233    ;
                =1  2234    ;
0654            =1  2235    TSTV:
                =1  2236    ;       Test if first non-blank string is a legal variable symbol.
                =1  2237    ;       If so, move cursor over string and any trailing blanks,
                =1  2238    ;       compute variable index value,
                =1  2239    ;       push onto arithmetic expression stack,
                =1  2240    ;       and continue with following IL instruction.
                =1  2241    ;       Otherwise branch to IL instruction at LBL with cursor unaffected.
                =1  2242    ;
0654 B1E5       =1  2243            CALL    READ_CHAR       ;Get next parsed char
0656 310C       =1  2244            CALL    UPPER           ;Convert to upper case
0658 24BF       =1  2245            ADD     A,#-'A'         ;Subtract offset for base variable.
065A FE         =1  2246            MOV     TOS_L,A         ;Save index in case needed later.
065B 24E6       =1  2247            ADD     A,#-26
065D 5004       =1  2248            JNC     ALPHAB          ;First character is alphabetic if C=0.
065F D259       =1  2249            SETB    CHAR_FLG
0661 C3         =1  2250            CLR     C
0662 22         =1  2251            RET
LILBASIC        LilBasic (c)2002                                                                              PAGE 40

                =1  2252    ;
0663 B1AD       =1  2253    ALPHAB: CALL    SAVE_PNTR       ;In case variable name not found.
0665 B1E5       =1  2254            CALL    READ_CHAR       ;Verify that next character is not alphabetic.
0667 310C       =1  2255            CALL    UPPER
0669 24BF       =1  2256            ADD     A,#-'A'         ;Alphabetic characters now <= 25.
066B 24E6       =1  2257            ADD     A,#-26          ;Non-alphabetics cause overflow.
066D 5003       =1  2258            JNC     NOTVAR          ;Alphabetic character means illegal var. name.
066F 0207AC     =1  2259            JMP    TSTV_1          ;Jump to exit routine
                =1  2260    
                =1  2261    ;=====
0672 B1B4       =1  2262    NOTVAR: CALL    LOAD_PNTR       ;IF not an Inerger Varable.
0674 D259       =1  2263            SETB    CHAR_FLG
                =1  2264                                    ;Check to see if it is a reserved Variable name
                =2  2265    $INCLUDE(AES\PASVAL\PORT.ASM)
0676            =2  2266    PORT1:
0676 D123       =2  2267            call tst                ; Test it 'PORT1' token
0678 504F5254   =2  2268            db      'PORT',('1' OR 80H )
067C B1         
067D 500B       =2  2269            JNC     PORT1_END
                =2  2270 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
067F 5110       =2  2271 +1         CALL    LIT
0681 01         =2  2272 +1         DB      01H
                =2  2274 +1         LIT_    90H             ;Push low byte of ADDR onto Stack
0682 5110       =2  2275 +1         CALL    LIT
0684 90         =2  2276 +1         DB      90H
                =2  2278 +1         LIT_    00H             ;Push high byte of ADDR onto Stack
0685 5110       =2  2279 +1         CALL    LIT
0687 00         =2  2280 +1         DB      00H
0688 8085       =2  2282            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2283                                    ;and continue
068A            =2  2284    PORT1_END:
                =2  2285    $INCLUDE(AES\PASVAL\ERROR.ASM)
                =2  2286    
068A            =2  2287    TST_ERROR:
068A D123       =2  2288            call tst                ; Test it 'ERROR' token
068C 4552524F   =2  2289            db      'ERRO',('R' OR 80H )
0690 D2         
0691 500B       =2  2290            JNC     TST_ERROR_END
                =2  2291 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0693 5110       =2  2292 +1         CALL    LIT
0695 01         =2  2293 +1         DB      01H
                =2  2295 +1         LIT_    LOW(ERROR)      ;Push low byte of ADDR onto Stack
0696 5110       =2  2296 +1         CALL    LIT
0698 1A         =2  2297 +1         DB      LOW(ERROR)
                =2  2299 +1         LIT_    HIGH(ERROR)     ;Push high byte of ADDR onto Stack
0699 5110       =2  2300 +1         CALL    LIT
069B 00         =2  2301 +1         DB      HIGH(ERROR)
069C C10F       =2  2303            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2304                                    ;and continue
069E            =2  2305    TST_ERROR_END:
                =2  2306    $INCLUDE(AES\PASVAL\TIMER.ASM)
                =2  2307    
069E            =2  2308    TST_TIMER:
069E D123       =2  2309            call tst                ; Test it 'TIMER' token
06A0 54494D45   =2  2310            db      'TIME',('R' OR 80H )
06A4 D2         
06A5 500B       =2  2311            JNC     TST_TIMER_END
                =2  2312 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
LILBASIC        LilBasic (c)2002                                                                              PAGE 41

06A7 5110       =2  2313 +1         CALL    LIT
06A9 01         =2  2314 +1         DB      01H
                =2  2316 +1         LIT_    LOW(TIMER1)     ;Push low byte of ADDR onto Stack
06AA 5110       =2  2317 +1         CALL    LIT
06AC 1F         =2  2318 +1         DB      LOW(TIMER1)
                =2  2320 +1         LIT_    HIGH(TIMER1)    ;Push high byte of ADDR onto Stack
06AD 5110       =2  2321 +1         CALL    LIT
06AF 00         =2  2322 +1         DB      HIGH(TIMER1)
06B0 C10F       =2  2324            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2325                                    ;and continue
06B2            =2  2326    TST_TIMER_END:
                =2  2327    $INCLUDE(AES\PASVAL\FREQ.ASM)
                =2  2328    
06B2            =2  2329    TST_FREQ:
06B2 D123       =2  2330            call tst                ; Test it 'FREQ' token
06B4 465245D1   =2  2331            db      'FRE',('Q' OR 80H )
06B8 500B       =2  2332            JNC     TST_FREQ_END
                =2  2333 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06BA 5110       =2  2334 +1         CALL    LIT
06BC 01         =2  2335 +1         DB      01H
                =2  2337 +1         LIT_    LOW(TH0)        ;Push low byte of ADDR onto Stack
06BD 5110       =2  2338 +1         CALL    LIT
06BF 8C         =2  2339 +1         DB      LOW(TH0)
                =2  2341 +1         LIT_    HIGH(TH0)       ;Push high byte of ADDR onto Stack
06C0 5110       =2  2342 +1         CALL    LIT
06C2 00         =2  2343 +1         DB      HIGH(TH0)
06C3 C10F       =2  2345            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2346                                    ;and continue
06C5            =2  2347    TST_FREQ_END:
                =2  2348    $INCLUDE(AES\PASVAL\MASK.ASM)
                =2  2349    
06C5            =2  2350    TST_MASK:
06C5 D123       =2  2351            call tst                ; Test it 'MASK' token
06C7 4D4153CB   =2  2352            db      'MAS',('K' OR 80H )
06CB 500B       =2  2353            JNC     TST_MASK_END
                =2  2354 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06CD 5110       =2  2355 +1         CALL    LIT
06CF 01         =2  2356 +1         DB      01H
                =2  2358 +1         LIT_    LOW(PRT_MSK)    ;Push low byte of ADDR onto Stack
06D0 5110       =2  2359 +1         CALL    LIT
06D2 28         =2  2360 +1         DB      LOW(PRT_MSK)
                =2  2362 +1         LIT_    HIGH(PRT_MSK)   ;Push high byte of ADDR onto Stack
06D3 5110       =2  2363 +1         CALL    LIT
06D5 00         =2  2364 +1         DB      HIGH(PRT_MSK)
06D6 C10F       =2  2366            JMP     D_BLNK          ;Remove leading blanks from source line.
06D8            =2  2367    TST_MASK_END:
                =2  2368    $INCLUDE(AES\PASVAL\PWM.ASM)
                =2  2369    
06D8            =2  2370    TST_PWM0:                       ; Test it 'PWM0' token
06D8 D123       =2  2371            call tst
06DA 50574DB0   =2  2372            db      'PWM',('0' OR 80H )
06DE 500B       =2  2373            JNC     TST_PWM1
                =2  2374 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06E0 5110       =2  2375 +1         CALL    LIT
06E2 01         =2  2376 +1         DB      01H
                =2  2378 +1         LIT_    LOW(PWM0)    ;Push low byte of ADDR onto Stack
06E3 5110       =2  2379 +1         CALL    LIT
06E5 20         =2  2380 +1         DB      LOW(PWM0)
LILBASIC        LilBasic (c)2002                                                                              PAGE 42

                =2  2382 +1         LIT_    HIGH(PWM0)   ;Push high byte of ADDR onto Stack
06E6 5110       =2  2383 +1         CALL    LIT
06E8 00         =2  2384 +1         DB      HIGH(PWM0)
06E9 C10F       =2  2386            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2387    
06EB            =2  2388    TST_PWM1:                       ; Test it 'PWM0' token
06EB D123       =2  2389            call tst
06ED 50574DB1   =2  2390            db      'PWM',('1' OR 80H )
06F1 500B       =2  2391            JNC     TST_PWM2
                =2  2392 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06F3 5110       =2  2393 +1         CALL    LIT
06F5 01         =2  2394 +1         DB      01H
                =2  2396 +1         LIT_    LOW(PWM2)    ;Push low byte of ADDR onto Stack
06F6 5110       =2  2397 +1         CALL    LIT
06F8 22         =2  2398 +1         DB      LOW(PWM2)
                =2  2400 +1         LIT_    HIGH(PWM2)   ;Push high byte of ADDR onto Stack
06F9 5110       =2  2401 +1         CALL    LIT
06FB 00         =2  2402 +1         DB      HIGH(PWM2)
06FC C10F       =2  2404            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2405    
                =2  2406    ;
                =2  2407    
06FE            =2  2408    TST_PWM2:                       ; Test it 'PWM0' token
06FE D123       =2  2409            call tst
0700 50574DB2   =2  2410            db      'PWM',('2' OR 80H )
0704 500B       =2  2411            JNC     TST_PWM3
                =2  2412 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0706 5110       =2  2413 +1         CALL    LIT
0708 01         =2  2414 +1         DB      01H
                =2  2416 +1         LIT_    LOW(PWM2)    ;Push low byte of ADDR onto Stack
0709 5110       =2  2417 +1         CALL    LIT
070B 22         =2  2418 +1         DB      LOW(PWM2)
                =2  2420 +1         LIT_    HIGH(PWM2)   ;Push high byte of ADDR onto Stack
070C 5110       =2  2421 +1         CALL    LIT
070E 00         =2  2422 +1         DB      HIGH(PWM2)
070F C10F       =2  2424            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2425    
0711            =2  2426    TST_PWM3:                       ; Test it 'PWM0' token
0711 D123       =2  2427            call tst
0713 50574DB3   =2  2428            db      'PWM',('3' OR 80H )
0717 500B       =2  2429            JNC     TST_PWM4
                =2  2430 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0719 5110       =2  2431 +1         CALL    LIT
071B 01         =2  2432 +1         DB      01H
                =2  2434 +1         LIT_    LOW(PWM3)    ;Push low byte of ADDR onto Stack
071C 5110       =2  2435 +1         CALL    LIT
071E 23         =2  2436 +1         DB      LOW(PWM3)
                =2  2438 +1         LIT_    HIGH(PWM3)   ;Push high byte of ADDR onto Stack
071F 5110       =2  2439 +1         CALL    LIT
0721 00         =2  2440 +1         DB      HIGH(PWM3)
0722 C10F       =2  2442            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2443    
0724            =2  2444    TST_PWM4:                       ; Test it 'PWM0' token
0724 D123       =2  2445            call tst
0726 50574DB4   =2  2446            db      'PWM',('4' OR 80H )
072A 500B       =2  2447            JNC     TST_PWM5
                =2  2448 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
072C 5110       =2  2449 +1         CALL    LIT
LILBASIC        LilBasic (c)2002                                                                              PAGE 43

072E 01         =2  2450 +1         DB      01H
                =2  2452 +1         LIT_    LOW(PWM4)    ;Push low byte of ADDR onto Stack
072F 5110       =2  2453 +1         CALL    LIT
0731 24         =2  2454 +1         DB      LOW(PWM4)
                =2  2456 +1         LIT_    HIGH(PWM4)   ;Push high byte of ADDR onto Stack
0732 5110       =2  2457 +1         CALL    LIT
0734 00         =2  2458 +1         DB      HIGH(PWM4)
0735 C10F       =2  2460            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2461    
0737            =2  2462    TST_PWM5:                       ; Test it 'PWM0' token
0737 D123       =2  2463            call tst
0739 50574DB5   =2  2464            db      'PWM',('5' OR 80H )
073D 500B       =2  2465            JNC     TST_PWM6
                =2  2466 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
073F 5110       =2  2467 +1         CALL    LIT
0741 01         =2  2468 +1         DB      01H
                =2  2470 +1         LIT_    LOW(PWM6)    ;Push low byte of ADDR onto Stack
0742 5110       =2  2471 +1         CALL    LIT
0744 26         =2  2472 +1         DB      LOW(PWM6)
                =2  2474 +1         LIT_    HIGH(PWM6)   ;Push high byte of ADDR onto Stack
0745 5110       =2  2475 +1         CALL    LIT
0747 00         =2  2476 +1         DB      HIGH(PWM6)
0748 C10F       =2  2478            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2479    
074A            =2  2480    TST_PWM6:                       ; Test it 'PWM0' token
074A D123       =2  2481            call tst
074C 50574DB6   =2  2482            db      'PWM',('6' OR 80H )
0750 500B       =2  2483            JNC     TST_PWM7
                =2  2484 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0752 5110       =2  2485 +1         CALL    LIT
0754 01         =2  2486 +1         DB      01H
                =2  2488 +1         LIT_    LOW(PWM6)    ;Push low byte of ADDR onto Stack
0755 5110       =2  2489 +1         CALL    LIT
0757 26         =2  2490 +1         DB      LOW(PWM6)
                =2  2492 +1         LIT_    HIGH(PWM6)   ;Push high byte of ADDR onto Stack
0758 5110       =2  2493 +1         CALL    LIT
075A 00         =2  2494 +1         DB      HIGH(PWM6)
075B C10F       =2  2496            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2497    
075D            =2  2498    TST_PWM7:                       ; Test it 'PWM0' token
075D D123       =2  2499            call tst
075F 50574DB7   =2  2500            db      'PWM',('7' OR 80H )
0763 500B       =2  2501            JNC     TST_PWM_END
                =2  2502 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0765 5110       =2  2503 +1         CALL    LIT
0767 01         =2  2504 +1         DB      01H
                =2  2506 +1         LIT_    LOW(PWM7)    ;Push low byte of ADDR onto Stack
0768 5110       =2  2507 +1         CALL    LIT
076A 27         =2  2508 +1         DB      LOW(PWM7)
                =2  2510 +1         LIT_    HIGH(PWM7)   ;Push high byte of ADDR onto Stack
076B 5110       =2  2511 +1         CALL    LIT
076D 00         =2  2512 +1         DB      HIGH(PWM7)
076E C10F       =2  2514            JMP     D_BLNK          ;Remove leading blanks from source line.
0770            =2  2515    TST_PWM_END:
                =2  2516    $INCLUDE(AES\PASVAL\DBYTE.ASM)
0770            =2  2517    tst_dbyte:
0770 D123       =2  2518            call   tst                ;Test if 'DBYTE' token.
0772 44425954   =2  2519            db      'DBYT',('E' OR 80H)
LILBASIC        LilBasic (c)2002                                                                              PAGE 44

0776 C5         
0777 5005       =2  2520            jnc     tst_dbyte_end
                =2  2521 +1         LIT_    1                 ; Push a 1 onto AES STACK
0779 5110       =2  2522 +1         CALL    LIT
077B 01         =2  2523 +1         DB      1
077C 8029       =2  2525            SJMP    INDEX
077E            =2  2526    tst_dbyte_end:
                =2  2527    $INCLUDE(AES\PASVAL\RBIT.ASM)
077E            =2  2528    TST_RBIT:
077E D123       =2  2529            call   tst                ;Test for RBIT
0780 524249D4   =2  2530            db      'RBI',('T' OR 80H)
0784 5005       =2  2531            jnc     TST_RBIT_END
                =2  2532 +1         LIT_    2                 ; PUSH a 2 onto AES STACK
0786 5110       =2  2533 +1         CALL    LIT
0788 02         =2  2534 +1         DB      2
0789 801C       =2  2536            SJMP    INDEX
078B            =2  2537    TST_RBIT_END:
                =2  2538    $INCLUDE(AES\PASVAL\XBYTE.ASM)
078B            =2  2539    TST_XBYTE:
078B D123       =2  2540            call   tst                ;Test for Xbyte
078D 58425954   =2  2541            db      'XBYT',('E' OR 80H)
0791 C5         
0792 5005       =2  2542            jnc     TST_XBYTE_END
                =2  2543 +1         LIT_    3                 ; PUSH a 3 ONTO AES STACK
0794 5110       =2  2544 +1         CALL    LIT
0796 03         =2  2545 +1         DB      3
0797 800E       =2  2547            SJMP    INDEX
0799            =2  2548    TST_XBYTE_END:
                =2  2549    $INCLUDE(AES\PASVAL\CBYTE.ASM)
0799            =2  2550    TST_CBYTE:
0799 D123       =2  2551            call   tst
079B 43425954   =2  2552            db      'CBYT',('E' OR 80H)
079F C5         
07A0 5003       =2  2553            jnc     TST_CBYTE_END
                =2  2554 +1         LIT_    4
07A2 5110       =2  2555 +1         CALL    LIT
07A4 04         =2  2556 +1         DB      4
07A5            =2  2558    TST_CBYTE_END:
                =1  2559    
07A5 C3         =1  2560    NOTSYM: CLR     C               ;Indicate that condition tested wasn't true.
07A6 22         =1  2561            RET
                =1  2562    ;==============================================================================
                =1  2563    ;
07A7 1210D5     =1  2564    INDEX:  CALL    VAR               ;Get value of Next variable
07AA D3         =1  2565            SETB    C                 ;Set to true
07AB 22         =1  2566            RET
                =1  2567    ;==============================================================================
                =1  2568    ;
                =1  2569    ;
                =1  2570    ;       BASIC Variable name is legitimate (A-Z).
                =1  2571    ;
                =1  2572 +1 TSTV_1: LIT_    0               ;Push a 0 onto AES (Varable)
07AC 5110       =1  2573 +1         CALL    LIT
07AE 00         =1  2574 +1         DB      0
07AF 7F00       =1  2576            MOV     TOS_H,#0        ;Clear High byte.
07B1 31DF       =1  2577            CALL    PUSH_TOS        ;Push var. (A-Z) onto stack as 16 bit # 1-26
07B3 D259       =1  2578            SETB    CHAR_FLG        ;
07B5 C10F       =1  2579            JMP     D_BLNK          ;Remove leading blanks from source line.
LILBASIC        LilBasic (c)2002                                                                              PAGE 45

                =1  2580                                    ;and return
                =1  2581    ;
                    2582    ;===============
                    2583    ;TSTN   (LBL)
                    2584    ;       Test if indicated string is an unsigned number.
                    2585    ;       If so, move cursor over string and trailing blanks,
                    2586    ;       compute number's binary value,
                    2587    ;       push onto arithmetic expression stack, and continue with
                    2588    ;       following IL instruction.
                    2589    ;       Otherwise restore cursor and branch to IL instruction at LBL.
                    2590    ;
                    2591    ;TSTL   (LBL)
                    2592    ;       Test if first non-blank string is a BASIC source line number.
                    2593    ;       If so, move cursor over string and following blanks,
                    2594    ;       compute number's binary value,
                    2595    ;       push onto arithmetic expression stack,
                    2596    ;       and continue with next IL instruction.
                    2597    ;       If invalid source line number report syntax error.
                    2598    ;       If line number not present restore cursor
                    2599    ;       and branch to IL instruction at LBL.
                    2600    ;
                =1  2601    $INCLUDE(AES\TSTN.ASM)
                =1  2602    ;TSTN   (LBL)
                =1  2603    ;       Test if indicated string is an unsigned number.
                =1  2604    ;       If so, move cursor over string and trailing blanks,
                =1  2605    ;       compute number's binary value,
                =1  2606    ;       push onto arithmetic expression stack, and continue with
                =1  2607    ;       following IL instruction.
                =1  2608    ;       Otherwise restore cursor and branch to IL instruction at LBL.
                =1  2609    ;
                =1  2610    ;
07B7 B1E5       =1  2611    TSTN:   CALL    READ_CHAR
07B9 7190       =1  2612            CALL    CREATE          ;Create entry on AES if legit. digit.
07BB 4003       =1  2613            JC      TSTN_1          ;Abort if CHAR is not decimal digit.
07BD D259       =1  2614            SETB    CHAR_FLG
07BF 22         =1  2615            RET
                =1  2616    ;
07C0 B1E5       =1  2617    TSTN_1: CALL    READ_CHAR       ;Move over matched character.
07C2 719D       =1  2618            CALL    APPEND          ;Append new digit to entry on TOS.
07C4 40FA       =1  2619            JC      TSTN_1          ;Continue processing while legal characters.
07C6 31DF       =1  2620            CALL    PUSH_TOS
07C8 D259       =1  2621            SETB    CHAR_FLG
07CA C10F       =1  2622            JMP     D_BLNK          ;Remove leading blank characters.
                =1  2623    ;
                    2624    ;===============
                    2625    ;TSTS   (LBL)
                    2626    ;       Test if first character is a quote.
                    2627    ;       If so, print characters from the BASIC source program to the console
                    2628    ;       until a (closing) quote is encountered,
                    2629    ;       pass over any trailing blanks,
                    2630    ;       leave source cursor pointing to first non-blank character,
                    2631    ;       and branch to IL instruction at location (LBL).
                    2632    ;       (Report syntax error if <CR> encountered before quote.)
                    2633    ;       If first character is not a quote, return to next
                    2634    ;       sequential IL instruction with cursor unchanged.
                    2635    ;
                =1  2636    $INCLUDE(AES\TSTS.ASM)
                =1  2637    ;TSTS   (LBL)
LILBASIC        LilBasic (c)2002                                                                              PAGE 46

                =1  2638    ;       Test if first character is a quote.
                =1  2639    ;       If so, print characters from the BASIC source program to the console
                =1  2640    ;       until a (closing) quote is encountered,
                =1  2641    ;       pass over any trailing blanks,
                =1  2642    ;       leave source cursor pointing to first non-blank character,
                =1  2643    ;       and branch to IL instruction at location (LBL).
                =1  2644    ;       (Report syntax error if <CR> encountered before quote.)
                =1  2645    ;       If first character is not a quote, return to next
                =1  2646    ;       sequential IL instruction with cursor unchanged.
                =1  2647    ;
07CC B1E5       =1  2648    TSTS:   CALL    READ_CHAR
07CE F508       =1  2649            MOV     TMP0,A
07D0 6422       =1  2650            XRL     A,#'"'
07D2 6008       =1  2651            JZ      TSTS_1
07D4 6405       =1  2652            XRL     A,#'''' XOR '"'
07D6 6004       =1  2653            JZ      TSTS_1
07D8 C3         =1  2654            CLR     C
07D9 D259       =1  2655            SETB    CHAR_FLG
07DB 22         =1  2656            RET
                =1  2657    ;
07DC B1E5       =1  2658    TSTS_1: CALL    READ_CHAR       ;Read next string character.
07DE B50802     =1  2659            CJNE    A,TMP0,TSTS_2
07E1 C10F       =1  2660            JMP     D_BLNK
                =1  2661    ;
07E3 312A       =1  2662    TSTS_2: CALL    C_OUT           ;Call output routine.
07E5 B40DF4     =1  2663            CJNE    A,#CR,TSTS_1    ;<CR> before closing quote is illegal.
07E8 020FF4     =1  2664            JMP     SYN_ER          ;Transmit error message.
                =1  2665    ;
                    2666    ;========
                    2667    ;DONE
                    2668    ;       Delete leading blanks from the BASIC source line.
                    2669    ;       Return with the cursor positioned over the first non-blank
                    2670    ;       character, which must be a colon or <CR> in the source line.
                    2671    ;       If any other characters are encountered report a syntax error.
                =1  2672    $INCLUDE(AES\DONE.ASM)
                =1  2673    ;DONE
                =1  2674    ;       Delete leading blanks from the BASIC source line.
                =1  2675    ;       Return with the cursor positioned over the first non-blank
                =1  2676    ;       character, which must be a colon or <CR> in the source line.
                =1  2677    ;       If any other characters are encountered report a syntax error.
                =1  2678    ;
                =1  2679    ;
                =1  2680    ;
07EB B1E5       =1  2681    DONE:   CALL    READ_CHAR
07ED BC3A03     =1  2682            CJNE    CHAR,#':',DONE_1        ;Colon indicates resume interpretation.
07F0 22         =1  2683            RET                     ;Return to IL.
                =1  2684    ;
07F1 B1E5       =1  2685    LNDONE: CALL    READ_CHAR
07F3 BC0D01     =1  2686    DONE_1: CJNE    CHAR,#CR,DONE_2 ;Any non-colon, non-CR characters are illegal.
07F6 22         =1  2687            RET
                =1  2688    ;
07F7 D259       =1  2689    DONE_2: SETB    CHAR_FLG
07F9 020FF4     =1  2690            JMP     SYN_ER          ;Process syntax error if so.
                =1  2691    ;
                    2692    ;=======
                    2693    ;IFDONE (LBL)
                    2694    ;       If the first non-blank character is a colon or <CR> in the source line
                    2695    ;       then branch to the IL instruction specified by (LBL).
LILBASIC        LilBasic (c)2002                                                                              PAGE 47

                    2696    ;       If any other characters are encountered
                    2697    ;       then continue with next IL instruction.
                    2698    ;
                =1  2699    $INCLUDE(AES\IFDONE.ASM)
                =1  2700    ;IFDONE (LBL)
                =1  2701    ;       If the first non-blank character is a colon or <CR> in the source line
                =1  2702    ;       then branch to the IL instruction specified by (LBL).
                =1  2703    ;       If any other characters are encountered
                =1  2704    ;       then continue with next IL instruction.
                =1  2705    ;
                =1  2706    ;
07FC B1E5       =1  2707    IFDONE: CALL    READ_CHAR
07FE BC3A01     =1  2708            CJNE    CHAR,#':',IFDN_1        ;Colon indicates resume interpretation.
0801 22         =1  2709            RET                     ;Return to IL.
                =1  2710    ;
0802 BC0D01     =1  2711    IFDN_1: CJNE    CHAR,#CR,IFDN_2 ;Any non-colon, non-CR characters are illegal.
0805 22         =1  2712            RET
                =1  2713    ;
0806 D259       =1  2714    IFDN_2: SETB    CHAR_FLG
0808 D3         =1  2715            SETB    C
0809 22         =1  2716            RET
                =1  2717    ;
                    2718    ;=======
                    2719    ;READ_LABEL
                    2720    ;       Read next two characters from program buffer into <LABL_H><LABL_L>.
                    2721    ;       Return with carry set if bit 15 of LABL is set (indicating EOF).
                =1  2722    $INCLUDE(AES\R_LABEL.ASM)
080A            =1  2723    READ_LABEL:
                =1  2724    ;       Read next two characters from program buffer into <LABL_H><LABL_L>.
                =1  2725    ;       Return with carry set if bit 15 of LABL is set (indicating EOF).
                =1  2726    ;
080A 1205E5     =1  2727            CALL    READ_CHAR
080D F519       =1  2728            MOV     LABL_H,A
080F 1205E5     =1  2729            CALL    READ_CHAR
0812 F518       =1  2730            MOV     LABL_L,A
0814 E519       =1  2731            MOV     A,LABL_H
0816 A2E7       =1  2732            MOV     C,ACC.7
0818 22         =1  2733            RET
                =1  2734    ;
                    2735    ;=======
                    2736    ;L_INIT:
                    2737    ;       Initialize for execution of new BASIC source line.
                    2738    ;       If none present, or if not in sequential execution mode,
                    2739    ;       then return to line collection operation.
                =1  2740    $INCLUDE(AES\LINIT.ASM)
0819            =1  2741    L_INIT:
                =1  2742    ;       Initialize for execution of new BASIC source line.
                =1  2743    ;       If none present, or if not in sequential execution mode,
                =1  2744    ;       then return to line collection operation.
                =1  2745    ;
0819 305302     =1  2746            JNB     RUNMOD,LINI_1   ;Determine operating mode.
081C 80EC       =1  2747            JMP     READ_LABEL
                =1  2748    ;
081E D3         =1  2749    LINI_1: SETB    C
081F 22         =1  2750            RET
                =1  2751    ;
                    2752    ;=======
                    2753    ;NL_NXT:
LILBASIC        LilBasic (c)2002                                                                              PAGE 48

                    2754    ;       Output a <CR><LF> and continue with NXT routine.
                    2755    ;
                    2756    ;
                    2757    ;NXT:
                    2758    ;       A colon or carriage return has been previously READ_CHARed.
                    2759    ;       If CHAR holds a colon,
                    2760    ;       continue interpretation of source line in current mode
                    2761    ;       from IL program instruction "TOKEN".
                    2762    ;       Otherwise CHAR is a <CR>, and line has been completed.
                    2763    ;       Resume execution from IL instruction "STMT".
                =1  2764    $INCLUDE(AES\NXT.ASM)
0820            =1  2765    NL_NXT:
                =1  2766    ;       Output a <CR><LF> and continue with NXT routine.
                =1  2767    ;
0820 120128     =1  2768            CALL    NLINE
                =1  2769    ;
0823            =1  2770    NXT:
                =1  2771    ;       A colon or carriage return has been previously READ_CHARed.
                =1  2772    ;       If CHAR holds a colon,
                =1  2773    ;       continue interpretation of source line in current mode
                =1  2774    ;       from IL program instruction "TOKEN".
                =1  2775    ;       Otherwise CHAR is a <CR>, and line has been completed.
                =1  2776    ;       Resume execution from IL instruction "STMT".
                =1  2777    ;
0823 BC3A06     =1  2778            CJNE    CHAR,#':',NXT_1 ;Skip ahead unless colon detected.
0826 12060F     =1  2779            CALL    D_BLNK
0829 020ABD     =1  2780            JMP     TOKEN           ;Continue with interpretation.
                =1  2781    ;
082C 020AB9     =1  2782    NXT_1:  JMP     STMT
                =1  2783    ;
                    2784    ;=======
                    2785    ;GETLN:
                    2786    ;       Input a line from console input device and put in line buffer
                    2787    ;       in internal RAM.
                =1  2788    $INCLUDE(AES\GETLN.ASM)
082F            =1  2789    GETLN:
                =1  2790    ;       Input a line from console input device and put in line buffer
                =1  2791    ;       in internal RAM.
                =1  2792    ;
082F E51D       =1  2793            MOV     A,AESP
0831 2404       =1  2794            ADD     A,#4
0833 F508       =1  2795            MOV     TMP0,A
0835            =1  2796    GETL_0:
0835 A808       =1  2797            MOV     R0,TMP0         ;Point to beginning of line buffer.
0837 12018B     =1  2798            CALL    STROUT
083A 2D2DBE     =1  2799            DB      '--',('>' OR 80H)  ;Display Prompt. -->
083D            =1  2800    GETL_1:
083D 120119     =1  2801            CALL    C_IN            ;Get next character from console.
0840 60FB       =1  2802            JZ      GETL_1          ;Skip over nul Chars                            Process Nul 
                                                                               Char
0842 B41217     =1  2803            CJNE    A,#CTRL_R,GETL_5   ;Re-type line on <CNTRL-R>.                  Process CTYR
                                                                               L-R
0845 12018B     =1  2804            CALL    STROUT
0848 8D         =1  2805            DB      (CR OR 80H)     ;Newline.
0849 8815       =1  2806            MOV     CURS_L,R0       ;Save old value of cursor.
084B A808       =1  2807            MOV     R0,TMP0         ;Start at beginning of line buffer.
084D E8         =1  2808    GETL_6: MOV     A,R0            ;Check if re-write done.
084E 6515       =1  2809            XRL     A,CURS_L
LILBASIC        LilBasic (c)2002                                                                              PAGE 49

0850 60EB       =1  2810            JZ      GETL_1          ;Continue with line input.
                =1  2811 +1         PAGE    #0H             ;ZERO PAGE for AES
0852 75A000     =1  2812 +1         MOV     P2,#0H
0855 E2         =1  2814            MOVX     A,@R0           ;Load character to re-write.
0856 12012A     =1  2815            CALL    C_OUT
0859 08         =1  2816            INC     R0
085A 80F1       =1  2817            SJMP    GETL_6          ;Continue until done.
                =1  2818    ;
085C B47F07     =1  2819    GETL_5: CJNE    A,#DEL,GETL_7   ;Cancel whole line on <DEL>.
085F 12018B     =1  2820            CALL    STROUT
0862 238D       =1  2821            DB      '#',(CR OR 80H) ;Advance to next line.
0864 80CF       =1  2822            SJMP    GETL_0
                =1  2823    ;
0866 B40813     =1  2824    GETL_7: CJNE    A,#BS,GETL_3                                                    ;Process Bac
                                                                               k space
0869 E8         =1  2825            MOV     A,R0
086A B50806     =1  2826            CJNE    A,TMP0,GETL_4   ;Delete previous character (if any).
086D 12018B     =1  2827            CALL    STROUT
0870 87         =1  2828            DB      (BEL OR 80H)    ;Echo <BEL>.
0871 80CA       =1  2829            SJMP    GETL_1          ;Ignore rubouts at beginning of line
                =1  2830    ;
0873 12018B     =1  2831    GETL_4: CALL    STROUT
0876 082088     =1  2832            DB      BS,' ',(BS OR 80H)     ;BKSP,SPC,BKSP
0879 18         =1  2833            DEC     R0              ;Wipeout last char.
087A 80C1       =1  2834            SJMP    GETL_1
                =1  2835    ;
087C B8FE06     =1  2836    GETL_3: CJNE    R0,#0FEH,GETL_2 ;Test if buffer full.
087F 12018B     =1  2837            CALL    STROUT          ;Echo <BEL>.
0882 87         =1  2838            DB      (BEL OR 80H)
0883 80B8       =1  2839            SJMP    GETL_1          ;If so, override character received.
                =1  2840    ;
                =1  2841 +1 GETL_2: PAGE    #0H             ;ZERO PAGE for AES
0885 75A000     =1  2842 +1         MOV     P2,#0H
0888 F2         =1  2844            MOVX     @R0,A           ;Store into line buffer.
0889 12012A     =1  2845            CALL    C_OUT           ;Echo character.
088C 08         =1  2846            INC     R0              ;Bump pointer.
088D B40DAD     =1  2847            CJNE    A,#CR,GETL_1    ;Repeat for next character.
0890 A808       =1  2848            MOV     PNTR_L,TMP0     ;Point cursor to beginning of line buffer.
0892 C259       =1  2849            CLR     CHAR_FLG
0894 22         =1  2850            RET
                =1  2851    ;
                    2852    ;===============
                    2853    ;PRN:
                    2854    ;       Pop top of arithmetic expression stack (AES),
                    2855    ;       convert to decimal number,
                    2856    ;       and print to console output device, suppressing leading zeroes.
                    2857    ;
                =1  2858    $INCLUDE(AES\PRN_.ASM)
0895            =1  2859    PRN:
                =1  2860    ;       Pop top of arithmetic expression stack (AES),
                =1  2861    ;       convert to decimal number,
                =1  2862    ;       and print to console output device, suppressing leading zeroes.
                =1  2863    ;
0895 C25A       =1  2864            CLR     SGN_FLG
0897 120437     =1  2865            CALL    IABS
089A 1201C1     =1  2866            CALL    POP_TOS
089D D258       =1  2867    PRNTOS: SETB    ZERSUP          ;Set zero suppression flag.
089F E4         =1  2868            CLR     A
LILBASIC        LilBasic (c)2002                                                                              PAGE 50

08A0 F508       =1  2869            MOV     TMP0,A
08A2 7D10       =1  2870            MOV     LP_CNT,#16      ;Conversion precision.
                =1  2871    
08A4 20541E     =1  2872            JB      HEXMOD,PRNHEX   ;If in hexmode, then jump to ...
                =1  2873    
08A7 305A04     =1  2874            JNB     SGN_FLG,PRN_1   ;Skip ahead if positive number.
08AA 12018B     =1  2875            CALL    STROUT          ;Output minus sign if negative.
08AD AD         =1  2876            DB      ('-' OR 80H)
                =1  2877    
08AE CE         =1  2878    PRN_1:  XCH     A,TOS_L
08AF 33         =1  2879            RLC     A
08B0 CE         =1  2880            XCH     A,TOS_L
08B1 CF         =1  2881            XCH     A,TOS_H
08B2 33         =1  2882            RLC     A
08B3 CF         =1  2883            XCH     A,TOS_H
08B4 C508       =1  2884            XCH     A,TMP0
08B6 35E0       =1  2885            ADDC    A,ACC
08B8 D4         =1  2886            DA      A
08B9 C508       =1  2887            XCH     A,TMP0
08BB 35E0       =1  2888            ADDC    A,ACC
08BD D4         =1  2889            DA      A
08BE DDEE       =1  2890            DJNZ    LP_CNT,PRN_1
08C0 FF         =1  2891            MOV     TOS_H,A
08C1 EE         =1  2892            MOV     A,TOS_L
08C2 33         =1  2893            RLC     A
08C3 AE08       =1  2894            MOV     TOS_L,TMP0
                =1  2895    
08C5 12015C     =1  2896    PRNHEX: CALL    NIBOUT
08C8 EF         =1  2897            MOV     A,TOS_H
08C9 C4         =1  2898            SWAP    A
08CA 12015C     =1  2899            CALL    NIBOUT          ;Print second digit.
08CD EF         =1  2900            MOV     A,TOS_H
08CE 12015C     =1  2901            CALL    NIBOUT          ;Print third digit.
08D1 305402     =1  2902            JNB     HEXMOD,PRNH_1
08D4 C258       =1  2903            CLR     ZERSUP          ;Print out last two chars. (at least) in hex.
                =1  2904    
08D6 EE         =1  2905    PRNH_1: MOV     A,TOS_L         ;Read into Acc.
08D7 C4         =1  2906            SWAP    A               ;Interchange nibbles.
08D8 12015C     =1  2907            CALL    NIBOUT          ;Print fourth digit.
08DB C258       =1  2908            CLR     ZERSUP
08DD EE         =1  2909            MOV     A,TOS_L         ;Reload byte.
08DE 12015C     =1  2910            CALL    NIBOUT          ;Print last digit.
08E1 305404     =1  2911            JNB     HEXMOD,PRNRET
08E4 12018B     =1  2912            CALL    STROUT          ;Print trailing "H".
08E7 C8         =1  2913            DB      ('H' OR 80H)
08E8 22         =1  2914    PRNRET: RET
                =1  2915    ;
                    2916    ;===============
                    2917    ;LSTLIN:
                    2918    ;       Check Label of Program line pointed to by Cursor.
                    2919    ;       If legal, print line number, source line, and <CR><LF> to console,
                    2920    ;       adjust Cursor to start of next line,
                    2921    ;       and return with carry set.
                    2922    ;       Else return with carry cleared.
                    2923    ;
                =1  2924    $INCLUDE(AES\LSTLIN.ASM)
08E9            =1  2925    LSTLIN:
                =1  2926    ;       Check Label of Program line pointed to by Cursor.
LILBASIC        LilBasic (c)2002                                                                              PAGE 51

                =1  2927    ;       If legal, print line number, source line, and <CR><LF> to console,
                =1  2928    ;       adjust Cursor to start of next line,
                =1  2929    ;       and return with carry set.
                =1  2930    ;       Else return with carry cleared.
                =1  2931    ;
08E9 110A       =1  2932            CALL    READ_LABEL
08EB 4015       =1  2933            JC      LSTL_1
08ED AF19       =1  2934            MOV     TOS_H,LABL_H
08EF AE18       =1  2935            MOV     TOS_L,LABL_L
08F1 C25A       =1  2936            CLR     SGN_FLG
08F3 119D       =1  2937            CALL    PRNTOS
08F5 12018B     =1  2938            CALL    STROUT          ;Insert space before user's source line.
08F8 A0         =1  2939            DB      (' ' OR 80H)
08F9 1205E5     =1  2940    LSTL_2: CALL    READ_CHAR
08FC 12012A     =1  2941            CALL    C_OUT
08FF B40DF7     =1  2942            CJNE    A,#CR,LSTL_2
0902 22         =1  2943    LSTL_1: RET
                =1  2944    ;
                    2945    ;===============
                    2946    ;LST
                    2947    ;       List the contents of the program memory area.
                    2948    ;
                =1  2949    $INCLUDE(AES\LST.ASM)
                =1  2950    ;LST
                =1  2951    ;       List the contents of the program memory area.
                =1  2952    ;
                =1  2953    ;
0903 D253       =1  2954    LST:    SETB    RUNMOD
0905 12058F     =1  2955            CALL    REWIND          ;Point to first char of external buffer.
0908 120147     =1  2956    LST_1:  CALL    CNTRL
090B 4004       =1  2957            JC      LSTRET
090D 11E9       =1  2958            CALL    LSTLIN          ;Print out current line if present.
090F 50F7       =1  2959            JNC     LST_1           ;Repeat if successful.
0911 C253       =1  2960    LSTRET: CLR     RUNMOD
0913 22         =1  2961            RET
                =1  2962    ;
                    2963    ;===============
                    2964    ;INNUM:
                    2965    ;       Read a numeric character string from the console input device.
                    2966    ;       Convert to binary value and push onto arithmetic expression stack.
                    2967    ;       Report error if illegal characters read.
                =1  2968    $INCLUDE(AES\INUM.ASM)
0914            =1  2969    INNUM:
                =1  2970    ;       Read a numeric character string from the console input device.
                =1  2971    ;       Convert to binary value and push onto arithmetic expression stack.
                =1  2972    ;       Report error if illegal characters read.
                =1  2973    ;
0914 C25A       =1  2974            CLR     SGN_FLG         ;Assume number will be positive.
0916 12018B     =1  2975            CALL    STROUT
0919 3AA0       =1  2976            DB      ':',(' ' OR 80H);Print input prompt.
091B 120119     =1  2977    INUM_0: CALL    C_IN
091E 12012A     =1  2978            CALL    C_OUT           ;Echo input
0921 B42002     =1  2979            CJNE    A,#' ',INUM_3
0924 80F5       =1  2980            SJMP    INUM_0
                =1  2981    ;
0926 B42B02     =1  2982    INUM_3: CJNE    A,#'+',INUM_4
0929 80F0       =1  2983            SJMP    INUM_0
                =1  2984    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 52

092B B42D04     =1  2985    INUM_4: CJNE    A,#'-',INUM_5
092E B25A       =1  2986            CPL     SGN_FLG
0930 80E9       =1  2987            SJMP    INUM_0
                =1  2988    ;
0932 120390     =1  2989    INUM_5: CALL    CREATE          ;Create value on stack if legal decimal digit.
0935 5009       =1  2990            JNC     INUM_2          ;Abort if first character received not legal.
0937 120119     =1  2991    INUM_1: CALL    C_IN            ;Get additional characters.
093A 12012A     =1  2992            CALL    C_OUT           ;Echo input.
093D B47F07     =1  2993            CJNE    A,#7FH,INUM_6   ;Start over if delete char detected.
0940 12018B     =1  2994    INUM_2: CALL    STROUT
0943 238D       =1  2995            DB      '#',(CR OR 80H)
0945 80CD       =1  2996            SJMP    INNUM
                =1  2997    ;
0947 12039D     =1  2998    INUM_6: CALL    APPEND          ;Incorporate into stack entry.
094A 40EB       =1  2999            JC      INUM_1          ;Loop while legal characters arrive.
094C 1201DF     =1  3000            CALL    PUSH_TOS
094F 020444     =1  3001            JMP     NEG_IF_NEG
                =1  3002    ;
                    3003    ;===============
                    3004    ;INIT
                    3005    ;       Perform global initialization:
                    3006    ;       Clear program memory, empty all I/O buffers, reset all stack
                    3007    ;       pointers, etc.
                =1  3008    $INCLUDE(AES\INIT.ASM)
                =1  3009    ;INIT
                =1  3010    ;       Perform global initialization:
                =1  3011    ;       Clear program memory, empty all I/O buffers, reset all stack
                =1  3012    ;       pointers, etc.
                =1  3013    ;
                =1  3014    ;
0952 120955     =1  3015    INIT:   CALL    RAM_INIT
0955            =1  3016    RAM_INIT:
0955 E4         =1  3017            CLR     A               ;Quick & easy version of 00H
0956 F52A       =1  3018            MOV     MODE,A          ;Interactive mode, decimal radix.
0958 F52B       =1  3019            MOV     FLAGS,A         ;Interroutine flags.
                =1  3020    
                =1  3021    
                =1  3022                                    ;Wipe all System memory
095A 900000     =1  3023            MOV     DPTR,#0000H     ;Set DPTR to 0000H
095D            =1  3024    INIT_LOOP_1:
095D F0         =1  3025            MOVX    @DPTR,A         ;Clear a byte
095E A3         =1  3026            INC     DPTR            ;Bump to next byte
095F A883       =1  3027            MOV     R0,DPH          ;Check if Highbyte at RAMLIMit yet?
0961 B87FF9     =1  3028            CJNE    R0,#HIGH(RAMLIM),INIT_LOOP_1
0964 A882       =1  3029            MOV     R0,DPL          ;Check if Lowbyte at RAMLIMit yet?
0966 B8FFF4     =1  3030            CJNE    R0,#LOW(RAMLIM),INIT_LOOP_1
                =1  3031    
0969 902000     =1  3032            MOV     DPTR,#EXTRAM    ;Set pointer to beginning of program mem
096C 7480       =1  3033            MOV     A,#080H
096E F0         =1  3034            MOVX    @DPTR,A         ;Store 80H at beginning of program
096F 22         =1  3035            RET
                    3036    
                    3037    ;=====================================================================================
                    3038    ;                      BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
                    3039    ;=====================================================================================;
                    3040    
                    3041    ;XINIT
                    3042    ;       Perform initialization needed before starting sequential execution.
LILBASIC        LilBasic (c)2002                                                                              PAGE 53

                    3043    ;       Empty stacks, set BASIC line number to 1, etc.
                    3044    
                =1  3045    $INCLUDE(AES\XINIT.ASM)
                =1  3046    ;XINIT
                =1  3047    ;       Perform initialization needed before starting sequential execution.
                =1  3048    ;       Empty stacks, set BASIC line number to 1, etc.
                =1  3049    ;
                =1  3050    ;
0970 751D00     =1  3051    XINIT:  MOV     AESP,#00H     ;Initialize AE Stack.
0973 12058F     =1  3052            CALL    REWIND
0976 D253       =1  3053            SETB    RUNMOD
0978 22         =1  3054            RET                     ;Begin execution.
                =1  3055    ;
                    3056    ;===============
                    3057    ;FNDLBL:
                    3058    ;       Search program buffer for line with label passed on AES (Pop AES).
                    3059    ;       If found, return with CURSOR pointing to start of line (before label)
                    3060    ;       and carry cleared.
                    3061    ;       If not found return with carry set and pointer at start of first
                    3062    ;       line with a greater label value (possible EOF).
                =1  3063    $INCLUDE(AES\FNDLBL.ASM)
0979            =1  3064    FNDLBL:
                =1  3065    ;       Search program buffer for line with label passed on AES (Pop AES).
                =1  3066    ;       If found, return with CURSOR pointing to start of line (before label)
                =1  3067    ;       and carry cleared.
                =1  3068    ;       If not found return with carry set and pointer at start of first
                =1  3069    ;       line with a greater label value (possible EOF).
                =1  3070    ;
0979 D253       =1  3071            SETB    RUNMOD          ;Kludge to make GET_C fetch from prog. buffer.
097B 12058F     =1  3072            CALL    REWIND
097E 1201C1     =1  3073            CALL    POP_TOS
0981 1205AD     =1  3074    FND_1:  CALL    SAVE_PNTR       ;Store position of beginning of line.
0984 110A       =1  3075            CALL    READ_LABEL
0986 4013       =1  3076            JC      FNDDON
0988 EE         =1  3077            MOV     A,TOS_L
0989 9518       =1  3078            SUBB    A,LABL_L
098B F518       =1  3079            MOV     LABL_L,A        ;Save non-zero bits.
098D EF         =1  3080            MOV     A,TOS_H
098E 9519       =1  3081            SUBB    A,LABL_H
0990 4518       =1  3082            ORL     A,LABL_L        ;Test for non-zero bits.
0992 6007       =1  3083            JZ      FNDDON
0994 4005       =1  3084            JC      FNDDON          ;Carry=1 if a greater label value found.
0996 12061D     =1  3085            CALL    SKPTXT          ;Skip over remaining text portion of line.
0999 80E6       =1  3086            SJMP    FND_1
                =1  3087    ;
099B 0205B4     =1  3088    FNDDON: JMP     LOAD_PNTR
                =1  3089    ;
                    3090    ;=======
                    3091    ;KILL_L:
                    3092    ;       Kill (delete) line from code buffer indicated by pointer.
                    3093    ;       When called, CURSOR and POINTER hold the address of first LABEL byte of
                    3094    ;       line to be deleted.
                =1  3095    $INCLUDE(AES\KILL_L.ASM)
099E            =1  3096    KILL_L:
                =1  3097    ;       Kill (delete) line from code buffer indicated by pointer.
                =1  3098    ;       When called, CURSOR and POINTER hold the address of first LABEL byte of
                =1  3099    ;       line to be deleted.
                =1  3100    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 54

099E A915       =1  3101            MOV     DEST_L,CURS_L
09A0 AB16       =1  3102            MOV     DEST_H,CURS_H
09A2 120619     =1  3103            CALL    SKPLIN          ;Pass pointer over full text line.
                =1  3104    ;
                =1  3105    ;       Pointer now indicates first label byte of following line.
                =1  3106    ;       Cursor and DEST still indicate first label byte of obsolete line.
                =1  3107    ;
09A5 1205E5     =1  3108    KILL_2: CALL    READ_CHAR       ;Copy down first label byte.
09A8 120607     =1  3109            CALL    WRITE_CHAR      ;Transfer first byte of label number.
09AB 20E711     =1  3110            JB      ACC.7,KILL_9    ;Quit when End of Code sentinel reached.
09AE 1205E5     =1  3111            CALL    READ_CHAR       ;Copy down second label byte.
09B1 120607     =1  3112            CALL    WRITE_CHAR      ;Store second byte of label number.
09B4 1205E5     =1  3113    KILL_3: CALL    READ_CHAR       ;Transfer text character.
09B7 120607     =1  3114            CALL    WRITE_CHAR
09BA B40DF7     =1  3115            CJNE    A,#CR,KILL_3    ;Loop until full line moved.
09BD 80E6       =1  3116            SJMP    KILL_2          ;Continue until all code moved forward.
                =1  3117    ;
09BF 22         =1  3118    KILL_9: RET                     ;Full line now deleted.
                =1  3119    ;
                    3120    ;=======
                    3121    ;OPEN_L:
                    3122    ;       Open space for new line in code buffer starting at Cursor.
                =1  3123    $INCLUDE(AES\OPEN_L.ASM)
09C0            =1  3124    OPEN_L:
                =1  3125    ;       Open space for new line in code buffer starting at Cursor.
                =1  3126    ;
09C0 1205B4     =1  3127            CALL    LOAD_PNTR       ;Load address of point for insertion.
09C3 C259       =1  3128            CLR     CHAR_FLG
09C5 1205E5     =1  3129    OPEN_3: CALL    READ_CHAR       ;Test first label byte of following line.
09C8 20E70B     =1  3130            JB      ACC.7,OPEN_4
09CB 1205E5     =1  3131            CALL    READ_CHAR       ;Pass over next LABEL byte.
09CE 1205E5     =1  3132    OPEN_5: CALL    READ_CHAR
09D1 B40DFA     =1  3133            CJNE    A,#CR,OPEN_5
09D4 80EF       =1  3134            SJMP    OPEN_3
                =1  3135    ;
                =1  3136    ;       Pointer now indicates end-of-buffer sentinel.
                =1  3137    ;
09D6 E512       =1  3138    OPEN_4: MOV     A,STRLEN        ;Number of bytes needed for BASIC text.
09D8 2403       =1  3139            ADD     A,#3            ;Space needed for for label and <CR>.
09DA 28         =1  3140            ADD     A,R0            ;Low-order byte of old pointer.
09DB F9         =1  3141            MOV     DEST_L,A
09DC E4         =1  3142            CLR     A
09DD 3A         =1  3143            ADDC    A,PNTR_H
09DE FB         =1  3144            MOV     DEST_H,A
09DF B47F03     =1  3145            CJNE    A,#HIGH(RAMLIM),OPEN_1
09E2 020FDD     =1  3146            JMP     AES_ER
                =1  3147    ;
                =1  3148    ;       Transfer characters from source back to destination
                =1  3149    ;       until pointer at original CURSOR value.
                =1  3150    ;
09E5 1205C3     =1  3151    OPEN_1: CALL    GET_BUF         ;Move back next character.
09E8 1205F3     =1  3152            CALL    PUT_BUF
09EB E8         =1  3153            MOV     A,PNTR_L
09EC B51505     =1  3154            CJNE    A,CURS_L,OPEN_2
09EF EA         =1  3155            MOV     A,PNTR_H
09F0 B51601     =1  3156            CJNE    A,CURS_H,OPEN_2
                =1  3157    ;
                =1  3158    ;       All bytes have been moved back.
LILBASIC        LilBasic (c)2002                                                                              PAGE 55

                =1  3159    ;
09F3 22         =1  3160            RET
                =1  3161    ;
09F4            =1  3162    OPEN_2:
                =1  3163    ;       Decrement src. and dest. pointers and repeat.
                =1  3164    ;
09F4 18         =1  3165            DEC     PNTR_L
09F5 B8FF01     =1  3166            CJNE    PNTR_L,#0FFH,OPEN_6
09F8 1A         =1  3167            DEC     PNTR_H
09F9 19         =1  3168    OPEN_6: DEC     DEST_L
09FA B9FFE8     =1  3169            CJNE    DEST_L,#0FFH,OPEN_1
09FD 1B         =1  3170            DEC     DEST_H
09FE 80E5       =1  3171            SJMP    OPEN_1          ;Repeat for next character.
                =1  3172    ;
                    3173    ;=======
                    3174    ;INSR_L:
                    3175    ;       Insert program line label (still held in <TOS_H><TOS_L> from earlier
                    3176    ;       call to FNDLBL)
                    3177    ;       and character string in line buffer (pointed at by L_CURS)
                    3178    ;       into program buffer gap created by OPEN_L routine
                    3179    ;       (still pointed at by CURSOR).
                =1  3180    $INCLUDE(AES\INSER_L.ASM)
0A00            =1  3181    INSR_L:
                =1  3182    ;       Insert program line label (still held in <TOS_H><TOS_L> from earlier
                =1  3183    ;       call to FNDLBL)
                =1  3184    ;       and character string in line buffer (pointed at by L_CURS)
                =1  3185    ;       into program buffer gap created by OPEN_L routine
                =1  3186    ;       (still pointed at by CURSOR).
                =1  3187    ;
0A00 A915       =1  3188            MOV     DEST_L,CURS_L
0A02 AB16       =1  3189            MOV     DEST_H,CURS_H
0A04 EF         =1  3190            MOV     A,TOS_H
0A05 120607     =1  3191            CALL    WRITE_CHAR
0A08 EE         =1  3192            MOV     A,TOS_L
0A09 120607     =1  3193            CALL    WRITE_CHAR
0A0C A813       =1  3194            MOV     PNTR_L,L_CURS
                =1  3195 +1         PAGE    #0H             ;ZERO PAGE for AES
0A0E 75A000     =1  3196 +1         MOV     P2,#0H
0A11 E2         =1  3198    INSL_1: MOVX     A,@PNTR_L
0A12 120607     =1  3199            CALL    WRITE_CHAR
0A15 08         =1  3200            INC     PNTR_L
0A16 B40DF8     =1  3201            CJNE    A,#CR,INSL_1
0A19 22         =1  3202            RET
                =1  3203    ;
                    3204    ;=======
                    3205    ;INSRT:
                    3206    ;       Pop line number from top of arithmetic expression stack.
                    3207    ;       Search BASIC source program for corresponding line number.
                    3208    ;       If found, delete old line.
                    3209    ;       Otherwise position cursor before next sequential line number.
                    3210    ;       If line buffer is not empty then insert line number, contents of
                    3211    ;       line buffer, and line terminator.
                =1  3212    $INCLUDE(AES\INSRT.ASM)
0A1A            =1  3213    INSRT:
                =1  3214    ;       Pop line number from top of arithmetic expression stack.
                =1  3215    ;       Search BASIC source program for corresponding line number.
                =1  3216    ;       If found, delete old line.
                =1  3217    ;       Otherwise position cursor before next sequential line number.
LILBASIC        LilBasic (c)2002                                                                              PAGE 56

                =1  3218    ;       If line buffer is not empty then insert line number, contents of
                =1  3219    ;       line buffer, and line terminator.
                =1  3220    ;
0A1A 18         =1  3221            DEC     PNTR_L          ;Since previous D_BLNK passed over first char.
0A1B 8813       =1  3222            MOV     L_CURS,PNTR_L
0A1D 3179       =1  3223            CALL    FNDLBL          ;Check to see if line # in Program
0A1F 4002       =1  3224            JC      INSR_1
0A21 319E       =1  3225            CALL    KILL_L          ;Delete line if label found in buffer.
0A23 A913       =1  3226    INSR_1: MOV     R1,L_CURS
0A25 19         =1  3227            DEC     R1
0A26 09         =1  3228    INSR_2: INC     R1
                =1  3229 +1         PAGE    #0H             ;ZERO PAGE for AES
0A27 75A000     =1  3230 +1         MOV     P2,#0H
0A2A E3         =1  3232            MOVX    A,@R1
0A2B B40DF8     =1  3233            CJNE    A,#CR,INSR_2
0A2E E9         =1  3234            MOV     A,R1
0A2F C3         =1  3235            CLR     C
0A30 9513       =1  3236            SUBB    A,L_CURS
0A32 F512       =1  3237            MOV     STRLEN,A
0A34 6004       =1  3238            JZ      INSR_4
0A36 31C0       =1  3239            CALL    OPEN_L
0A38 5100       =1  3240            CALL    INSR_L
0A3A C253       =1  3241    INSR_4: CLR     RUNMOD
0A3C 22         =1  3242            RET
                =1  3243    ;
                    3244    ;===============
0A3D                3245    COND:
0A3D 1201C1         3246            CALL    POP_TOS
0A40 EE             3247            MOV     A,TOS_L
0A41 13             3248            RRC     A
0A42 22             3249            RET
                    3250    ;
                    3251    ;=======
                    3252    ;XFER
                    3253    ;       Pop the value from the top of the arithmetic expression stack (AES).
                    3254    ;       Position cursor at beginning of the BASIC source program line
                    3255    ;       with that label and begin source interpretation.
                    3256    ;       (Report error if corresponding source line not found.)
                =1  3257    $INCLUDE(AES\XFER.ASM)
                =1  3258    ;XFER
                =1  3259    ;       Pop the value from the top of the arithmetic expression stack (AES).
                =1  3260    ;       Position cursor at beginning of the BASIC source program line
                =1  3261    ;       with that label and begin source interpretation.
                =1  3262    ;       (Report error if corresponding source line not found.)
                =1  3263    ;
                =1  3264    ;
0A43 3179       =1  3265    XFER:   CALL    FNDLBL
0A45 4003       =1  3266            JC      XFERNG
0A47 020AB9     =1  3267            JMP     STMT            ;Begin execution of source line.
                =1  3268    ;
0A4A 020FBD     =1  3269    XFERNG: JMP     EXP_ER
                =1  3270    ;
                    3271    ;===============
                    3272    ;SAV:
                    3273    ;       Push BASIC line number of current source line onto AES.
                =1  3274    $INCLUDE(AES\SAV.ASM)
0A4D            =1  3275    SAV:
                =1  3276    ;       Push BASIC line number of current source line onto AES.
LILBASIC        LilBasic (c)2002                                                                              PAGE 57

                =1  3277    ;
0A4D AF19       =1  3278            MOV     TOS_H,LABL_H
0A4F AE18       =1  3279            MOV     TOS_L,LABL_L
0A51 0201DF     =1  3280            JMP     PUSH_TOS
                =1  3281    ;
                    3282    ;===============
                    3283    ;RSTR:
                    3284    ;       If AES is empty report a nesting error.
                    3285    ;       Otherwise, pop AES into current BASIC souce program line number.
                =1  3286    $INCLUDE(AES\RSTR.ASM)
0A54            =1  3287    RSTR:
                =1  3288    ;       If AES is empty report a nesting error.
                =1  3289    ;       Otherwise, pop AES into current BASIC souce program line number.
                =1  3290    ;
0A54 3179       =1  3291            CALL    FNDLBL
0A56 120619     =1  3292            CALL    SKPLIN          ;Pass over statement initiating transfer.
0A59 020AB9     =1  3293            JMP     STMT
                =1  3294    ;
                    3295    ;=======
                    3296    ;FIN
                    3297    ;       Return to line collection routine.
                    3298    ;
                =1  3299    $INCLUDE(AES\FIN.ASM)
                =1  3300    ;FIN
                =1  3301    ;       Return to line collection routine.
                =1  3302    ;
                =1  3303    ;
0A5C C253       =1  3304    FIN:    CLR     RUNMOD
0A5E 020A83     =1  3305            JMP     CONT            ;Return to line collection mode.
                =1  3306    ;
                    3307    ;======================================================================================
                    3308    ;               IL SEQUENCE CONTROL INSTRUCTIONS:
                    3309    ;======================================================================================;
                    3310    ;MLCALL
                    3311    ;       Call the ML subroutine starting at the address on top of AES.
                    3312    ;
                    3313    ;
                =1  3314    $INCLUDE(AES\MLCALL.ASM)
                =1  3315    ;MLCALL
                =1  3316    ;       Call the ML subroutine starting at the address on top of AES.
                =1  3317    ;
                =1  3318    ;
                =1  3319 +1 MLCALL: PAGE    #0H             ;ZERO PAGE for AES
0A61 75A000     =1  3320 +1         MOV     P2,#0H
0A64 A91D       =1  3322            MOV     R1,AESP
0A66 C5F0       =1  3323            XCH     A,B
0A68 E3         =1  3324            MOVX     A,@R1
0A69 C5F0       =1  3325            XCH     A,B
0A6B 19         =1  3326            DEC     R1
0A6C E3         =1  3327            MOVX     A,@R1
0A6D 19         =1  3328            DEC     R1
0A6E 891D       =1  3329            MOV     AESP,R1
0A70 C0E0       =1  3330            PUSH    ACC
0A72 C0F0       =1  3331            PUSH    B
0A74 43D018     =1  3332            ORL     PSW,#00011000B  ;Select RB3.
                =1  3333 +1         PAGE    #0FFH            ;Move to  User Page!
0A77 75A0FF     =1  3334 +1         MOV     P2,#0FFH
0A7A 22         =1  3336            RET                     ;Branch to user routine.
LILBASIC        LilBasic (c)2002                                                                              PAGE 58

                =1  3337    ;
                    3338    
                    3339    
                    3340    ;===========================================================================================
                                                                               ===============
                    3341    ;       LIL'BASIC STATEMENT EXECUTION
                    3342    
0A7B                3343    START:
                    3344    
0A7B                3345    ERRENT:
0A7B C253           3346            CLR     RUNMOD
0A7D 75812B         3347            MOV     SP,#SP_BASE             ;Re-initialize hardware stack.
0A80 751D00         3348            MOV     AESP,#00H               ;Initialize AES pointer.
0A83                3349    CONT:
0A83 205231         3350            JB      XAUTO, XEC              ;If in Auto or Xauto run mode,
0A86 10512E         3351            JBC     AUTO, XEC               ;Do not allow for command line input!
0A89 12018B         3352            CALL    STROUT
0A8C 0D576861       3353            DB      CR,'What next boss?   ',(CR OR 80H)
0A90 74206E65   
0A94 78742062   
0A98 6F73733F   
0A9C 2020208D   
0AA0 751800         3354            MOV     LABL_L,#0H              ;
0AA3 751900         3355            MOV     LABL_H,#0H
0AA6                3356    CONT_1:
0AA6 112F           3357            CALL    GETLN                   ;Receive interactive command line.
0AA8 12060F         3358            CALL    D_BLNK
0AAB 1207B7         3359            CALL    TSTN
0AAE 500D           3360            JNC     TOKEN
0AB0 511A           3361            CALL    INSRT
0AB2 80F2           3362            JMP    CONT_1
                    3363    ;
                    3364    
                    3365    ;
0AB4 1207F1         3366    ARUN:   CALL    LNDONE                  ;Clear pointer to end of line
0AB7 3170           3367    XEC:    CALL    XINIT                   ;Initialize for sequential execution.
                    3368 +1 STMT:   LINIT_                          ;Initialize for line execution.
0AB9 1119           3369 +1         CALL   L_INIT
0ABB 40BE           3370 +1         JC      ERRENT
0ABD 120147         3372    TOKEN:  CALL    CNTRL
                    3373    
0AC0 12060F         3374            CALL    D_BLNK                  ;Remove leading blanks from BASIC source line, updat
                                                                               e cursor,
                    3375                                            ;load first non-blank character into CHAR, and leave
                                                                                pointer
                    3376                                            ;loaded with its address.
                    3377    
                    3378 +1         TSTV_   BASCMD                  ;Test if first non-blank string is a legal variable 
                                                                               symbol.
0AC3 120654         3379 +1         CALL    TSTV
0AC6 5014           3380 +1         JNC     BASCMD
                    3382                                            ;If not, Jump to process BASic CoMmanDs
                    3383    
                    3384                                            ;If so, move cursor over string and any trailing bla
                                                                               nks,
                    3385                                            ;compute variable index value, push onto arithmetic 
                                                                               expression
                    3386                                            ;stack, and continue with following IL instruction.
LILBASIC        LilBasic (c)2002                                                                              PAGE 59

                                                                               
                    3387                                            ;Otherwise branch to IL instruction at LBL with curs
                                                                               or unaffected.
                    3388    
                =1  3389    $INCLUDE(AES\CMDS\IMPLIED.ASM)              ;Execute Implied commands
                =1  3390    
0AC8            =1  3391     IMPLST:                               ;Implied LET Basic Command
                =1  3392    
0AC8 120623     =1  3393            call   tst                      ;Test for 'var=' command
0ACB BD         =1  3394            db      ('=' OR 80H)
0ACC 500E       =1  3395            jnc     IMPLEXT                  ;If no '=' in CMD line, then Exit
                =1  3396    
                =1  3397 +1         ICALL_  EXPR                    ;Push Expression into AES
0ACE 12102A     =1  3398 +1         CALL    EXPR
                =1  3400    
                =1  3401    ;        call   tst
                =1  3402    ;        db      (',' OR 80H)           ;Removed implied command A=1,2,3,4
                =1  3403    ;        jnc     se3a                   ;                        (A=1, B=2, C=3, ...ETC)
                =1  3404    ;        CALL    SEQ_STORE
                =1  3405    ;        CALL    IINC
                =1  3406    ;        HOP_    SE3
                =1  3407    
0AD1 1207EB     =1  3408            CALL    DONE                    ;Clear pointer to next Command
0AD4 1202DA     =1  3409            CALL    STORE                   ;Store result of AES into Variable
0AD7 0123       =1  3410            JMP     NXT                     ;Process next command
                =1  3411    
0AD9 020FF4     =1  3412    CMD_NG: JMP     SYN_ER                  ;Invalid Implied Command; Jump To Syntax Error
                =1  3413    
0ADC            =1  3414    IMPLEXT:
                    3415    ;-----
0ADC                3416    BASCMD:                                 ;Process Basic Token Commands.
                =1  3417    $INCLUDE(AES\CMDS\LET.ASM)
                =1  3418    
                =1  3419    
0ADC            =1  3420    STLET:                                  ;Parse explicit LET command.
0ADC 120623     =1  3421            call   tst                      ;Test if 'LET' Command
0ADF 4C45D4     =1  3422            db      'LE',('T' OR 80H)
0AE2 5013       =1  3423            jnc     ENDLET                  ;if not 'LET' command process next command
                =1  3424    
                =1  3425 +1         TSTV_   CMD_NG                  ;Test for 'var='
0AE4 120654     =1  3426 +1         CALL    TSTV
0AE7 50F0       =1  3427 +1         JNC     CMD_NG
0AE9 BD         =1  3429            db      ('=' OR 80H)
0AEA 50ED       =1  3430            jnc     cmd_ng                  ;If not exizts branch to jump to Syntax Error
                =1  3431 +1         ICALL_  EXPR                    ;Push expressions into AES
0AEC 12102A     =1  3432 +1         CALL    EXPR
0AEF 1207EB     =1  3434            CALL    DONE                    ;Move IL pointer past rest of command
0AF2 1202DA     =1  3435            CALL    STORE                   ;Put Value into Variable
                =1  3436                                            ;       When STORE is called, AES contains
                =1  3437                                            ;       (TOS:)  2 byte VALUE to be stored,
                =1  3438                                            ;               2 byte INDEX of destination variable
                                                                               ,
                =1  3439                                            ;               1 byte TYPE code for variable space.
                                                                               
                =1  3440                                            ;                       (0=BASIC variable,
                =1  3441                                            ;                        1=DBYTE,
                =1  3442                                            ;                        2=RBIT,
                =1  3443                                            ;                        3=XBYTE,
LILBASIC        LilBasic (c)2002                                                                              PAGE 60

                =1  3444                                            ;                        4=CBYTE.)
                =1  3445                                            ;       Store (VAR_1) into appropriate variable memo
                                                                               ry at location of (INDEX).
                =1  3446    
0AF5 0123       =1  3447            JMP     NXT                     ;Process next Command
                =1  3448    
0AF7            =1  3449    ENDLET:
                =1  3450    $INCLUDE(AES\CMDS\GO.ASM)
0AF7            =1  3451    GO_ST:
0AF7 120623     =1  3452            CALL    TST                     ;See if 'GO' command
0AFA 47CF       =1  3453            DB      'G',('O' OR 80H)
0AFC 501F       =1  3454            JNC     GO_END                  ;If not Try next command
0AFE            =1  3455    GOSUB_ST:
0AFE 120623     =1  3456            call   tst                      ;Test For 'GO SUB' Command
0B01 5355C2     =1  3457            db      'SU',('B' OR 80H)
0B04 5005       =1  3458            jnc     GOTO_ST                 ;If Not 'GO SUB' Then try 'GO TO'
0B06 514D       =1  3459            CALL    SAV                     ;Push return addr onto AES stack
0B08 020B12     =1  3460            JMP     GO_COMMON
0B0B            =1  3461    GOTO_ST:
0B0B 120623     =1  3462            call   tst                      ;Test for 'GO TO' command
0B0E 54CF       =1  3463            db      'T',('O' OR 80H)
0B10 5008       =1  3464            jnc     GO_ERR                  ;If Not Must be a syntax Error
                =1  3465    
0B12            =1  3466    GO_COMMON:
                =1  3467 +1         ICALL_  EXPR                    ;Load expression into AES
0B12 12102A     =1  3468 +1         CALL    EXPR
0B15 1207F1     =1  3470            CALL    LNDONE                  ;Move Command Pointer to end of line
                =1  3471    
0B18 4143       =1  3472            JMP     XFER                    ;Pop the value from the top of the arithmetic expres
                                                                               sion stack (AES).
                =1  3473                                            ;Position cursor at beginning of the BASIC source pr
                                                                               ogram line
                =1  3474                                            ;with that label and begin source interpretation.
                =1  3475                                            ;(Report error if corresponding source line not foun
                                                                               d.)
0B1A            =1  3476    GO_ERR:
0B1A 020FF4     =1  3477            JMP     SYN_ER
                =1  3478    
                =1  3479    
                =1  3480    
0B1D            =1  3481    GO_END:
                =1  3482    
                =1  3483    
                =1  3484    ;
                =1  3485    $INCLUDE(AES\CMDS\PRINT.ASM)
0B1D            =1  3486    PRINT_START:
0B1D 120623     =1  3487            call   tst                      ;Test for 'PRINT' TOKEN
0B20 5052494E   =1  3488            db      'PRIN',('T' OR 80H)
0B24 D4         
0B25 4008       =1  3489            JC      PRINT_LOOP              ;if so, then goto print command
                =1  3490    
0B27 120623     =1  3491            call   tst                      ;Test for '?' TOKEN (PRINT)
0B2A BF         =1  3492            db      ('?' OR 80H)
0B2B 4002       =1  3493            JC      PRINT_LOOP              ;if so, then goto print command
                =1  3494 +1         HOP_    PRINT_EXIT               ;If not, try next Command.
0B2D 8030       =1  3495 +1         SJMP    PRINT_EXIT
                =1  3497    
0B2F            =1  3498    PRINT_LOOP:                              ;Process PRINT Command
LILBASIC        LilBasic (c)2002                                                                              PAGE 61

                =1  3499    
                =1  3500 +1         IFDONE_  PRINT_END              ;If empty print statment, EXIT
0B2F 1207FC     =1  3501 +1         CALL    IFDONE
0B32 5027       =1  3502 +1         JNC     PRINT_END
                =1  3504    
0B34 120623     =1  3505            call   tst                      ;if PRINT starts with a ';' Skip over it
0B37 BB         =1  3506            db      (';' OR 80H)
0B38 401A       =1  3507            jc     PRINT_CHECK_SEMI
                =1  3508    
0B3A 120623     =1  3509            call   tst
0B3D AC         =1  3510            db      (',' OR 80H)            ;If PRINT starts with a ','
0B3E 4011       =1  3511            jc     PRINT_COMMA              ;Space out tab fields
                =1  3512    
                =1  3513 +1         IFDONE_ PRINT_EXIT              ;If end of PRINT cmd, goto PRINT EXIT
0B40 1207FC     =1  3514 +1         CALL    IFDONE
0B43 501A       =1  3515 +1         JNC     PRINT_EXIT
                =1  3517 +1         TSTS_   PRINT_LOOP              ;Output LITERAL string ("") if Exists and continue P
                                                                               RINT_LOOP
0B45 1207CC     =1  3518 +1         CALL    TSTS
0B48 40E5       =1  3519 +1         JC      PRINT_LOOP
                =1  3521                                            ;Else
                =1  3522 +1         ICALL_  EXPR                    ;Push Expression onto AES stack
0B4A 12102A     =1  3523 +1         CALL    EXPR
0B4D 1195       =1  3525            CALL    PRN                     ;Print It
                =1  3526 +1         HOP_    PRINT_LOOP              ;Continue Print Loop
0B4F 80DE       =1  3527 +1         SJMP    PRINT_LOOP
                =1  3529    ;-------------------------
0B51            =1  3530    PRINT_COMMA:
0B51 120155     =1  3531    CALL    SPC                             ;output sapces, Continue with Print Command
                =1  3532                                            ;Check to see if last command in print Loop (same as
                                                                                ';')
0B54            =1  3533    PRINT_CHECK_SEMI:
                =1  3534 +1         IFDONE_  PRINT_SEMI              ;If ';' or ',' is last character in print loop, the
                                                                               n exit w/o NewLine
0B54 1207FC     =1  3535 +1         CALL    IFDONE
0B57 5004       =1  3536 +1         JNC     PRINT_SEMI
                =1  3538 +1         HOP_    PRINT_LOOP              ;Else Continue Loop
0B59 80D4       =1  3539 +1         SJMP    PRINT_LOOP
                =1  3541    ;-------------------------
0B5B            =1  3542    PRINT_END:
0B5B 0120       =1  3543           JMP      NL_NXT                   ;Send NewLine and exit.
                =1  3544    
0B5D            =1  3545    PRINT_SEMI:
0B5D 0123       =1  3546           JMP      NXT                      ;Exit Without NewLine
                =1  3547    
0B5F            =1  3548    PRINT_EXIT:                             ;Continue with checking next Command
                =1  3549    ;
                =1  3550    $INCLUDE(AES\CMDS\IFTHEN.ASM)
0B5F            =1  3551    IFST:
0B5F 120623     =1  3552    s8:     call   tst
0B62 49C6       =1  3553            db      'I',('F' OR 80H)        ;Check for 'IF' Command
0B64 5017       =1  3554            jnc     IFEXIT                  ;If not check next command
                =1  3555 +1         ICALL_  EXPR                    ;Push expressionon on AES stack
0B66 12102A     =1  3556 +1         CALL    EXPR
0B69 120623     =1  3558            call   tst
0B6C 544845CE   =1  3559            db      'THE',('N' OR 80H)      ;Check for 'THEN' command
0B70 5000       =1  3560            jnc     IF_TF                     ; NEEDS changed to jnc ERROR
                =1  3561    
LILBASIC        LilBasic (c)2002                                                                              PAGE 62

0B72            =1  3562    IF_TF:
                =1  3563 +1         COND_   IF_FALSE
0B72 513D       =1  3564 +1         CALL   COND
0B74 5002       =1  3565 +1         JNC    IF_FALSE
                =1  3567 +1         IJMP_   TOKEN                   ;If True Continue parsing command.
0B76 41BD       =1  3568 +1         JMP     TOKEN
                =1  3570    
0B78            =1  3571    IF_FALSE:
0B78 12061D     =1  3572            CALL    SKPTXT                  ;If False Skip rest of line
                =1  3573 +1         IJMP_   STMT
0B7B 41B9       =1  3574 +1         JMP     STMT
                =1  3576    
0B7D            =1  3577    IFEXIT:
                =1  3578    $INCLUDE(AES\CMDS\INPUT.ASM)
0B7D            =1  3579    INPUTST:
0B7D 120623     =1  3580            call   tst
0B80 494E5055   =1  3581            db      'INPU',('T' OR 80H)     ;Check if Input Command
0B84 D4         
0B85 5028       =1  3582            jnc     INPEXIT                 ;If not exit
0B87            =1  3583    INPUT_LOOP:
                =1  3584 +1         TSTS_   INPUT_SEMI              ;If Followed by String Literal Print it,
0B87 1207CC     =1  3585 +1         CALL    TSTS
0B8A 400A       =1  3586 +1         JC      INPUT_SEMI
                =1  3588                                            ;and Check if followed by semi or comma.
                =1  3589 +1         TSTV_   INPUT_ERR               ;If not followed by variable exit with error
0B8C 120654     =1  3590 +1         CALL    TSTV
0B8F 5016       =1  3591 +1         JNC     INPUT_ERR
0B91 3114       =1  3593            CALL    INNUM                   ;Get value from 232port
0B93 1202DA     =1  3594            CALL    STORE                   ;Put value into var
                =1  3595                                            ;Need to check here to verify we are done.
0B96            =1  3596    INPUT_SEMI:
0B96 120623     =1  3597            call   tst                      ;If next char is a ';'
0B99 BB         =1  3598            db      (';' OR 80H)
0B9A 40EB       =1  3599            jc     INPUT_LOOP               ;Continue with input command
                =1  3600                                            ;Else Check if it is a comma
                =1  3601    
0B9C            =1  3602    INPUT_COMMA:
0B9C 120623     =1  3603            call   tst                      ;If next char is not a','
0B9F AC         =1  3604            db      (',' OR 80H)
0BA0 5008       =1  3605            jnc     INPUT_END               ;Then must be end of command, so exit
0BA2 120155     =1  3606            CALL    SPC                     ;Else Space out tabfield
                =1  3607 +1         HOP_    INPUT_LOOP              ;continue input command
0BA5 80E0       =1  3608 +1         SJMP    INPUT_LOOP
                =1  3610    ;
0BA7            =1  3611    INPUT_ERR:
                =1  3612 +1        IJMP_   SYN_NG                  ;Jump to Syntax Error
0BA7 02111A     =1  3613 +1         JMP     SYN_NG
                =1  3615    ;
0BAA            =1  3616    INPUT_END:
0BAA 1207EB     =1  3617            CALL    DONE
0BAD 0120       =1  3618            JMP     NL_NXT
                =1  3619    ;
0BAF            =1  3620    INPEXIT:
                =1  3621    $INCLUDE(AES\CMDS\RETURN.ASM)
0BAF            =1  3622    RETURN_START:
0BAF 120623     =1  3623            call   tst                      ;If Not 'RETURN' command
0BB2 52455455   =1  3624            db      'RETUR',('N' OR 80H)
0BB6 52CE       
LILBASIC        LilBasic (c)2002                                                                              PAGE 63

0BB8 5005       =1  3625            jnc     RETURN_END              ;Then try next command
0BBA 1207F1     =1  3626            CALL    LNDONE                  ;Else through with this line.
0BBD 4154       =1  3627            JMP     RSTR                    ;Pop of of AES new LINE #
0BBF            =1  3628    RETURN_END:
                =1  3629    $INCLUDE(AES\CMDS\CALL.ASM)  ; call machine subroutine
0BBF            =1  3630    CALL_START:
0BBF 120623     =1  3631            call   tst
0BC2 43414CCC   =1  3632            db      'CAL',('L' OR 80H)      ;Check if 'CALL' command
0BC6 500D       =1  3633            jnc     CALL_END                ;If not try next command
                =1  3634 +1         ICALL_  EXPR                    ;Else push Expresson on AES
0BC8 12102A     =1  3635 +1         CALL    EXPR
0BCB 1207F1     =1  3637            CALL    LNDONE                  ;move pointer to end of stmt
                =1  3638 +1         MLCALL_                         ;Gosub Machine Lang. Subrutine.
0BCE 5161       =1  3639 +1         CALL    MLCALL
0BD0 53D0E7     =1  3640 +1         ANL     PSW,#11100111B
0BD3 0123       =1  3642            JMP     NXT                     ;Execute next command
0BD5            =1  3643    CALL_END:
                =1  3644    $INCLUDE(AES\CMDS\END.ASM)   ; end program
0BD5            =1  3645    END_START:
0BD5 120623     =1  3646            call   tst                      ;Check to see if next token is 'END'
0BD8 454EC4     =1  3647            db      'EN',('D' OR 80H)
0BDB 5005       =1  3648            jnc     END_END                 ;If not try next command
0BDD 1207F1     =1  3649            CALL    LNDONE                  ;Clear pointer to end of line
0BE0 415C       =1  3650            JMP     FIN                     ;End Program
0BE2            =1  3651    END_END:
                =1  3652    $INCLUDE(AES\CMDS\LIST.ASM)   ; list program
0BE2            =1  3653    LISTSTART:
0BE2 120623     =1  3654            call   tst
0BE5 4C4953D4   =1  3655            db      'LIS',('T' OR 80H)              ;Check to see if 'LIST' Commans
0BE9 5012       =1  3656            jnc     LISTEND                         ;If not, then check next command
                =1  3657 +1         IFDONE_ FULLLIST                        ;If nothing after 'LIST' command then list w
                                                                               hole program
0BEB 1207FC     =1  3658 +1         CALL    IFDONE
0BEE 5009       =1  3659 +1         JNC     FULLLIST
                =1  3661 +1         ICALL_  EXPR                            ;Else get line no.
0BF0 12102A     =1  3662 +1         CALL    EXPR
0BF3 3179       =1  3664            CALL    FNDLBL                          ;Find line in code
0BF5 3108       =1  3665            CALL    LST_1                           ;Display it
                =1  3666 +1         IJMP_   CONT                            ;exit
0BF7 4183       =1  3667 +1         JMP     CONT
                =1  3669    ;
0BF9            =1  3670    FULLLIST:
0BF9 3103       =1  3671            CALL    LST                             ;Gosub list whole program
                =1  3672 +1         IJMP_   CONT                            ;exit
0BFB 4183       =1  3673 +1         JMP     CONT
0BFD            =1  3675    LISTEND:
                =1  3676    $INCLUDE(AES\CMDS\RUN.ASM)   ; run program
0BFD            =1  3677    RUNSTART:
0BFD 120623     =1  3678            call   tst                      ;Check to see if it is 'RUN'command
0C00 5255CE     =1  3679            db      'RU',('N' OR 80H)
0C03 5002       =1  3680            jnc     RUNEND                  ;If not, check next command
0C05 41B4       =1  3681            JMP     ARUN                   ;Else clear pointer to end of line and run program
0C07            =1  3682    RUNEND:
                =1  3683    $INCLUDE(AES\CMDS\NEW.ASM)   ; clear out program
0C07            =1  3684    NEWSTART:
0C07 120623     =1  3685            call   tst                      ;Check to see if 'NEW' command
0C0A 4E45D7     =1  3686            db      'NE',('W' OR 80H)
0C0D 500E       =1  3687            jnc     NEWEND                  ;If not, try next command
LILBASIC        LilBasic (c)2002                                                                              PAGE 64

0C0F 1207EB     =1  3688            CALL    DONE                    ;Clear pointer to end of line
0C12 758200     =1  3689            MOV     DPL,#LOW(EXTRAM)        ;Move DPTR to beginning of program
0C15 758320     =1  3690            MOV     DPH,#HIGH(EXTRAM)
0C18 74FF       =1  3691            MOV     A,#0FFH                 ;Token for end of basic program
0C1A F0         =1  3692            MOVX    @DPTR,A                 ;Put END token at start of program
                =1  3693    
                =1  3694 +1         IJMP_   START                   ;Start at beginning
0C1B 417B       =1  3695 +1         JMP     START
0C1D            =1  3697    NEWEND:
                =1  3698    $INCLUDE(AES\CMDS\BREAK.ASM)  ; simulate reset
0C1D            =1  3699    BREAK_START:
0C1D 120623     =1  3700            call   tst                      ;Check if 'BREAK' command
0C20 42524541   =1  3701            db      'BREA',('K' OR 80H)
0C24 CB         
0C25 5006       =1  3702            jnc     BREAK_END               ;If not check next command
0C27 1207EB     =1  3703            CALL    DONE                    ;Clear pointer
0C2A 020000     =1  3704            JMP     0000H                   ;Reset CPU
0C2D            =1  3705    BREAK_END:
                =1  3706    $INCLUDE(AES\CMDS\PROG.ASM)
0C2D            =1  3707    FILE_START:
                =1  3708    
0C2D 120623     =1  3709            call tst                        ;Check to see if 'FILE' command
0C30 50524FC7   =1  3710            DB      'PRO',('G'or 80H)
0C34 5036       =1  3711            JNC     FILE_END                ;If not, try next command
                =1  3712    ;----
0C36            =1  3713    ROM_PROGRAM:                            ; ROM
0C36 120623     =1  3714            call tst                        ;Check to see if 'ROM' command
0C39 44454DCF   =1  3715            DB     'DEM',('O'or 80H)
0C3D 5009       =1  3716            JNC     TEST_PROGRAM
0C3F 1207EB     =1  3717            CALL    DONE
0C42 D251       =1  3718            SETB    AUTO
0C44 D252       =1  3719            SETB    XAUTO
0C46 0123       =1  3720            JMP     NXT
                =1  3721    
                =1  3722    ;----
0C48            =1  3723    TEST_PROGRAM:
0C48 120623     =1  3724            call tst                        ;Check to see if 'TEST' command
0C4B 415554CF   =1  3725            DB     'AUT',('O'or 80H)
0C4F 5009       =1  3726            JNC     RAM_PROGRAM
0C51 1207EB     =1  3727            CALL    DONE                    ;clear pointer.
0C54 D251       =1  3728            SETB    AUTO                  ;Set PROGRAM MODE
0C56 C252       =1  3729            CLR     XAUTO
0C58 0123       =1  3730            JMP     NXT                     ;Execute next line of code (if any)
                =1  3731    
                =1  3732    ;----
0C5A            =1  3733    RAM_PROGRAM:
0C5A 120623     =1  3734            call tst                        ;Check to see if 'RAM' command
0C5D 5241CD     =1  3735            DB     'RA',('M'or 80H)
0C60 5007       =1  3736            JNC    FILE_ERROR
0C62 1207EB     =1  3737            CALL    DONE                    ;clear pointers
0C65 C251       =1  3738            CLR     AUTO                    ;Set Program Mode to RAM, no auto run
0C67 0123       =1  3739            JMP     NXT                     ;Execute any further code if present.
                =1  3740    
                =1  3741    ;----
0C69            =1  3742    FILE_ERROR:
0C69 020FBD     =1  3743             JMP     EXP_ER
                =1  3744    ;----
0C6C            =1  3745    FILE_END:
LILBASIC        LilBasic (c)2002                                                                              PAGE 65

                =1  3746    $INCLUDE(AES\CMDS\HEXDECI.ASM) ; set oytput mode decimal or Hex
0C6C            =1  3747    HEXDECIMAL:
0C6C 120623     =1  3748             call   tst                     ;Check if 'HEX' command
0C6F 4845D8     =1  3749            db      'HE',('X' OR 80H)
0C72 5007       =1  3750            jnc     DECIMAL                 ;If not, goto DECIMAL
0C74 1207EB     =1  3751            CALL    DONE                    ;Else ignore rest of line
0C77 D254       =1  3752            SETB    HEXMOD                  ;Set Output mode to HEX
0C79 0123       =1  3753            JMP     NXT                     ;continue with next line
                =1  3754    
0C7B            =1  3755    DECIMAL:
0C7B 120623     =1  3756            call   tst                      ;Check if 'DEC' command
0C7E 4445C3     =1  3757            db      'DE',('C' OR 80H)
0C81 5007       =1  3758            jnc     HEXDEC_END              ;If not, try next command
0C83 1207EB     =1  3759            CALL    DONE                    ;Else ignore rest of line
0C86 C254       =1  3760            CLR     HEXMOD                  ;Set Output to Decimal
0C88 0123       =1  3761            JMP     NXT                     ;Continue execution with next command
0C8A            =1  3762    HEXDEC_END:
                =1  3763    $INCLUDE(AES\CMDS\REMARK.ASM); remark stmt
0C8A            =1  3764    REMARK_START:
0C8A 120623     =1  3765            call   tst                      ;Check to see if 'REM' command
0C8D 5245CD     =1  3766            db      'RE',('M' OR 80H)
0C90 5010       =1  3767            jnc     REMARK_END              ;If not try short version
0C92 12061D     =1  3768            CALL    SKPTXT                  ;Skip over rest of line.
                =1  3769 +1         IJMP_   STMT                    ;Execute neext stmt
0C95 41B9       =1  3770 +1         JMP     STMT
0C97            =1  3772    APOSTRO:
0C97 120623     =1  3773            call   tst                      ;Check to see if (') command
0C9A A7         =1  3774            db      (''''OR 80H)            ;(')
0C9B 5005       =1  3775            jnc     REMARK_END              ;If not try Next command
0C9D 12061D     =1  3776            CALL    SKPTXT                  ;Skip over rest of line
                =1  3777 +1         IJMP_   STMT                    ;Execute next stmt
0CA0 41B9       =1  3778 +1         JMP     STMT
                =1  3780    
0CA2            =1  3781    REMARK_END:
                =1  3782    $INCLUDE(AES\CMDS\CLS.ASM)   ; send clear screen command
0CA2            =1  3783    CLS_START:
                =1  3784    
0CA2 120623     =1  3785            call tst                        ;Check to see if 'FILE' command
0CA5 434CD3     =1  3786            DB      'CL',('S'or 80H)
0CA8 500D       =1  3787            JNC     CLS_END                ;If not, try next command
0CAA 12018B     =1  3788            CALL    STROUT                 ;Send String Below
0CAD 1B5B324A   =1  3789            DB      ESC,'[2J',80H          ;Ansi Escape code for Clear Screan
0CB1 80         
0CB2 1207EB     =1  3790            CALL    DONE                   ;Get ready for next command
0CB5 0123       =1  3791            JMP     NXT                    ;Execute next command
0CB7            =1  3792    CLS_END:
                =1  3793    $INCLUDE(AES\CMDS\HELP.ASM)  ; display help file
0CB7            =1  3794    HELP_START:
                =1  3795    
                =1  3796    
0CB7            =1  3797    HELP_1:
0CB7 120623     =1  3798            CALL    TST                        ;Check to see if 'HELP' command
0CBA 48454CD0   =1  3799            DB      'HEL',('P'or 80H)
0CBE 505A       =1  3800            JNC     HELP_END                ;If not help command, try next command
                =1  3801    
0CC0 120623     =1  3802            CALL    TST                     ;Check to see if 'Help CMDS' command
0CC3 434D44D3   =1  3803            DB      'CMD',('S'or 80H)
0CC7 500B       =1  3804            JNC     HELP_2                  ;If not, try next command
LILBASIC        LilBasic (c)2002                                                                              PAGE 66

0CC9 9013BC     =1  3805            MOV     DPTR,#HELPTEXTCMD       ;Set pointer to Help text commands
0CCC 12019D     =1  3806            CALL    STROUT2                 ;Output Help Text
0CCF 1207EB     =1  3807            CALL    DONE                    ;Get ready for next command
0CD2 0123       =1  3808            JMP     NXT                     ;Execute next command
                =1  3809    
0CD4            =1  3810    HELP_2:
0CD4 120623     =1  3811            call tst                        ;Check to see if 'HELP FUNC' command
0CD7 46554EC3   =1  3812            DB      'FUN',('C'or 80H)
0CDB 500B       =1  3813            JNC     HELP_3                  ;If not, try next command
0CDD 901849     =1  3814            MOV     DPTR,#HELPTEXTFUNC      ;Set pointer to Help text functions
0CE0 12019D     =1  3815            CALL    STROUT2                 ;Output Help Text
0CE3 1207EB     =1  3816            CALL    DONE                    ;Get ready for next command
0CE6 0123       =1  3817            JMP     NXT                     ;Execute next command
                =1  3818    
0CE8            =1  3819    HELP_3:
0CE8 120623     =1  3820            call tst                        ;Check to see if 'HELP OPER' command
0CEB 4F5045D2   =1  3821            DB      'OPE',('R'or 80H)
0CEF 500B       =1  3822            JNC     HELP_4                  ;If not, try next command
0CF1 901947     =1  3823            MOV     DPTR,#HELPTEXTOPER      ;Set pointer to Help text operators
0CF4 12019D     =1  3824            CALL    STROUT2                 ;Output Help Text
0CF7 1207EB     =1  3825            CALL    DONE                    ;Get ready for next command
0CFA 0123       =1  3826            JMP     NXT                     ;Execute next command
                =1  3827    
0CFC            =1  3828    HELP_4:
0CFC 120623     =1  3829            call tst                        ;Check to see if 'VARS' command
0CFF 5641D2     =1  3830            DB      'VA',('R'or 80H)
0D02 500B       =1  3831            JNC     HELP_0                  ;If not, try next command
0D04 901C58     =1  3832            MOV     DPTR,#HELPTEXTVARS      ;Set pointer to Help text operators
0D07 12019D     =1  3833            CALL    STROUT2                 ;Output Help Text
0D0A 1207EB     =1  3834            CALL    DONE                    ;Get ready for next command
0D0D 0123       =1  3835            JMP     NXT                     ;Execute next command
                =1  3836    
                =1  3837    
0D0F            =1  3838    HELP_0:                                 ; Not 1, 2, or 3. So send help on help
0D0F 90127B     =1  3839            MOV     DPTR,#HELPTEXT         ;Set pointer to Help text part 1
0D12 12019D     =1  3840            CALL    STROUT2                 ;Output Help Text
0D15 1207EB     =1  3841                    CALL    DONE                    ;Get ready for next command
0D18 0123       =1  3842            JMP     NXT                     ;Execute next command
                =1  3843    
                =1  3844    
                =1  3845    
0D1A            =1  3846    HELP_END:
                =1  3847    $INCLUDE(AES\CMDS\VER.ASM)   ; display version
0D1A            =1  3848    VER_ST:
0D1A 120623     =1  3849            call tst                        ;Check to see if 'VER' command
0D1D 5645D2     =1  3850            DB      'VE',('R'or 80H)
0D20 5067       =1  3851            JNC     VER_END                 ;If not, try next command
0D22 120D2A     =1  3852            CALL    VER_MSG                 ;Send Version
0D25 1207EB     =1  3853            CALL    DONE                    ;Get ready for next command
0D28 0123       =1  3854            JMP     NXT                     ;Execute next command
                =1  3855    
0D2A            =1  3856    VER_MSG:
0D2A 12018B     =1  3857            CALL    STROUT
0D2D 1B5B324A   =1  3858            DB      ESC,'[2J',80H    ;CLS
0D31 80         
0D32 12018B     =1  3859            CALL    STROUT
0D35 20204C69   =1  3860            DB      '  Lil''Basic ver ',('0'+VERS/10H),'.',('0'+(VERS AND 0FH)),(CR OR 80H)
0D39 6C274261   
LILBASIC        LilBasic (c)2002                                                                              PAGE 67

0D3D 73696320   
0D41 76657220   
0D45 332E308D   
0D49 12018B     =1  3861            CALL    STROUT
0D4C 28632931   =1  3862            DB      '(c)13/JAN/2002    -NQR',CR,(CR OR 80H)
0D50 332F4A41   
0D54 4E2F3230   
0D58 30322020   
0D5C 20202D4E   
0D60 51520D8D   
0D64 12018B     =1  3863            CALL    STROUT
0D67 54797065   =1  3864            DB      'Type HELP for more information.',CR,(CR OR 80H)
0D6B 2048454C   
0D6F 5020666F   
0D73 72206D6F   
0D77 72652069   
0D7B 6E666F72   
0D7F 6D617469   
0D83 6F6E2E0D   
0D87 8D         
0D88 22         =1  3865            RET
                =1  3866    
0D89            =1  3867    VER_END:
                =1  3868    $INCLUDE(AES\CMDS\FILES.ASM) ; display program saved
0D89            =1  3869    FILES_START:
                =1  3870    
0D89 120623     =1  3871            call tst                        ;Check to see if 'FILE' command
0D8C 46494C45   =1  3872            DB      'FILE',('S'or 80H)
0D90 D3         
0D91 5078       =1  3873            JNC     FILES_END               ;If not, try next command
0D93 12018B     =1  3874            CALL    STROUT                 ;Send String Below
0D96 0D0D2046   =1  3875            DB      CR,CR,' Files in memory ',CR,'=================',CR,80H
0D9A 696C6573   
0D9E 20696E20   
0DA2 6D656D6F   
0DA6 7279200D   
0DAA 3D3D3D3D   
0DAE 3D3D3D3D   
0DB2 3D3D3D3D   
0DB6 3D3D3D3D   
0DBA 3D0D80     
0DBD 9020EC     =1  3876            MOV     DPTR,#START_OF_PROGRAMS ;Initilize DATA pointer
                =1  3877    
0DC0            =1  3878     FILES_LOOK:
0DC0 121164     =1  3879            CALL    FIND_NEXT_TAG           ;Look for next TAG
0DC3 502A       =1  3880            JNC     FILES_EXIT              ;If end found, then end
0DC5 7400       =1  3881            MOV     A,#0H                   ;Clear A
0DC7 93         =1  3882            MOVC    A,@A+DPTR               ;Get File type
0DC8 F509       =1  3883            MOV     TMP1,A                  ;Save File type
0DCA A3         =1  3884            INC     DPTR                    ;Step over file type
0DCB 7420       =1  3885            MOV     A,#SPACE                 ;Load A with a space
0DCD 12012A     =1  3886            CALL    C_OUT                   ;Send 2 spaces
0DD0 12019D     =1  3887            CALL    STROUT2                 ;Output file name
0DD3 7420       =1  3888            MOV     A,#SPACE                 ;Load A with a space
0DD5 12012A     =1  3889            CALL    C_OUT                   ;Send 2 spaces
0DD8 12012A     =1  3890            CALL    C_OUT
0DDB 7428       =1  3891            MOV     A,#'('                  ;
0DDD 12012A     =1  3892            CALL    C_OUT
LILBASIC        LilBasic (c)2002                                                                              PAGE 68

0DE0 E509       =1  3893            MOV     A,TMP1                  ;Move FILE TYPE into A
0DE2 12012A     =1  3894            CALL    C_OUT                   ;Send File Type to display
0DE5 7429       =1  3895            MOV     A,#')'                  ;
0DE7 12012A     =1  3896            CALL    C_OUT
                =1  3897    
0DEA 120128     =1  3898            CALL    NLINE                   ;Send Line feed
0DED 80D1       =1  3899            SJMP    FILES_LOOK              ;Look for next file in memory
                =1  3900    
                =1  3901    
                =1  3902    
                =1  3903    
0DEF            =1  3904     FILES_EXIT:
0DEF 12018B     =1  3905            CALL    STROUT                 ;Send String Below
0DF2 3D3D3D3D   =1  3906            DB      '=================',CR,CR,80H
0DF6 3D3D3D3D   
0DFA 3D3D3D3D   
0DFE 3D3D3D3D   
0E02 3D0D0D80   
                =1  3907    
0E06 1207EB     =1  3908            CALL    DONE                    ;Get ready for next command
0E09 0123       =1  3909            JMP     NXT                     ;Execute next command
0E0B            =1  3910    FILES_END:
                =1  3911    
                =1  3912    $INCLUDE(AES\CMDS\LOAD.ASM)  ; load program
0E0B            =1  3913    LOAD_START:
                =1  3914    
0E0B 120623     =1  3915            call tst                        ; Check to see if 'FILE' command
0E0E 4C4F41C4   =1  3916            DB      'LOA',('D'or 80H)
0E12 503A       =1  3917            JNC     LOAD_END                ; If not, try next command
0E14 18         =1  3918            DEC     PNTR_L                  ; Back up pointer to start of FN
0E15 B8FF01     =1  3919            CJNE    PNTR_L,#0FFH,LOAD_CARY
0E18 1A         =1  3920            DEC     PNTR_H
0E19            =1  3921    LOAD_CARY:
0E19 D259       =1  3922            SETB    CHAR_FLG                ; Reset read Char flag
0E1B 7450       =1  3923            MOV     A,#'P'                  ; Set filetype to Program
0E1D 12118E     =1  3924            CALL    FIND_FILE               ; Find file in memory
0E20 4015       =1  3925            JC      LOAD_BADFN              ; Exit if filename invalid!
                =1  3926    
0E22 750900     =1  3927            MOV     TMP1,#LOW(EXTRAM)       ; Setup To ADDR
0E25 750A20     =1  3928            MOV     TMP2,#HIGH(EXTRAM)      ;
0E28 85820B     =1  3929            MOV     TMP3,DPL                ; Setup From Addr
0E2B 85830C     =1  3930            MOV     TMP4,DPH
                =1  3931    
0E2E D25E       =1  3932            SETB    RAMROM                  ; Move from ROM to XRAM
0E30 1211C3     =1  3933            Call    MOVE_P                  ; Move program in memory
                =1  3934    
0E33            =1  3935     LOAD_EXIT:
0E33 C251       =1  3936            CLR     AUTO                  ; Set Program Mode TO RAM, no autorun
0E35 417B       =1  3937            JMP     START
                =1  3938    
                =1  3939    
                =1  3940    
0E37            =1  3941    LOAD_BADFN:
0E37 12018B     =1  3942            CALL    STROUT                   ; Send String Below
0E3A 0D46696C   =1  3943            DB      CR,'File not found',CR,80H
0E3E 65206E6F   
0E42 7420666F   
0E46 756E640D   
LILBASIC        LilBasic (c)2002                                                                              PAGE 69

0E4A 80         
                =1  3944    
0E4B 020FBD     =1  3945            JMP     EXP_ER
                =1  3946    
                =1  3947    
0E4E            =1  3948    LOAD_END:
                =1  3949    $INCLUDE(AES\CMDS\SAVE.ASM)  ; save program
0E4E            =1  3950    SAVE_START:
0E4E 120623     =1  3951            call tst                        ; Check to see if 'SAVE' command
0E51 534156C5   =1  3952            DB      'SAV',('E'or 80H)
0E55 504B       =1  3953            JNC     SAVE_END                ; If not, try next command
0E57 18         =1  3954            DEC     PNTR_L                  ; Back up pointer to start of FN
0E58 B8FF01     =1  3955            CJNE    PNTR_L,#0FFH,SAVE_CARY
0E5B 1A         =1  3956            DEC     PNTR_H
0E5C            =1  3957    SAVE_CARY:
0E5C D259       =1  3958            SETB    CHAR_FLG                ; Reset read Char flag
0E5E 7450       =1  3959            MOV     A,#'P'                  ; Set filetype to Program
0E60 12118E     =1  3960            CALL    FIND_FILE               ; Find file in memory
0E63 50D2       =1  3961            JNC     LOAD_BADFN              ; Exit if filename found!
                =1  3962    
                =1  3963    
0E65 12126E     =1  3964            CALL    GET_XTOP                ; Set Datapointer to Top of Xram
                =1  3965    
                =1  3966    
0E68 7450       =1  3967            MOV     A,#'P'                  ; Set filetype to Program
0E6A 1211FD     =1  3968            call SET_TAG                    ; Put header in memory
                =1  3969    
                =1  3970    
0E6D 858209     =1  3971            MOV     TMP1,DPL                ; SET MOVE_P TO Addr
0E70 85830A     =1  3972            MOV     TMP2,DPH
                =1  3973    
0E73 750B00     =1  3974            MOV     TMP3,#LOW(EXTRAM)       ; SET MOVE_P FROM Addr
0E76 750C20     =1  3975            MOV     TMP4,#HIGH(EXTRAM)      ;
                =1  3976    
0E79 C25E       =1  3977            CLR     RAMROM                  ; Set flag to move from XRAM to XRAM
0E7B 1211C3     =1  3978            CALL    MOVE_P                  ; Move PROGRAM in Memory
                =1  3979    
0E7E 12125B     =1  3980            CALL    SAVE_XTOP               ; Save new Top of Xram
                =1  3981    
                =1  3982    
                =1  3983    
0E81            =1  3984     SAVE_EXIT:
                =1  3985    
0E81 417B       =1  3986            JMP     START
                =1  3987    
                =1  3988    
                =1  3989    
0E83            =1  3990    SAVE_BADFN:
0E83 12018B     =1  3991            CALL    STROUT                   ;Send String Below
0E86 0D44656C   =1  3992            DB      CR,'Delete old file first!',CR,80H
0E8A 65746520   
0E8E 6F6C6420   
0E92 66696C65   
0E96 20666972   
0E9A 7374210D   
0E9E 80         
                =1  3993    
0E9F 020FBD     =1  3994            JMP     EXP_ER
LILBASIC        LilBasic (c)2002                                                                              PAGE 70

0EA2            =1  3995    SAVE_END:
                =1  3996    $INCLUDE(AES\CMDS\WIPEALL.ASM) ; Wipe all programs
0EA2            =1  3997    WIPEALL_START:
                =1  3998    
0EA2 120623     =1  3999            call tst                        ;Check to see if 'WIPEALL' command
0EA5 57495045   =1  4000            DB      'WIPEAL',('L'or 80H)
0EA9 414CCC     
0EAC 502C       =1  4001            JNC     WIPEALL_END             ;If not, try next command
                =1  4002    
0EAE 908002     =1  4003            MOV     DPTR,#XRAM              ;Set pointer to start of MFS mem
0EB1 12125B     =1  4004            CALL    SAVE_XTOP               ;Reset top of mem pointer
                =1  4005            ;MOV     DPTR,#XRAM              ;Set pointer to start of MFS mem
                =1  4006    
0EB4 120F13     =1  4007            CALL    UNLOCK                  ; Unlock EEprom
0EB7 E0         =1  4008            MOVX    A,@DPTR                 ; This is a test
                =1  4009    
                =1  4010    
0EB8 1201B6     =1  4011            CALL    WAIT5MS
0EBB 1201B6     =1  4012            CALL    WAIT5MS
                =1  4013    
0EBE            =1  4014    WIPEALL_LOOP:
0EBE 7400       =1  4015            MOV     A,#0                    ;Set A to byte to wipe memory with
0EC0 F0         =1  4016            MOVX    @DPTR,A                 ;Clear memory
                =1  4017    
                =1  4018                                            ; Handle EEprom Page limitations
0EC1 E582       =1  4019            MOV     A, DPL                  ;   Get low byte
0EC3 541F       =1  4020            ANL     A,#01fh                 ;   Compute 32bit page boundry
0EC5 7007       =1  4021            JNZ     WIPEALL_CONT            ;   Check
                =1  4022    
0EC7 E0         =1  4023            MOVX     A,@DPTR                ; Force end of write cycle on EEPROM
0EC8 1201B6     =1  4024            CALL    WAIT5MS                 ;  Wait to complete
0ECB 1201B6     =1  4025            CALL    WAIT5MS
                =1  4026    
0ECE            =1  4027    WIPEALL_CONT:
0ECE A3         =1  4028            INC     DPTR                    ;Bump pointer to next address
0ECF B583EC     =1  4029            CJNE    A,DPH,WIPEALL_LOOP      ;Continue until end of memory.
                =1  4030    
0ED2 120F38     =1  4031            CALL    LOCK                    ; Lock EEprom
                =1  4032    
0ED5 1207EB     =1  4033            CALL    DONE                    ;Get ready for next command
0ED8 0123       =1  4034            JMP     NXT                     ;Execute next command
                =1  4035    
                =1  4036    
                =1  4037    
                =1  4038    
                =1  4039    
                =1  4040    
0EDA            =1  4041    WIPEALL_END:
                =1  4042    $INCLUDE(AES\CMDS\LOCK.ASM)    ; lock & Unlock memory
                =1  4043    
                =1  4044    
0EDA            =1  4045    STUNLOCK:                               ;Parse explicit UNLCOK command.
0EDA 120623     =1  4046            call   tst                      ;Test if 'UNLOCK' Command
0EDD 2E554E4C   =1  4047            db      '.UNLOC',('K' OR 80H)
0EE1 4F43CB     
0EE4 5008       =1  4048            jnc     ENDUNLOCK              ;if not 'UNLOCK' command process next command
0EE6 120F13     =1  4049            CALL    UNLOCK
0EE9 1207EB     =1  4050            CALL    DONE                    ;Get ready for next command
LILBASIC        LilBasic (c)2002                                                                              PAGE 71

0EEC 0123       =1  4051            JMP     NXT                     ;Execute next command
                =1  4052    
                =1  4053    
0EEE            =1  4054    ENDUNLOCK:
                =1  4055    
0EEE            =1  4056    STLOCK:                               ;Parse explicit LOCK command.
0EEE 120623     =1  4057            call   tst                      ;Test if 'LOCK' Command
0EF1 2E4C4F43   =1  4058            db      '.LOC',('K' OR 80H)
0EF5 CB         
0EF6 5008       =1  4059            jnc     ENDLOCK              ;if not 'LOCK' command process next command
0EF8 120F38     =1  4060            CALL   LOCK
0EFB 1207EB     =1  4061            CALL    DONE                    ;Get ready for next command
0EFE 0123       =1  4062            JMP     NXT                     ;Execute next command
                =1  4063    
                =1  4064    
0F00            =1  4065    ENDLOCK:
                =1  4066    
0F00            =1  4067    STCLEAR:                               ;Parse explicit CLEAR command.
0F00 120623     =1  4068            call   tst                      ;Test if 'CLEAR' Command
0F03 2E434C45   =1  4069            db      '.CLEA',('R' OR 80H)
0F07 41D2       
0F09 5008       =1  4070            jnc     ENDCLEAR              ;if not 'CLEAR' command process next command
0F0B 120F51     =1  4071            CALL    CLEAR
0F0E 1207EB     =1  4072            CALL    DONE                    ;Get ready for next command
0F11 0123       =1  4073            JMP     NXT                     ;Execute next command
                =1  4074    
                =1  4075    
0F13            =1  4076    ENDCLEAR:
                =1  4077    
0F13            =1  4078    UNLOCK:
0F13 74AA       =1  4079            mov A,#0AAh
0F15 90D555     =1  4080            mov DPTR,#0D555h                ; Write AA to D555
0F18 F0         =1  4081            MOVX @DPTR,A
                =1  4082    
0F19 7455       =1  4083            mov A,#55h
0F1B 90AAAA     =1  4084            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F1E F0         =1  4085            MOVX @DPTR,A
                =1  4086    
0F1F 7480       =1  4087            mov A,#80h
0F21 90D555     =1  4088            mov DPTR,#0D555h                ; Write 80 to D5555
0F24 F0         =1  4089            MOVX @DPTR,A
                =1  4090    
0F25 74AA       =1  4091            mov A,#0AAh
0F27 90D555     =1  4092            mov DPTR,#0D555h                ; Write AA to D555
0F2A F0         =1  4093            MOVX @DPTR,A
                =1  4094    
0F2B 7455       =1  4095            mov A,#55h
0F2D 90AAAA     =1  4096            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F30 F0         =1  4097            MOVX @DPTR,A
                =1  4098    
0F31 7420       =1  4099            mov A,#20h
0F33 90D555     =1  4100            mov DPTR,#0d555h                ; Write 20 to D5555
0F36 F0         =1  4101            MOVX @DPTR,A
0F37 22         =1  4102            RET
0F38            =1  4103    LOCK:
0F38 74AA       =1  4104            mov A,#0AAh
0F3A 90D555     =1  4105            mov DPTR,#0D555h                ; Write AA to D555
0F3D F0         =1  4106            MOVX @DPTR,A
LILBASIC        LilBasic (c)2002                                                                              PAGE 72

                =1  4107    
0F3E 7455       =1  4108            mov A,#55h
0F40 90AAAA     =1  4109            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F43 F0         =1  4110            MOVX @DPTR,A
                =1  4111    
0F44 74A0       =1  4112            mov A,#0A0h
0F46 90D555     =1  4113            mov DPTR,#0D555h                ; Write A0 to D5555
0F49 F0         =1  4114            MOVX @DPTR,A
                =1  4115    
0F4A 74AA       =1  4116            mov A,#0AAh
0F4C 90D555     =1  4117            mov DPTR,#0D555h                ; Write AA to D555
0F4F F0         =1  4118            MOVX @DPTR,A
0F50 22         =1  4119            RET
0F51            =1  4120    CLEAR:
0F51 74AA       =1  4121            mov A,#0AAh
0F53 90D555     =1  4122            mov DPTR,#0D555h                ; Write AA to D555
0F56 F0         =1  4123            MOVX @DPTR,A
                =1  4124    
0F57 7455       =1  4125            mov A,#55h
0F59 90AAAA     =1  4126            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F5C F0         =1  4127            MOVX @DPTR,A
                =1  4128    
0F5D 7480       =1  4129            mov A,#080h
0F5F 90D555     =1  4130            mov DPTR,#0D555h                ; Write 80 to D5555
0F62 F0         =1  4131            MOVX @DPTR,A
                =1  4132    
0F63 74AA       =1  4133            mov A,#0AAh
0F65 90D555     =1  4134            mov DPTR,#0D555h                ; Write AA to D555
0F68 F0         =1  4135            MOVX @DPTR,A
                =1  4136    
0F69 7455       =1  4137            mov A,#55h
0F6B 90AAAA     =1  4138            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F6E F0         =1  4139            MOVX @DPTR,A
                =1  4140    
0F6F 7410       =1  4141            mov A,#010h
0F71 90D555     =1  4142            mov DPTR,#0D555h                ; Write 10 to D555
0F74 F0         =1  4143            MOVX @DPTR,A
                =1  4144    
0F75 1201B6     =1  4145            CALL WAIT5MS                     ;Wait 20 MS
0F78 1201B6     =1  4146            CALL WAIT5MS
0F7B 1201B6     =1  4147            CALL WAIT5MS
0F7E 0201B6     =1  4148            JMP  WAIT5MS
                =1  4149    
                =1  4150    
                    4151    ;$INCLUDE(AES\CMDS\FORNEXT.ASM)
                    4152    
0F81 020FF4         4153    JMP   SYN_ER           ;If not a command, then Syntax Error
                    4154    
                =1  4155    $INCLUDE(AES\ERROR.ASM)
                =1  4156    
                =1  4157    
0F84            =1  4158    ERROUT:
                =1  4159    ;       Error handling routine common entry point.
                =1  4160    ;       (Could retype bad line, etc.)
                =1  4161    ;
0F84 AE18       =1  4162            MOV     TOS_L,LABL_L
0F86 AF19       =1  4163            MOV     TOS_H,LABL_H
0F88 8E1B       =1  4164            MOV     ELN_L,TOS_L             ;Save Line # of error for later use
LILBASIC        LilBasic (c)2002                                                                              PAGE 73

0F8A 8F1C       =1  4165            MOV     ELN_H,TOS_H
0F8C BE0005     =1  4166            CJNE    TOS_L,#0H,ERROR_PR      ;Jump to print routine if Error was from line #
0F8F BF0002     =1  4167            CJNE    TOS_H,#0H,ERROR_PR
                =1  4168    
0F92            =1  4169    ERROR_NP:
0F92 417B       =1  4170            JMP     ERRENT          ;Return to executive.
                =1  4171    
                =1  4172    
0F94            =1  4173    ERROR_PR:                       ;Print Basic line number of Error
0F94 12018B     =1  4174            CALL    STROUT
0F97 4572726F   =1  4175            DB      'Error in line number ',(80H)
0F9B 7220696E   
0F9F 206C696E   
0FA3 65206E75   
0FA7 6D626572   
0FAB 2080       
0FAD 751D00     =1  4176            MOV     AESP,#00H               ;Initialize AES pointer.
0FB0 1201DF     =1  4177            CALL    PUSH_TOS        ;Push Error Line number on stack
0FB3 1195       =1  4178            CALL PRN                ;Print it
0FB5 12018B     =1  4179            CALL    STROUT          ;Output error message.
0FB8 2E208D     =1  4180            DB      '. ',(CR OR 80H)
0FBB 80D5       =1  4181            SJMP    ERROR_NP
                =1  4182    ;
                =1  4183    ;=======
                =1  4184    ;
                =1  4185    ;EXP_ER Expression evaluation error.
0FBD 12018B     =1  4186    EXP_ER: CALL    STROUT          ;Output error message.
0FC0 4E6F7420   =1  4187            DB      'Not within my means.  ',07,(CR OR 80H)
0FC4 77697468   
0FC8 696E206D   
0FCC 79206D65   
0FD0 616E732E   
0FD4 2020078D   
0FD8 751A01     =1  4188            MOV     ERROR,#01
0FDB 80A7       =1  4189            JMP     ERROUT          ;Return to executive.
                =1  4190    ;
                =1  4191    ;=======
                =1  4192    ;
                =1  4193    ;AES_ER Arithmetic expression stack error handling routine.
0FDD 12018B     =1  4194    AES_ER: CALL    STROUT          ;Output error message.
0FE0 53746163   =1  4195            DB      'Stack error. ',07,(CR OR 80H)
0FE4 6B206572   
0FE8 726F722E   
0FEC 20078D     
0FEF 751A02     =1  4196            MOV     ERROR,#02
0FF2 8090       =1  4197            JMP     ERROUT          ;Return to executive.
                =1  4198    ;
                =1  4199    ;
                =1  4200    ;=======
                =1  4201    ;
                =1  4202    ;SYN_ER Syntax error handling routine.
0FF4 12018B     =1  4203    SYN_ER: CALL    STROUT          ;Output error message.
0FF7 0D53796E   =1  4204            DB      CR,'Syntax error. ',07,(CR OR 80H)
0FFB 74617820   
0FFF 6572726F   
1003 722E2007   
1007 8D         
1008 751A01     =1  4205            MOV     ERROR,#01
LILBASIC        LilBasic (c)2002                                                                              PAGE 74

100B 020F84     =1  4206            JMP     ERROUT          ;Process error.
                =1  4207    ;
                =1  4208    ;=======
                =1  4209    ;
                =1  4210    ;OV_ER overflow error handling routine.
100E 12018B     =1  4211    OV_ER: CALL    STROUT          ;Output error message.
1011 0D4F7665   =1  4212           DB      CR,'Overflow error. ',07,(CR OR 80H)
1015 72666C6F   
1019 77206572   
101D 726F722E   
1021 20078D     
1024 751A04     =1  4213           MOV     ERROR,#04
1027 020F84     =1  4214           JMP    ERROUT          ;Process error.
                =1  4215    ;
                =1  4216    
                =1  4217    ;=======
                    4218    ;EXP_ER
                    4219    ;       Expression evaluation error.
                    4220    ;AES_ER
                    4221    ;       Arithmetic expression stack error handling routine.
                    4222    ;SYN_ER
                    4223    ;       Syntax error handling routine.
                    4224    ;OV_ER
                    4225    ;       Overflow error handling routine.
                    4226    ;===========================================================================================
                                                                               ===============
                    4227    ;
                    4228    ;
                    4229    ;       INTERPRETIVE LANGUAGE SUBROUTINES:
                    4230    ;       ============ ======== ===========
                    4231    ;
102A 12103A         4232    EXPR:   CALL    AR_EXP
102D 12111D         4233    E0:     CALL    RELOP
1030 5046           4234            JNC     E5
1032 12103A         4235            CALL    AR_EXP
1035 120554         4236            CALL    CMPR
1038 80F3           4237            JMP    E0
                    4238    
103A 121079         4239    AR_EXP: CALL  TERM
                    4240    
                    4241    
                    4242    ;*E1:     %TST    (E2,+)
103D 120623         4243    e1:     call   tst
1040 AB             4244            db      ('+' OR 80H)
1041 5008           4245            jnc     e2
1043 121079         4246            CALL   TERM
1046 1203EF         4247            CALL    IADD
1049 80F2           4248            JMP    E1
                    4249    ;
                    4250    ;*E2:     %TST    (E3,-)
104B 120623         4251    e2:     call   tst
104E AD             4252            db      ('-' OR 80H)
104F 5008           4253            jnc     e3
1051 121079         4254            CALL  TERM
1054 120401         4255            CALL    ISUB
1057 80E4           4256            JMP    E1
                    4257    ;
                    4258    ;*E3:     %TST    (E4,OR)
LILBASIC        LilBasic (c)2002                                                                              PAGE 75

1059 120623         4259    e3:     call   tst
105C 4FD2           4260            db      'O',('R' OR 80H)
105E 5008           4261            jnc     e4
1060 121079         4262            CALL  TERM
1063 12041D         4263            CALL    IOR
1066 80D5           4264            JMP    E1
                    4265    ;
                    4266    ;*E4:     %TST    (E5,XOR)
1068 120623         4267    e4:     call   tst
106B 584FD2         4268            db      'XO',('R' OR 80H)
106E 5008           4269            jnc     e5
1070 121079         4270            CALL  TERM
1073 12042A         4271            CALL    IXOR
1076 80C5           4272            JMP    E1
                    4273    
1078 22             4274    E5:     RET
                    4275    ;
                    4276    ;
                    4277    ;=======
                    4278    ;
1079 1210B9         4279    TERM:   CALL  FACT
                    4280    ;*TERM_0: %TST    (TERM_1,*)
107C 120623         4281    term_0: call   tst
107F AA             4282            db      ('*' OR 80H)
1080 5008           4283            jnc     term_1
1082 1210B9         4284            CALL  FACT
1085 1204AD         4285            CALL    IMUL
1088 80F2           4286            JMP    TERM_0
                    4287    ;
                    4288    ;*TERM_1: %TST    (TERM_2,/)
108A 120623         4289    term_1: call   tst
108D AF             4290            db      ('/' OR 80H)
108E 5008           4291            jnc     term_2
1090 1210B9         4292            CALL  FACT
1093 1204C0         4293            CALL    IDIV
1096 80E4           4294            JMP    TERM_0
                    4295    ;
                    4296    ;*TERM_2: %TST    (TERM_3,AND)
1098 120623         4297    term_2: call   tst
109B 414EC4         4298            db      'AN',('D' OR 80H)
109E 5008           4299            jnc     term_3
10A0 1210B9         4300            CALL  FACT
10A3 120410         4301            CALL    IAND
10A6 80D4           4302            JMP    TERM_0
                    4303    ;
                    4304    ;*TERM_3: %TST    (TERM_4,MOD)
10A8 120623         4305    term_3: call   tst
10AB 4D4FC4         4306            db      'MO',('D' OR 80H)
10AE 5008           4307            jnc     term_4
10B0 1210B9         4308            CALL  FACT
10B3 1204BC         4309            CALL    IMOD
10B6 80C4           4310            JMP    TERM_0
                    4311    ;
10B8 22             4312    TERM_4: RET
                    4313    ;
                    4314    ;=======
                    4315    ;
                    4316    ;*FACT:   %TST    (FACT_1,-)
LILBASIC        LilBasic (c)2002                                                                              PAGE 76

10B9 120623         4317    fact:   call   tst
10BC AD             4318            db      ('-' OR 80H)
10BD 5007           4319            jnc     fact_1
10BF 1210D5         4320            CALL  VAR
10C2 12044B         4321            CALL    NEG
10C5 22             4322            RET
                    4323    ;
                    4324    ;*FACT_1: %TST    (VAR,NOT)
10C6 120623         4325    fact_1: call   tst
10C9 4E4FD4         4326            db      'NO',('T' OR 80H)
10CC 5007           4327            jnc     var
10CE 1210D5         4328            CALL  VAR
10D1 120448         4329            CALL    ICPL
10D4 22             4330            RET
                    4331    ;
                    4332    ;
                    4333    ;=======
                    4334    ;
                    4335 +1 VAR:    TSTV_   VAR_0
10D5 120654         4336 +1         CALL    TSTV
10D8 5004           4337 +1         JNC     VAR_0
10DA 120339         4339            CALL    FETCH
10DD 22             4340            RET
                    4341    ;
                    4342 +1 VAR_0:  TSTN_   VAR_1
10DE 1207B7         4343 +1         CALL    TSTN
10E1 5001           4344 +1         JNC     VAR_1
10E3 22             4346            RET
                    4347    ;
                    4348    ;*VAR_1:  %TST    (VAR_1A,RND)
10E4 120623         4349    var_1:  call   tst
10E7 524EC4         4350            db      'RN',('D' OR 80H)
10EA 5010           4351            jnc     var_1a
10EC 12052C         4352            CALL    RND
10EF 12110B         4353            CALL  VAR_2
10F2 1204BC         4354            CALL    IMOD
10F5 120437         4355            CALL    IABS
10F8 120465         4356            CALL    IINC
10FB 22             4357            RET
                    4358    ;
                    4359    ;*VAR_1A: %TST    (VAR_2,ABS)
10FC 120623         4360    var_1a: call   tst
10FF 4142D3         4361            db      'AB',('S' OR 80H)
1102 5007           4362            jnc     var_2
1104 12110B         4363            CALL  VAR_2
1107 120437         4364            CALL    IABS
110A 22             4365            RET
                    4366    ;
                    4367    ;*VAR_2:  %TST    (SYN_NG,%1()
110B 120623         4368    var_2:  call   tst
110E A8             4369            db      ('(' OR 80H)            ;to match lil'basic.LST
110F 5009           4370            jnc     syn_ng
1111 112A           4371            CALL  EXPR
                    4372    ;*        %TST    (SYN_NG,%1))
1113 120623         4373            call   tst
1116 A9             4374            db      (')' OR 80H)            ;to match lil'basic.LST
1117 5001           4375            jnc     syn_ng
1119 22             4376            RET
LILBASIC        LilBasic (c)2002                                                                              PAGE 77

                    4377    ;
                    4378    ;=======
                    4379    ;
111A 020AD9         4380    SYN_NG: JMP   CMD_NG
                    4381    ;
                    4382    
                    4383    ;
111D                4384    RELOP:
                    4385    ;       Search for relational operator in text string.
                    4386    ;       If found, push appropriate operator code on AES and return with
                    4387    ;       carry set.
                    4388    ;       Otherwise restore cursor and return with carry=0.
                    4389    ;
                    4390    ;*        %TST    (REL_1,=)
111D 120623         4391            call   tst
1120 BD             4392            db      ('=' OR 80H)
1121 5005           4393            jnc     rel_1
1123 120210         4394            CALL    LIT
1126 02             4395            DB      010B            ;Test for _=_
1127 22             4396            RET
                    4397    ;
                    4398    ;*REL_1:  %TST    (REL_2,<=)
1128 120623         4399    rel_1:  call   tst
112B 3CBD           4400            db      '<',('=' OR 80H)
112D 5005           4401            jnc     rel_2
112F 120210         4402            CALL    LIT
1132 06             4403            DB      110B            ;Test for <=_
1133 22             4404            RET
                    4405    ;
                    4406    ;*REL_2:  %TST    (REL_3,<>)
1134 120623         4407    rel_2:  call   tst
1137 3CBE           4408            db      '<',('>' OR 80H)
1139 5005           4409            jnc     rel_3
113B 120210         4410            CALL    LIT
113E 05             4411            DB      101B            ;Test for <_>
113F 22             4412            RET
                    4413    ;
                    4414    ;*REL_3:  %TST    (REL_4,<)
1140 120623         4415    rel_3:  call   tst
1143 BC             4416            db      ('<' OR 80H)
1144 5005           4417            jnc     rel_4
1146 120210         4418            CALL    LIT
1149 04             4419            DB      100B            ;Test for <__
114A 22             4420            RET
                    4421    ;
                    4422    ;*REL_4:  %TST    (REL_5,>=)
114B 120623         4423    rel_4:  call   tst
114E 3EBD           4424            db      '>',('=' OR 80H)
1150 5005           4425            jnc     rel_5
1152 120210         4426            CALL    LIT
1155 03             4427            DB      011B            ;Test for _=>
1156 22             4428            RET
                    4429    ;
                    4430    ;*REL_5:  %TST    (REL_6,>)
1157 120623         4431    rel_5:  call   tst
115A BE             4432            db      ('>' OR 80H)
115B 5005           4433            jnc     rel_6
115D 120210         4434            CALL    LIT
LILBASIC        LilBasic (c)2002                                                                              PAGE 78

1160 01             4435            DB      001B            ;Test for __>
1161 22             4436            RET
                    4437    ;
1162 C3             4438    REL_6:  CLR     C
1163 22             4439            RET
                    4440    ;
                    4441    ;======================================================================================
                    4442    ;       Memory File System
                    4443    ;======================================================================================
                    4444    
                    4445    ; FIND_NEXT_TAG
                    4446    ;
                    4447    ; SERCH FOR NEXT TAG IN MEMORY
                    4448    ; TAG = 029H,0EEH,0F1H,0F2H
                    4449    ; Uses ACC,DPTR,C
                    4450    ; Set:          DPTR --> start location
                    4451    ; Returns:      DPTR --> end of TAG   C --> 1 Found TAG   0 No TAG found
                =1  4452    $INCLUDE(MFS\TAG.asm)
                =1  4453    ; FIND_NEXT_TAG
                =1  4454    ;
                =1  4455    ; SERCH FOR NEXT TAG IN MEMORY
                =1  4456    ; TAG = 029H,0EEH,0F1H,0F2H
                =1  4457    ;
                =1  4458    ; Uses ACC,DPTR,C
                =1  4459    ; Set:          DPTR --> start location
                =1  4460    ; Returns:      DPTR --> end of TAG   C --> 1 Found TAG   0 No TAG found
                =1  4461    
1164            =1  4462    FIND_NEXT_TAG:
1164 E583       =1  4463            MOV     A,DPH           ; Get highbyte of current pointer address
1166 6024       =1  4464            JZ      NOT_TAG          ; TAG not allowed in first 256 bytes of mem, so exit with f
                                                                               alse if we are there.
1168 121172     =1  4465            CALL    IS_TAG          ; Check to see if DPTR --> TAG
116B A3         =1  4466            INC     DPTR            ; Increment DPRT to next byte
116C 50F6       =1  4467            JNC     FIND_NEXT_TAG   ; If tag not found then try again.
116E            =1  4468    TAG_FOUND:
116E A3         =1  4469            INC     DPTR            ;Increment DPRT past tag
116F A3         =1  4470            INC     DPTR
1170 A3         =1  4471            INC     DPTR
1171 22         =1  4472            RET
                =1  4473    
                =1  4474    
                =1  4475    
                =1  4476    ; Check if current location DPTR in memory is a TAG.
                =1  4477    ; C flag = 1 if true 0 if false.
1172            =1  4478    IS_TAG:
                =1  4479    
1172 7400       =1  4480            MOV     A,#00H          ; Check first byte
1174 93         =1  4481            MOVC    A,@A+DPTR
1175 B42914     =1  4482            CJNE    A,#029H,NOT_TAG ; Exit if fail
                =1  4483    
1178 7401       =1  4484            MOV     A,#01H          ; Check second byte
117A 93         =1  4485            MOVC    A,@A+DPTR
117B B4EE0E     =1  4486            CJNE    A,#0EEH,NOT_TAG ; Exit if fail
                =1  4487    
117E 7402       =1  4488            MOV     A,#02H          ; Check third byte
1180 93         =1  4489            MOVC    A,@A+DPTR
1181 B4F108     =1  4490            CJNE    A,#0F1H,NOT_TAG
                =1  4491    
LILBASIC        LilBasic (c)2002                                                                              PAGE 79

1184 7403       =1  4492            MOV     A,#03H          ; Check forth byte
1186 93         =1  4493            MOVC    A,@A+DPTR
1187 B4F202     =1  4494            CJNE    A,#0F2H,NOT_TAG ; Exit if fail else TAG=valid !!!
                =1  4495    
118A            =1  4496    YES_TAG:
118A D3         =1  4497            SETB    C               ; Set flag for True
118B 22         =1  4498            RET
                =1  4499    
118C            =1  4500    NOT_TAG:
118C C3         =1  4501            CLR     C               ; Clear flag for False
118D 22         =1  4502            RET
                =1  4503    
                    4504    
                    4505    
                    4506    
                    4507    ;=======
                    4508    ;FIND_FILE
                    4509    ;Find file pointed ontop of AES stack
                    4510    ; then point to program in memory!
                    4511    ; Uses A,DPTR,TMP1,TMP5,TMP6,TMP7
                    4512    ; Needs:        AESP --> Filename
                    4513    ;               A    --> Filetype
                    4514    ;
                    4515    ; Returns :     DPTR --> Start of program
                    4516    ;               C    --> Set if File not found.
                =1  4517    $INCLUDE(MFS\FIND.asm)
                =1  4518    ;FIND_FILE
                =1  4519    ;Find file pointed ontop of AES stack
                =1  4520    ; then point to program in memory!
                =1  4521    ; Needs:        PNTR_L --> Filename
                =1  4522    ;               PNTR_H -^
                =1  4523    ;               A      --> Filetype
                =1  4524    ;
                =1  4525    ; Returns :     DPTR  --> Start of program
                =1  4526    ;               C     --> SET = File name not found
                =1  4527    ;
                =1  4528    ; Uses:         TMP1  --> File Type
                =1  4529    ;               TMP2  --> Char in FN pointer/counter
                =1  4530    ;               TMP3  --> AES Pointer as is was when entered subroutine.
                =1  4531    ;               TMP4  -^
                =1  4532    ;               TMP5  --> Current char in AES FN being processed
                =1  4533    
                =1  4534    
                =1  4535    
                =1  4536    
118E            =1  4537    FIND_FILE:
118E F509       =1  4538            MOV     TMP1,A                  ;Save Filetype
1190 880B       =1  4539            MOV     TMP3,PNTR_L             ;Save Pointer
1192 8A0C       =1  4540            MOV     TMP4,PNTR_H             ;Save Pointer
1194 1205E5     =1  4541            CALL    READ_CHAR               ;Clear read char if needed
1197 9020EC     =1  4542            MOV     DPTR,#START_OF_PROGRAMS ;Initilize DATA pointer
                =1  4543    
119A            =1  4544    FIND_LOOP:
119A 3164       =1  4545            CALL    FIND_NEXT_TAG           ;Get next tag in memory
119C 5021       =1  4546            JNC     FIND_NO_FILE            ;If end found, then end
119E 7400       =1  4547            MOV     A,#0H                   ;Clear A
11A0 93         =1  4548            MOVC    A,@A+DPTR               ;Get File type
11A1 A3         =1  4549            INC     DPTR                    ;Step over tag
LILBASIC        LilBasic (c)2002                                                                              PAGE 80

11A2 B509F5     =1  4550            CJNE    A,TMP1,FIND_LOOP        ;If not the right file type, then try again.
11A5 A80B       =1  4551            MOV     PNTR_L,TMP3             ;Restore Pointer
11A7 AA0C       =1  4552            MOV     PNTR_H,TMP4             ;Restore Pointer
                =1  4553    
11A9            =1  4554    FIND_COMP_C:
                =1  4555    
11A9 1205E5     =1  4556            CALL    READ_CHAR
11AC 12010C     =1  4557            CALL    UPPER                   ;Convert  to uppercase
11AF F50D       =1  4558            MOV     TMP5,A                  ;Save Char for later use
11B1 7400       =1  4559            MOV     A,#0                    ;Clear Out A
11B3 93         =1  4560            MOVC    A,@A+DPTR               ;Get character in DPRT string
11B4 A3         =1  4561            INC     DPTR
11B5 12010C     =1  4562            CALL    UPPER                   ;Convert to uppercase
11B8 6007       =1  4563            JZ      FOUND_FILE              ;If at the end of FN then exit
11BA            =1  4564    FIND_CONT:
11BA B50DDD     =1  4565            CJNE    A,TMP5,FIND_LOOP        ;if chars not equal, Try next tag
11BD 80EA       =1  4566            SJMP    FIND_COMP_C             ;Else check next char
                =1  4567    
11BF            =1  4568    FIND_NO_FILE:                           ;File dosn't exist
11BF D3         =1  4569            SETB    C                       ;Flag invalid name
11C0 22         =1  4570            RET
                =1  4571    
11C1            =1  4572    FOUND_FILE:                              ;Found File !!!!!
                =1  4573    
11C1 C3         =1  4574            CLR     C                        ;Flag valid name
11C2 22         =1  4575            RET
                    4576    
                    4577    
                    4578    ;=======
                    4579    ; Move Program
                    4580    ; Move Basic program in memory FROM,TO
                    4581    ; Uses A,DPTR
                    4582    ; NEEDS         TMP1,TMP2 --> TO   L,H
                    4583    ;               TMP3,TMP4 --> FROM L,H
                    4584    ;               RAMROM    --> Set = ROM to XRAM
                    4585    ;                             Clr = XRAM to XRAM
                    4586    ; RETURNS       DPTR      --> END of moved file +1
                =1  4587    $INCLUDE(MFS\MOVE_P.asm)
                =1  4588    
                =1  4589    
                =1  4590    ; Move Program
                =1  4591    ; Move Basic program in memory FROM TMP1,2 TO TMP3,4
                =1  4592    ; Uses A,DPTR
                =1  4593    ; NEEDS         TMP1,TMP2 --> TO   L,H
                =1  4594    ;               TMP3,TMP4 --> FROM L,H
                =1  4595    ;               RAMROM    --> Set = ROM to XRAM
                =1  4596    ;                             Clr = XRAM to XRAM
                =1  4597    ;
                =1  4598    ;RETURNS        DPTR      --> End of file +1 address
                =1  4599    
11C3            =1  4600    MOVE_P:
11C3 850B82     =1  4601            MOV     DPL,TMP3                ; Get from addr
11C6 850C83     =1  4602            MOV     DPH,TMP4
                =1  4603    
11C9 205E03     =1  4604            JB      RAMROM,MOVE_ROM         ; Fetch from RAM/ROM ?  Set = ROM
                =1  4605    
11CC            =1  4606    MOVE_XRAM:                              ; Get byte from XRAM
11CC E0         =1  4607            MOVX    A,@DPTR
LILBASIC        LilBasic (c)2002                                                                              PAGE 81

11CD 8002       =1  4608            SJMP    MOVE_CONT
                =1  4609    
11CF            =1  4610    MOVE_ROM:                               ; Get byte from ROM
11CF E4         =1  4611            CLR     A
11D0 93         =1  4612            MOVC    A,@A+DPTR               ; Get Byte
                =1  4613    
11D1            =1  4614    MOVE_CONT:
11D1 A3         =1  4615            INC     DPTR                    ; Bump to next byte
11D2 85820B     =1  4616            MOV     TMP3,DPL                ; Save From Addr
11D5 85830C     =1  4617            MOV     TMP4,DPH
                =1  4618    
11D8 850982     =1  4619            MOV     DPL,TMP1                ; Get To Addr
11DB 850A83     =1  4620            Mov     DPH,TMP2
11DE F0         =1  4621            MOVX    @DPTR,A                 ; Store Byte
11DF A3         =1  4622            INC     DPTR
                =1  4623    
                =1  4624                                            ; Handle EEprom Page limitations
11E0 C0E0       =1  4625            PUSH ACC                        ; Save reg
11E2 E582       =1  4626            MOV     A, DPL                  ;   Get low byte
11E4 541F       =1  4627            ANL     A,#01fh                 ;   Compute 32bit page boundry
11E6 7007       =1  4628            JNZ     MOVE_CONT_2          ;   Check
                =1  4629    
11E8 E0         =1  4630            MOVX    A,@DPTR         ; Force end of write cycle on EEPROM
11E9 1201B6     =1  4631            CALL    WAIT5MS                 ;  Wait to complete
11EC 1201B6     =1  4632            CALL    WAIT5MS
                =1  4633    
11EF            =1  4634    MOVE_CONT_2:                            ; Restore Registers
11EF D0E0       =1  4635            POP ACC
                =1  4636    
11F1 858209     =1  4637            MOV     TMP1,DPL                ; Save To Addr
11F4 85830A     =1  4638            MOV     TMP2,DPH
11F7 5480       =1  4639            ANL     A,#80H                  ; Mask of all but MSB
11F9 B480C7     =1  4640            CJNE    A,#80H,MOVE_P           ; If MSB not not set, move Next Byte
11FC 22         =1  4641            RET                             ; Else we have moved the program
                    4642    
                    4643    ;=======
                    4644    
                    4645    ;SET_TAG
                    4646    ; Store  in memory
                    4647    ;029H,0EEH,0F1H,0F2H,'P',NAME,00H
                    4648    ; NEEDS         DPTR    --> Start Address in RAM
                    4649    
                    4650    ;               A       --> FILE TYPE
                    4651    ;               PNTR_L  --> Poiner to filename
                    4652    ;               PNTR_H
                    4653    ; USES          TMP1, TMP2
                =1  4654    $INCLUDE(MFS\SETTAG.asm)
                =1  4655    ;SET_TAG
                =1  4656    ; Store  in memory
                =1  4657    ;029H,0EEH,0F1H,0F2H,'P',NAME,00H
                =1  4658    ; NEEDS         DPTR    --> Start Address in RAM
                =1  4659    ;               A       --> FILE TYPE
                =1  4660    ;               PNTR_L  --> Poiner to filename
                =1  4661    ;               PNTR_H
                =1  4662    ;USES           TMP1,2
                =1  4663    
11FD            =1  4664    SET_TAG:
                =1  4665    
LILBASIC        LilBasic (c)2002                                                                              PAGE 82

11FD F509       =1  4666            MOV    TMP1,A           ; Save file type
                =1  4667    
11FF 7429       =1  4668            MOV     A,#029H         ; Store 029H,0EEH,0F1H,0F2H in Xmem
1201 F0         =1  4669            MOVX    @DPTR,A
1202 E0         =1  4670             MOVX    A,@DPTR                ; Force end of write cycle on EEPROM
1203 1201B6     =1  4671            CALL    WAIT5MS                 ;  Wait to complete
1206 1201B6     =1  4672            CALL    WAIT5MS
1209 A3         =1  4673            INC     DPTR
                =1  4674    
120A 74EE       =1  4675            MOV     A,#0EEH
120C F0         =1  4676            MOVX    @DPTR,A
120D E0         =1  4677            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
120E 1201B6     =1  4678            CALL    WAIT5MS                 ;  Wait to complete
1211 1201B6     =1  4679            CALL    WAIT5MS
1214 A3         =1  4680            INC     DPTR
                =1  4681    
1215 74F1       =1  4682            MOV     A,#0F1H
1217 F0         =1  4683            MOVX    @DPTR,A
1218 E0         =1  4684            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1219 1201B6     =1  4685            CALL    WAIT5MS                 ;  Wait to complete
121C 1201B6     =1  4686            CALL    WAIT5MS
121F A3         =1  4687            INC     DPTR
                =1  4688    
1220 74F2       =1  4689            MOV     A,#0F2H
1222 F0         =1  4690            MOVX    @DPTR,A
1223 E0         =1  4691            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1224 1201B6     =1  4692            CALL    WAIT5MS                 ;  Wait to complete
1227 1201B6     =1  4693            CALL    WAIT5MS
122A A3         =1  4694            INC     DPTR
                =1  4695    
122B E509       =1  4696            MOV     A,TMP1          ; Store File Type in Xmem
122D F0         =1  4697            MOVX    @DPTR,A
122E E0         =1  4698            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
122F 1201B6     =1  4699            CALL    WAIT5MS                 ;  Wait to complete
1232 1201B6     =1  4700            CALL    WAIT5MS
                =1  4701    
1235 18         =1  4702            DEC     PNTR_L          ; Back up pointer to start of FN
1236 B8FF00     =1  4703            CJNE    PNTR_L,#0FFH,SET_TAG_JMP
1239            =1  4704    SET_TAG_JMP:
1239 1A         =1  4705            DEC     PNTR_H
                =1  4706    
                =1  4707    
123A            =1  4708    SET_TAG_LOOP:                   ; Move File Name into Xmem
123A A3         =1  4709            INC DPTR                ; Bump pointer to next Char
123B C082       =1  4710            PUSH    DPL             ; Save DPTR
123D C083       =1  4711            PUSH    DPH
                =1  4712    
                =1  4713    
123F 1205E5     =1  4714            CALL    READ_CHAR       ; Get char from AES
1242 12010C     =1  4715            CALL    UPPER           ; Convert  to uppercase
                =1  4716    
1245 D083       =1  4717            POP DPH                 ; Store char from FN in Xmem
1247 D082       =1  4718            POP DPL
1249 F0         =1  4719            MOVX    @DPTR,A
124A 1200E6     =1  4720            CALL    ISALPHANUM      ; check to see if char is AlphaNumeric
124D 40EB       =1  4721            JC      SET_TAG_LOOP    ; Continue as long as char between A and Z
                =1  4722    
124F            =1  4723    SET_TAG_EOFN:
LILBASIC        LilBasic (c)2002                                                                              PAGE 83

124F 7400       =1  4724            MOV     A,#00H          ; Store 00 in mem to mark end of FN
1251 F0         =1  4725            MOVX    @DPTR,A
1252 E0         =1  4726            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1253 1201B6     =1  4727            CALL    WAIT5MS                 ;  Wait to complete
1256 1201B6     =1  4728            CALL    WAIT5MS
1259 A3         =1  4729            INC     DPTR
                =1  4730    
                =1  4731    
125A 22         =1  4732            RET
                    4733    
                    4734    
                    4735    ;=======
                    4736    
                    4737    
                    4738    ; XTOP
                    4739    ; Maintance for top of Xternal Memory File System
                    4740    ; Value is stored in Xram so it is not lost when
                    4741    ; power is lost!
                    4742    ;
                    4743    ; SAVE_XTOP
                    4744    ; Needs:        DPRT  --> New top of Xram
                    4745    ; Uses          A
                    4746    ;
                    4747    ;
                    4748    ; GET_XTOP
                    4749    ; Returns:      DPRT  --> New top of Xram
                    4750    ; Uses          A
                =1  4751    $INCLUDE(MFS\XTOP.asm)
                =1  4752    ; XTOP
                =1  4753    ; Maintance for top of Xternal Memory File System
                =1  4754    ; Value is stored in Xram so it is not lost when
                =1  4755    ; power is lost!
                =1  4756    ;
                =1  4757    ; SAVE_XTOP
                =1  4758    ; Needs:        DPRT  --> New top of Xram
                =1  4759    ; Uses          A
                =1  4760    ;
                =1  4761    ;
                =1  4762    ; GET_XTOP
                =1  4763    ; Returns:      DPRT  --> New top of Xram
                =1  4764    ; Uses          A
                =1  4765    
                =1  4766    
                =1  4767    
                =1  4768    
125B            =1  4769    SAVE_XTOP:
125B C082       =1  4770            PUSH    DPL                             ;Save Xtop Value
125D C083       =1  4771            PUSH    DPH
125F E582       =1  4772            MOV     A,DPL                           ;Get Low Byte
1261 908000     =1  4773            MOV     DPTR,#XTOP                      ;Point to first address
1264 F0         =1  4774            MOVX    @DPTR,A                         ;Store Low Byte
1265 A3         =1  4775            INC     DPTR                            ;Bump Pointer to next addr
1266 D0E0       =1  4776            POP     ACC                             ;Get High Byte
1268 F0         =1  4777            MOVX    @DPTR,A                         ;Store High Byte
1269 F583       =1  4778            MOV     DPH,A                           ;Move High Byte to DPTR
126B D082       =1  4779            POP     DPL                             ;Move Low Byte to DPTR
126D 22         =1  4780            RET
                =1  4781    
LILBASIC        LilBasic (c)2002                                                                              PAGE 84

                =1  4782    
                =1  4783    
                =1  4784    
126E            =1  4785    GET_XTOP:
126E 908000     =1  4786            MOV     DPTR,#XTOP                      ;Point to first address
1271 E0         =1  4787            MOVX    A,@DPTR                         ;Get Low Byte
1272 C0E0       =1  4788            PUSH    ACC                               ;Save Low Byte
1274 A3         =1  4789            INC     DPTR                            ;Bump Pointer to next addr
1275 E0         =1  4790            MOVX    A,@DPTR                         ;Get High Byte
1276 F583       =1  4791            MOV     DPH,A                           ;Move High Byte to DPTR
1278 D082       =1  4792            POP     DPL                             ;Move Low Byte to DPTR
127A 22         =1  4793            RET
                    4794    
                    4795    
                    4796    
                    4797    ;End Of Basic code
                    4798    ;======================================================================================
                    4799    ;       Basic Help Files
                    4800    ;======================================================================================
                    4801    
                    4802    
                    4803    
                =1  4804    $INCLUDE(AES\CMDS\HELPTEXT.ASM)         ;Text Help FILE
127B            =1  4805    HELPTEXT:      ;Help file to be displayed when 'HELP' command typed. END w/00HEX
                =1  4806    
127B 1B5B324A   =1  4807            DB      ESC,'[2J'       ;(CLS)
                =1  4808    
127F 204C696C   =1  4809            DB      ' Lil''Basic HELP (c)1998  -NQR',CR
1283 27426173   
1287 69632048   
128B 454C5020   
128F 28632931   
1293 39393820   
1297 202D4E51   
129B 520D       
129D 2D2D2D2D   =1  4810            DB      '-------------------------------------------------------------------',CR
12A1 2D2D2D2D   
12A5 2D2D2D2D   
12A9 2D2D2D2D   
12AD 2D2D2D2D   
12B1 2D2D2D2D   
12B5 2D2D2D2D   
12B9 2D2D2D2D   
12BD 2D2D2D2D   
12C1 2D2D2D2D   
12C5 2D2D2D2D   
12C9 2D2D2D2D   
12CD 2D2D2D2D   
12D1 2D2D2D2D   
12D5 2D2D2D2D   
12D9 2D2D2D2D   
12DD 2D2D2D0D   
12E1 0D         =1  4811            DB      CR
12E2 48656C70   =1  4812            DB      'Help On HELP command',CR
12E6 204F6E20   
12EA 48454C50   
12EE 20636F6D   
12F2 6D616E64   
LILBASIC        LilBasic (c)2002                                                                              PAGE 85

12F6 0D         
12F7 2D2D2D2D   =1  4813            DB      '--------------',CR
12FB 2D2D2D2D   
12FF 2D2D2D2D   
1303 2D2D0D     
1306 48454C50   =1  4814            DB      'HELP CMDS .......... Help on Basic commands',CR
130A 20434D44   
130E 53202E2E   
1312 2E2E2E2E   
1316 2E2E2E2E   
131A 2048656C   
131E 70206F6E   
1322 20426173   
1326 69632063   
132A 6F6D6D61   
132E 6E64730D   
1332 48454C50   =1  4815            DB      'HELP FUNC .......... Help on Basic functions',CR
1336 2046554E   
133A 43202E2E   
133E 2E2E2E2E   
1342 2E2E2E2E   
1346 2048656C   
134A 70206F6E   
134E 20426173   
1352 69632066   
1356 756E6374   
135A 696F6E73   
135E 0D         
135F 48454C50   =1  4816            DB      'HELP OPER .......... Help on Basic operators',CR
1363 204F5045   
1367 52202E2E   
136B 2E2E2E2E   
136F 2E2E2E2E   
1373 2048656C   
1377 70206F6E   
137B 20426173   
137F 6963206F   
1383 70657261   
1387 746F7273   
138B 0D         
138C 48454C50   =1  4817            DB      'HELP VARS .......... Help on Basic variables',CR
1390 20564152   
1394 53202E2E   
1398 2E2E2E2E   
139C 2E2E2E2E   
13A0 2048656C   
13A4 70206F6E   
13A8 20426173   
13AC 69632076   
13B0 61726961   
13B4 626C6573   
13B8 0D         
13B9 0D         =1  4818            DB      CR
13BA 0D         =1  4819            DB      CR
13BB 00         =1  4820            DB      00H
                =1  4821    
13BC            =1  4822    HELPTEXTCMD:
13BC 1B5B324A   =1  4823            DB      ESC,'[2J'       ;(CLS)
LILBASIC        LilBasic (c)2002                                                                              PAGE 86

13C0 204C696C   =1  4824            DB      ' Lil''Basic HELP (c)1998  -NQR',CR
13C4 27426173   
13C8 69632048   
13CC 454C5020   
13D0 28632931   
13D4 39393820   
13D8 202D4E51   
13DC 520D       
13DE 2D2D2D2D   =1  4825            DB      '-------------------------------------------------------------------',CR
13E2 2D2D2D2D   
13E6 2D2D2D2D   
13EA 2D2D2D2D   
13EE 2D2D2D2D   
13F2 2D2D2D2D   
13F6 2D2D2D2D   
13FA 2D2D2D2D   
13FE 2D2D2D2D   
1402 2D2D2D2D   
1406 2D2D2D2D   
140A 2D2D2D2D   
140E 2D2D2D2D   
1412 2D2D2D2D   
1416 2D2D2D2D   
141A 2D2D2D2D   
141E 2D2D2D0D   
1422 0D         =1  4826            DB      CR
1423 42617369   =1  4827            DB      'Basic Commands',CR
1427 6320436F   
142B 6D6D616E   
142F 64730D     
1432 2D2D2D2D   =1  4828            DB      '--------------',CR
1436 2D2D2D2D   
143A 2D2D2D2D   
143E 2D2D0D     
1441 46494C45   =1  4829            DB      'FILES  ............. List files in memory',CR
1445 5320202E   
1449 2E2E2E2E   
144D 2E2E2E2E   
1451 2E2E2E2E   
1455 204C6973   
1459 74206669   
145D 6C657320   
1461 696E206D   
1465 656D6F72   
1469 790D       
146B 4C4F4144   =1  4830            DB      'LOAD  .............. Load a program',CR
146F 20202E2E   
1473 2E2E2E2E   
1477 2E2E2E2E   
147B 2E2E2E2E   
147F 204C6F61   
1483 64206120   
1487 70726F67   
148B 72616D0D   
148F 53415645   =1  4831            DB      'SAVE ............... Save program ',CR
1493 202E2E2E   
1497 2E2E2E2E   
149B 2E2E2E2E   
LILBASIC        LilBasic (c)2002                                                                              PAGE 87

149F 2E2E2E2E   
14A3 20536176   
14A7 65207072   
14AB 6F677261   
14AF 6D200D     
14B2 57495045   =1  4832            DB      'WIPEALL ............ Wipe All saved programs'
14B6 414C4C20   
14BA 2E2E2E2E   
14BE 2E2E2E2E   
14C2 2E2E2E2E   
14C6 20576970   
14CA 6520416C   
14CE 6C207361   
14D2 76656420   
14D6 70726F67   
14DA 72616D73   
14DE 434C5320   =1  4833            DB      'CLS  ............... Send Escape code to clear the screen',CR
14E2 202E2E2E   
14E6 2E2E2E2E   
14EA 2E2E2E2E   
14EE 2E2E2E2E   
14F2 2053656E   
14F6 64204573   
14FA 63617065   
14FE 20636F64   
1502 6520746F   
1506 20636C65   
150A 61722074   
150E 68652073   
1512 63726565   
1516 6E0D       
1518 4C455420   =1  4834            DB      'LET  ............... Assign value to a variable ',CR
151C 202E2E2E   
1520 2E2E2E2E   
1524 2E2E2E2E   
1528 2E2E2E2E   
152C 20417373   
1530 69676E20   
1534 76616C75   
1538 6520746F   
153C 20612076   
1540 61726961   
1544 626C6520   
1548 0D         
1549 474F544F   =1  4835            DB      'GOTO ............... Continue execution on new line of code',CR
154D 202E2E2E   
1551 2E2E2E2E   
1555 2E2E2E2E   
1559 2E2E2E2E   
155D 20436F6E   
1561 74696E75   
1565 65206578   
1569 65637574   
156D 696F6E20   
1571 6F6E206E   
1575 6577206C   
1579 696E6520   
157D 6F662063   
LILBASIC        LilBasic (c)2002                                                                              PAGE 88

1581 6F64650D   
1585 474F5355   =1  4836            DB      'GOSUB  ............. Go to a subroutine',CR
1589 4220202E   
158D 2E2E2E2E   
1591 2E2E2E2E   
1595 2E2E2E2E   
1599 20476F20   
159D 746F2061   
15A1 20737562   
15A5 726F7574   
15A9 696E650D   
15AD 52455455   =1  4837            DB      'RETURN  ............ Return from a subroutine',CR
15B1 524E2020   
15B5 2E2E2E2E   
15B9 2E2E2E2E   
15BD 2E2E2E2E   
15C1 20526574   
15C5 75726E20   
15C9 66726F6D   
15CD 20612073   
15D1 7562726F   
15D5 7574696E   
15D9 650D       
15DB 5052494E   =1  4838            DB      'PRINT or ? ......... Display information via. 232 port',CR
15DF 54206F72   
15E3 203F202E   
15E7 2E2E2E2E   
15EB 2E2E2E2E   
15EF 20446973   
15F3 706C6179   
15F7 20696E66   
15FB 6F726D61   
15FF 74696F6E   
1603 20766961   
1607 2E203233   
160B 3220706F   
160F 72740D     
1612 49462028   =1  4839            DB      'IF () THEN  ........ Conditional branch',CR
1616 29205448   
161A 454E2020   
161E 2E2E2E2E   
1622 2E2E2E2E   
1626 20436F6E   
162A 64697469   
162E 6F6E616C   
1632 20627261   
1636 6E63680D   
163A 494E5055   =1  4840            DB      'INPUT  ............. Get a number from 232 port',CR
163E 5420202E   
1642 2E2E2E2E   
1646 2E2E2E2E   
164A 2E2E2E2E   
164E 20476574   
1652 2061206E   
1656 756D6265   
165A 72206672   
165E 6F6D2032   
1662 33322070   
LILBASIC        LilBasic (c)2002                                                                              PAGE 89

1666 6F72740D   
166A 43414C4C   =1  4841            DB      'CALL  .............. Execute machine code',CR
166E 20202E2E   
1672 2E2E2E2E   
1676 2E2E2E2E   
167A 2E2E2E2E   
167E 20457865   
1682 63757465   
1686 206D6163   
168A 68696E65   
168E 20636F64   
1692 650D       
                =1  4842    ;        DB      'FOR / NEXT  ........ Conditional loop',CR
1694 52454D20   =1  4843            DB      'REM  ............... Insert comments into program',CR
1698 202E2E2E   
169C 2E2E2E2E   
16A0 2E2E2E2E   
16A4 2E2E2E2E   
16A8 20496E73   
16AC 65727420   
16B0 636F6D6D   
16B4 656E7473   
16B8 20696E74   
16BC 6F207072   
16C0 6F677261   
16C4 6D0D       
16C6 454E4420   =1  4844            DB      'END  ............... Stop execution of program',CR
16CA 202E2E2E   
16CE 2E2E2E2E   
16D2 2E2E2E2E   
16D6 2E2E2E2E   
16DA 2053746F   
16DE 70206578   
16E2 65637574   
16E6 696F6E20   
16EA 6F662070   
16EE 726F6772   
16F2 616D0D     
16F5 4C495354   =1  4845            DB      'LIST  .............. Display program',CR
16F9 20202E2E   
16FD 2E2E2E2E   
1701 2E2E2E2E   
1705 2E2E2E2E   
1709 20446973   
170D 706C6179   
1711 2070726F   
1715 6772616D   
1719 0D         
171A 52554E20   =1  4846            DB      'RUN  ............... Execute program',CR
171E 202E2E2E   
1722 2E2E2E2E   
1726 2E2E2E2E   
172A 2E2E2E2E   
172E 20457865   
1732 63757465   
1736 2070726F   
173A 6772616D   
173E 0D         
LILBASIC        LilBasic (c)2002                                                                              PAGE 90

173F 4E455720   =1  4847            DB      'NEW  ............... Erase program & variables',CR
1743 202E2E2E   
1747 2E2E2E2E   
174B 2E2E2E2E   
174F 2E2E2E2E   
1753 20457261   
1757 73652070   
175B 726F6772   
175F 616D2026   
1763 20766172   
1767 6961626C   
176B 65730D     
176E 42524541   =1  4848            DB      'BREAK  ............. Restart CPU same as Reset button',CR
1772 4B20202E   
1776 2E2E2E2E   
177A 2E2E2E2E   
177E 2E2E2E2E   
1782 20526573   
1786 74617274   
178A 20435055   
178E 2073616D   
1792 65206173   
1796 20526573   
179A 65742062   
179E 7574746F   
17A2 6E0D       
17A4 48455820   =1  4849            DB      'HEX  ............... Change to Base 16 for Input & Output',CR
17A8 202E2E2E   
17AC 2E2E2E2E   
17B0 2E2E2E2E   
17B4 2E2E2E2E   
17B8 20436861   
17BC 6E676520   
17C0 746F2042   
17C4 61736520   
17C8 31362066   
17CC 6F722049   
17D0 6E707574   
17D4 2026204F   
17D8 75747075   
17DC 740D       
17DE 44454320   =1  4850            DB      'DEC  ............... Change to Base 10 for Input & Output',CR
17E2 202E2E2E   
17E6 2E2E2E2E   
17EA 2E2E2E2E   
17EE 2E2E2E2E   
17F2 20436861   
17F6 6E676520   
17FA 746F2042   
17FE 61736520   
1802 31302066   
1806 6F722049   
180A 6E707574   
180E 2026204F   
1812 75747075   
1816 740D       
1818 56455220   =1  4851            DB      'VER  ............... Display Lil''Basic version',CR
181C 202E2E2E   
LILBASIC        LilBasic (c)2002                                                                              PAGE 91

1820 2E2E2E2E   
1824 2E2E2E2E   
1828 2E2E2E2E   
182C 20446973   
1830 706C6179   
1834 204C696C   
1838 27426173   
183C 69632076   
1840 65727369   
1844 6F6E0D     
1847 0D         =1  4852            DB      CR
1848 00         =1  4853            DB      00H
1849            =1  4854    HELPTEXTFUNC:
1849 1B5B324A   =1  4855            DB      ESC,'[2J'       ;(CLS)
184D 204C696C   =1  4856            DB      ' Lil''Basic HELP (c)1998  -NQR',CR
1851 27426173   
1855 69632048   
1859 454C5020   
185D 28632931   
1861 39393820   
1865 202D4E51   
1869 520D       
186B 2D2D2D2D   =1  4857            DB      '-------------------------------------------------------------------',CR
186F 2D2D2D2D   
1873 2D2D2D2D   
1877 2D2D2D2D   
187B 2D2D2D2D   
187F 2D2D2D2D   
1883 2D2D2D2D   
1887 2D2D2D2D   
188B 2D2D2D2D   
188F 2D2D2D2D   
1893 2D2D2D2D   
1897 2D2D2D2D   
189B 2D2D2D2D   
189F 2D2D2D2D   
18A3 2D2D2D2D   
18A7 2D2D2D2D   
18AB 2D2D2D0D   
18AF 0D         =1  4858            DB      CR
18B0 42617369   =1  4859            DB      'Basic Functions',CR
18B4 63204675   
18B8 6E637469   
18BC 6F6E730D   
18C0 2D2D2D2D   =1  4860            DB      '---------------',CR
18C4 2D2D2D2D   
18C8 2D2D2D2D   
18CC 2D2D2D0D   
18D0 524E4428   =1  4861            DB      'RND()  ............. Returns a Random number from 1 to Number',CR
18D4 2920202E   
18D8 2E2E2E2E   
18DC 2E2E2E2E   
18E0 2E2E2E2E   
18E4 20526574   
18E8 75726E73   
18EC 20612052   
18F0 616E646F   
18F4 6D206E75   
LILBASIC        LilBasic (c)2002                                                                              PAGE 92

18F8 6D626572   
18FC 2066726F   
1900 6D203120   
1904 746F204E   
1908 756D6265   
190C 720D       
190E 41425328   =1  4862            DB      'ABS()  ............. Returns Absolute value of Number',CR
1912 2920202E   
1916 2E2E2E2E   
191A 2E2E2E2E   
191E 2E2E2E2E   
1922 20526574   
1926 75726E73   
192A 20416273   
192E 6F6C7574   
1932 65207661   
1936 6C756520   
193A 6F66204E   
193E 756D6265   
1942 720D       
1944 0D         =1  4863            DB      CR
1945 0D         =1  4864            DB      CR
1946 00         =1  4865            DB      00H
                =1  4866    
1947            =1  4867    HELPTEXTOPER:
1947 1B5B324A   =1  4868            DB      ESC,'[2J'       ;(CLS)
194B 204C696C   =1  4869            DB      ' Lil''Basic HELP file   (c)1998  -NQR',CR
194F 27426173   
1953 69632048   
1957 454C5020   
195B 66696C65   
195F 20202028   
1963 63293139   
1967 39382020   
196B 2D4E5152   
196F 0D         
1970 2D2D2D2D   =1  4870            DB      '-------------------------------------------------------------------',CR
1974 2D2D2D2D   
1978 2D2D2D2D   
197C 2D2D2D2D   
1980 2D2D2D2D   
1984 2D2D2D2D   
1988 2D2D2D2D   
198C 2D2D2D2D   
1990 2D2D2D2D   
1994 2D2D2D2D   
1998 2D2D2D2D   
199C 2D2D2D2D   
19A0 2D2D2D2D   
19A4 2D2D2D2D   
19A8 2D2D2D2D   
19AC 2D2D2D2D   
19B0 2D2D2D0D   
19B4 0D         =1  4871            DB      CR
19B5 42617369   =1  4872            DB      'Basic Operators',CR
19B9 63204F70   
19BD 65726174   
19C1 6F72730D   
LILBASIC        LilBasic (c)2002                                                                              PAGE 93

19C5 2D2D2D2D   =1  4873            DB      '---------------',CR
19C9 2D2D2D2D   
19CD 2D2D2D2D   
19D1 2D2D2D0D   
19D5 2B20202E   =1  4874            DB      '+  ................  Addition',CR
19D9 2E2E2E2E   
19DD 2E2E2E2E   
19E1 2E2E2E2E   
19E5 2E2E2E20   
19E9 20416464   
19ED 6974696F   
19F1 6E0D       
19F3 2D20202E   =1  4875            DB      '-  ................  Subtraction',CR
19F7 2E2E2E2E   
19FB 2E2E2E2E   
19FF 2E2E2E2E   
1A03 2E2E2E20   
1A07 20537562   
1A0B 74726163   
1A0F 74696F6E   
1A13 0D         
1A14 2A20202E   =1  4876            DB      '*  ................  Multiplication',CR
1A18 2E2E2E2E   
1A1C 2E2E2E2E   
1A20 2E2E2E2E   
1A24 2E2E2E20   
1A28 204D756C   
1A2C 7469706C   
1A30 69636174   
1A34 696F6E0D   
1A38 2F20202E   =1  4877            DB      '/  ................  Division',CR
1A3C 2E2E2E2E   
1A40 2E2E2E2E   
1A44 2E2E2E2E   
1A48 2E2E2E20   
1A4C 20446976   
1A50 6973696F   
1A54 6E0D       
1A56 4D4F4420   =1  4878            DB      'MOD  ..............  Modules ( Remainder from division )',CR
1A5A 202E2E2E   
1A5E 2E2E2E2E   
1A62 2E2E2E2E   
1A66 2E2E2E20   
1A6A 204D6F64   
1A6E 756C6573   
1A72 20282052   
1A76 656D6169   
1A7A 6E646572   
1A7E 2066726F   
1A82 6D206469   
1A86 76697369   
1A8A 6F6E2029   
1A8E 0D         
1A8F 3D20202E   =1  4879            DB      '=  ................  Compare if Equal',CR
1A93 2E2E2E2E   
1A97 2E2E2E2E   
1A9B 2E2E2E2E   
1A9F 2E2E2E20   
LILBASIC        LilBasic (c)2002                                                                              PAGE 94

1AA3 20436F6D   
1AA7 70617265   
1AAB 20696620   
1AAF 45717561   
1AB3 6C0D       
1AB5 3E20202E   =1  4880            DB      '>  ................  Compare if Greater than',CR
1AB9 2E2E2E2E   
1ABD 2E2E2E2E   
1AC1 2E2E2E2E   
1AC5 2E2E2E20   
1AC9 20436F6D   
1ACD 70617265   
1AD1 20696620   
1AD5 47726561   
1AD9 74657220   
1ADD 7468616E   
1AE1 0D         
1AE2 3C20202E   =1  4881            DB      '<  ................  Compare if Less than',CR
1AE6 2E2E2E2E   
1AEA 2E2E2E2E   
1AEE 2E2E2E2E   
1AF2 2E2E2E20   
1AF6 20436F6D   
1AFA 70617265   
1AFE 20696620   
1B02 4C657373   
1B06 20746861   
1B0A 6E0D       
1B0C 3C3E2020   =1  4882            DB      '<>  ...............  Compare if Not Equal',CR
1B10 2E2E2E2E   
1B14 2E2E2E2E   
1B18 2E2E2E2E   
1B1C 2E2E2E20   
1B20 20436F6D   
1B24 70617265   
1B28 20696620   
1B2C 4E6F7420   
1B30 45717561   
1B34 6C0D       
1B36 3E3D2020   =1  4883            DB      '>=  ...............  Compair if Grater than or Equal',CR
1B3A 2E2E2E2E   
1B3E 2E2E2E2E   
1B42 2E2E2E2E   
1B46 2E2E2E20   
1B4A 20436F6D   
1B4E 70616972   
1B52 20696620   
1B56 47726174   
1B5A 65722074   
1B5E 68616E20   
1B62 6F722045   
1B66 7175616C   
1B6A 0D         
1B6B 3C3D2020   =1  4884            DB      '<=  ...............  Compair if Less than or Equal',CR
1B6F 2E2E2E2E   
1B73 2E2E2E2E   
1B77 2E2E2E2E   
1B7B 2E2E2E20   
LILBASIC        LilBasic (c)2002                                                                              PAGE 95

1B7F 20436F6D   
1B83 70616972   
1B87 20696620   
1B8B 4C657373   
1B8F 20746861   
1B93 6E206F72   
1B97 20457175   
1B9B 616C0D     
1B9E 4E4F5420   =1  4885            DB      'NOT  ..............  Bit-wise logical complement',CR
1BA2 202E2E2E   
1BA6 2E2E2E2E   
1BAA 2E2E2E2E   
1BAE 2E2E2E20   
1BB2 20426974   
1BB6 2D776973   
1BBA 65206C6F   
1BBE 67696361   
1BC2 6C20636F   
1BC6 6D706C65   
1BCA 6D656E74   
1BCE 0D         
1BCF 414E4420   =1  4886            DB      'AND  ..............  Bit-wise logical AND',CR
1BD3 202E2E2E   
1BD7 2E2E2E2E   
1BDB 2E2E2E2E   
1BDF 2E2E2E20   
1BE3 20426974   
1BE7 2D776973   
1BEB 65206C6F   
1BEF 67696361   
1BF3 6C20414E   
1BF7 440D       
1BF9 4F522020   =1  4887            DB      'OR  ...............  Bit-wise logical OR',CR
1BFD 2E2E2E2E   
1C01 2E2E2E2E   
1C05 2E2E2E2E   
1C09 2E2E2E20   
1C0D 20426974   
1C11 2D776973   
1C15 65206C6F   
1C19 67696361   
1C1D 6C204F52   
1C21 0D         
1C22 584F5220   =1  4888            DB      'XOR  ..............  Bit-wise logical Exclusive OR',CR
1C26 202E2E2E   
1C2A 2E2E2E2E   
1C2E 2E2E2E2E   
1C32 2E2E2E20   
1C36 20426974   
1C3A 2D776973   
1C3E 65206C6F   
1C42 67696361   
1C46 6C204578   
1C4A 636C7573   
1C4E 69766520   
1C52 4F520D     
1C55 0D         =1  4889            DB      CR
1C56 0D         =1  4890            DB      CR
LILBASIC        LilBasic (c)2002                                                                              PAGE 96

1C57 00         =1  4891            DB      00H
                =1  4892    
1C58            =1  4893    HELPTEXTVARS:
1C58 1B5B324A   =1  4894            DB      ESC,'[2J'       ;(CLS)
1C5C 204C696C   =1  4895            DB      ' Lil''Basic HELP file   (c)1998  -NQR',CR
1C60 27426173   
1C64 69632048   
1C68 454C5020   
1C6C 66696C65   
1C70 20202028   
1C74 63293139   
1C78 39382020   
1C7C 2D4E5152   
1C80 0D         
1C81 2D2D2D2D   =1  4896            DB      '-------------------------------------------------------------------',CR
1C85 2D2D2D2D   
1C89 2D2D2D2D   
1C8D 2D2D2D2D   
1C91 2D2D2D2D   
1C95 2D2D2D2D   
1C99 2D2D2D2D   
1C9D 2D2D2D2D   
1CA1 2D2D2D2D   
1CA5 2D2D2D2D   
1CA9 2D2D2D2D   
1CAD 2D2D2D2D   
1CB1 2D2D2D2D   
1CB5 2D2D2D2D   
1CB9 2D2D2D2D   
1CBD 2D2D2D2D   
1CC1 2D2D2D0D   
1CC5 0D         =1  4897            DB      CR
1CC6 42617369   =1  4898            DB      'Basic Variables',CR
1CCA 63205661   
1CCE 72696162   
1CD2 6C65730D   
1CD6 2D2D2D2D   =1  4899            DB      '---------------',CR
1CDA 2D2D2D2D   
1CDE 2D2D2D2D   
1CE2 2D2D2D0D   
1CE6 4120746F   =1  4900            DB      'A to Z .............  Basic Program variables',CR
1CEA 205A202E   
1CEE 2E2E2E2E   
1CF2 2E2E2E2E   
1CF6 2E2E2E2E   
1CFA 20204261   
1CFE 73696320   
1D02 50726F67   
1D06 72616D20   
1D0A 76617269   
1D0E 61626C65   
1D12 730D       
1D14 504F5254   =1  4901            DB      'PORT1  .............  8 bit user Port on PCB',CR
1D18 3120202E   
1D1C 2E2E2E2E   
1D20 2E2E2E2E   
1D24 2E2E2E2E   
1D28 20203820   
LILBASIC        LilBasic (c)2002                                                                              PAGE 97

1D2C 62697420   
1D30 75736572   
1D34 20506F72   
1D38 74206F6E   
1D3C 20504342   
1D40 0D         
                =1  4902            ;DB      'PORT2  .............  4 bit expansion Port on PCB',CR
1D41 44425954   =1  4903            DB      'DBYTE()  ...........  On board CPU Memory location',CR
1D45 45282920   
1D49 202E2E2E   
1D4D 2E2E2E2E   
1D51 2E2E2E2E   
1D55 20204F6E   
1D59 20626F61   
1D5D 72642043   
1D61 5055204D   
1D65 656D6F72   
1D69 79206C6F   
1D6D 63617469   
1D71 6F6E0D     
1D74 52424954   =1  4904            DB      'RBIT()  ............  On board CPU Bit location',CR
1D78 28292020   
1D7C 2E2E2E2E   
1D80 2E2E2E2E   
1D84 2E2E2E2E   
1D88 20204F6E   
1D8C 20626F61   
1D90 72642043   
1D94 50552042   
1D98 6974206C   
1D9C 6F636174   
1DA0 696F6E0D   
1DA4 58425954   =1  4905            DB      'XBYTE()  ...........  External Memory location',CR
1DA8 45282920   
1DAC 202E2E2E   
1DB0 2E2E2E2E   
1DB4 2E2E2E2E   
1DB8 20204578   
1DBC 7465726E   
1DC0 616C204D   
1DC4 656D6F72   
1DC8 79206C6F   
1DCC 63617469   
1DD0 6F6E0D     
1DD3 43425954   =1  4906            DB      'CBYTE()  ...........  Code Memory location',CR
1DD7 45282920   
1DDB 202E2E2E   
1DDF 2E2E2E2E   
1DE3 2E2E2E2E   
1DE7 2020436F   
1DEB 6465204D   
1DEF 656D6F72   
1DF3 79206C6F   
1DF7 63617469   
1DFB 6F6E0D     
1DFE 50574D31   =1  4907            DB      'PWM1() .............  Pulse With Modulation Pin 1 duration = (x)',CR
1E02 2829202E   
1E06 2E2E2E2E   
LILBASIC        LilBasic (c)2002                                                                              PAGE 98

1E0A 2E2E2E2E   
1E0E 2E2E2E2E   
1E12 20205075   
1E16 6C736520   
1E1A 57697468   
1E1E 204D6F64   
1E22 756C6174   
1E26 696F6E20   
1E2A 50696E20   
1E2E 31206475   
1E32 72617469   
1E36 6F6E203D   
1E3A 20287829   
1E3E 0D         
1E3F 50574D32   =1  4908            DB      'PWM2() .............  Pulse With Modulation Pin 2 duration = (x)',CR
1E43 2829202E   
1E47 2E2E2E2E   
1E4B 2E2E2E2E   
1E4F 2E2E2E2E   
1E53 20205075   
1E57 6C736520   
1E5B 57697468   
1E5F 204D6F64   
1E63 756C6174   
1E67 696F6E20   
1E6B 50696E20   
1E6F 32206475   
1E73 72617469   
1E77 6F6E203D   
1E7B 20287829   
1E7F 0D         
1E80 50574D33   =1  4909            DB      'PWM3() .............  Pulse With Modulation Pin 3 duration = (x)',CR
1E84 2829202E   
1E88 2E2E2E2E   
1E8C 2E2E2E2E   
1E90 2E2E2E2E   
1E94 20205075   
1E98 6C736520   
1E9C 57697468   
1EA0 204D6F64   
1EA4 756C6174   
1EA8 696F6E20   
1EAC 50696E20   
1EB0 33206475   
1EB4 72617469   
1EB8 6F6E203D   
1EBC 20287829   
1EC0 0D         
1EC1 50574D34   =1  4910            DB      'PWM4() .............  Pulse With Modulation Pin 4 duration = (x)',CR
1EC5 2829202E   
1EC9 2E2E2E2E   
1ECD 2E2E2E2E   
1ED1 2E2E2E2E   
1ED5 20205075   
1ED9 6C736520   
1EDD 57697468   
1EE1 204D6F64   
1EE5 756C6174   
LILBASIC        LilBasic (c)2002                                                                              PAGE 99

1EE9 696F6E20   
1EED 50696E20   
1EF1 34206475   
1EF5 72617469   
1EF9 6F6E203D   
1EFD 20287829   
1F01 0D         
1F02 50574D35   =1  4911            DB      'PWM5() .............  Pulse With Modulation Pin 5 duration = (x)',CR
1F06 2829202E   
1F0A 2E2E2E2E   
1F0E 2E2E2E2E   
1F12 2E2E2E2E   
1F16 20205075   
1F1A 6C736520   
1F1E 57697468   
1F22 204D6F64   
1F26 756C6174   
1F2A 696F6E20   
1F2E 50696E20   
1F32 35206475   
1F36 72617469   
1F3A 6F6E203D   
1F3E 20287829   
1F42 0D         
1F43 50574D36   =1  4912            DB      'PWM6() .............  Pulse With Modulation Pin 6 duration = (x)',CR
1F47 2829202E   
1F4B 2E2E2E2E   
1F4F 2E2E2E2E   
1F53 2E2E2E2E   
1F57 20205075   
1F5B 6C736520   
1F5F 57697468   
1F63 204D6F64   
1F67 756C6174   
1F6B 696F6E20   
1F6F 50696E20   
1F73 36206475   
1F77 72617469   
1F7B 6F6E203D   
1F7F 20287829   
1F83 0D         
1F84 50574D37   =1  4913            DB      'PWM7() .............  Pulse With Modulation Pin 7 duration = (x)',CR
1F88 2829202E   
1F8C 2E2E2E2E   
1F90 2E2E2E2E   
1F94 2E2E2E2E   
1F98 20205075   
1F9C 6C736520   
1FA0 57697468   
1FA4 204D6F64   
1FA8 756C6174   
1FAC 696F6E20   
1FB0 50696E20   
1FB4 37206475   
1FB8 72617469   
1FBC 6F6E203D   
1FC0 20287829   
1FC4 0D         
LILBASIC        LilBasic (c)2002                                                                              PAGE 100

1FC5 50574D38   =1  4914            DB      'PWM8() .............  Pulse With Modulation Pin 8 duration = (x)',CR
1FC9 2829202E   
1FCD 2E2E2E2E   
1FD1 2E2E2E2E   
1FD5 2E2E2E2E   
1FD9 20205075   
1FDD 6C736520   
1FE1 57697468   
1FE5 204D6F64   
1FE9 756C6174   
1FED 696F6E20   
1FF1 50696E20   
1FF5 38206475   
1FF9 72617469   
1FFD 6F6E203D   
2001 20287829   
2005 0D         
2006 4D41534B   =1  4915            DB      'MASK  ..............  Mask for PWM pins used.  IE. 255 = all pins 0 = none'
                                                                               ,CR
200A 20202E2E   
200E 2E2E2E2E   
2012 2E2E2E2E   
2016 2E2E2E2E   
201A 20204D61   
201E 736B2066   
2022 6F722050   
2026 574D2070   
202A 696E7320   
202E 75736564   
2032 2E202049   
2036 452E2032   
203A 3535203D   
203E 20616C6C   
2042 2070696E   
2046 73203020   
204A 3D206E6F   
204E 6E650D     
2051 46524551   =1  4916            DB      'FREQ  ..............  FREQUENCY of PWM cycles  1= 36hz  75=50hz  100= 60hz 
                                                                               ',CR
2055 20202E2E   
2059 2E2E2E2E   
205D 2E2E2E2E   
2061 2E2E2E2E   
2065 20204652   
2069 45515545   
206D 4E435920   
2071 6F662050   
2075 574D2063   
2079 79636C65   
207D 73202031   
2081 3D203336   
2085 687A2020   
2089 37353D35   
208D 30687A20   
2091 20313030   
2095 3D203630   
2099 687A200D   
209D 20202020   =1  4917            DB      '                                             165=100hz 180=120hz 255=200hz 
LILBASIC        LilBasic (c)2002                                                                              PAGE 101

                                                                               ',CR
20A1 20202020   
20A5 20202020   
20A9 20202020   
20AD 20202020   
20B1 20202020   
20B5 20202020   
20B9 20202020   
20BD 20202020   
20C1 20202020   
20C5 20202020   
20C9 20313635   
20CD 3D313030   
20D1 687A2031   
20D5 38303D31   
20D9 3230687A   
20DD 20323535   
20E1 3D323030   
20E5 687A200D   
20E9 0D         =1  4918            DB      CR
20EA 0D         =1  4919            DB      CR
20EB 00         =1  4920            DB      00H            ;End of Help File
                    4921    
                    4922    
                    4923    ;======================================================================================
                    4924    ;       Basic Programs stored in ROM
                    4925    ;======================================================================================
                    4926    
                    4927    
20EC                4928    START_OF_PROGRAMS:
                    4929                                        ;PFILE = PROGRAM FILE
                    4930                                        ;DFILE = DATA FILE
                    4931    
                    4932    
                    4933 +1 PFILE 'DEMO'
20EC 29EEF1F2       4934 +1         DB      029H,0EEH,0F1H,0F2H,'P','DEMO',00H
20F0 5044454D   
20F4 4F00       
20F6                4936    DEMOPROG:                           ;Start of DEMO program buffer.
                =1  4937    $INCLUDE(DEMOS\DEMO.ASM)
                =1  4938                                 ;DEMO.BAS
                =1  4939                                 ;--------
20F6 000A       =1  4940    DW      10 
20F8 434C5320   =1  4941    DB     'CLS : S = 0' ,0DH
20FC 3A205320   
2100 3D20300D   
2104 0014       =1  4942    DW      20 
2106 3F224445   =1  4943    DB     '?"DEMO PROGRAM"' ,0DH
210A 4D4F2050   
210E 524F4752   
2112 414D220D   
2116 001E       =1  4944    DW      30 
2118 474F5355   =1  4945    DB     'GOSUB 2000' ,0DH
211C 42203230   
2120 30300D     
2123 0028       =1  4946    DW      40 
2125 4C3D4C2B   =1  4947    DB     'L=L+B' ,0DH
2129 420D       
LILBASIC        LilBasic (c)2002                                                                              PAGE 102

212B 0032       =1  4948    DW      50 
212D 4946204C   =1  4949    DB     'IF L < 1 THEN L = 4' ,0DH
2131 203C2031   
2135 20544845   
2139 4E204C20   
213D 3D20340D   
2141 003C       =1  4950    DW      60 
2143 4946204C   =1  4951    DB     'IF L > 4 THEN L = 1' ,0DH
2147 203E2034   
214B 20544845   
214F 4E204C20   
2153 3D20310D   
2157 0046       =1  4952    DW      70 
2159 474F5355   =1  4953    DB     'GOSUB 1000' ,0DH
215D 42203130   
2161 30300D     
2164 0050       =1  4954    DW      80 
2166 474F544F   =1  4955    DB     'GOTO 30' ,0DH
216A 2033300D   
216E 03E8       =1  4956    DW      1000 
2170 52454D20   =1  4957    DB     'REM LED DECODE' ,0DH
2174 4C454420   
2178 4445434F   
217C 44450D     
217F 03F2       =1  4958    DW      1010 
2181 4946204C   =1  4959    DB     'IF L=1 THEN PORT1= NOT1' ,0DH
2185 3D312054   
2189 48454E20   
218D 504F5254   
2191 313D204E   
2195 4F54310D   
2199 03FC       =1  4960    DW      1020 
219B 4946204C   =1  4961    DB     'IF L=2 THEN PORT1= NOT4' ,0DH
219F 3D322054   
21A3 48454E20   
21A7 504F5254   
21AB 313D204E   
21AF 4F54340D   
21B3 0406       =1  4962    DW      1030 
21B5 4946204C   =1  4963    DB     'IF L=3 THEN PORT1= NOT 16' ,0DH
21B9 3D332054   
21BD 48454E20   
21C1 504F5254   
21C5 313D204E   
21C9 4F542031   
21CD 360D       
21CF 0410       =1  4964    DW      1040 
21D1 4946204C   =1  4965    DB     'IF L=4 THEN PORT1= NOT 64' ,0DH
21D5 3D342054   
21D9 48454E20   
21DD 504F5254   
21E1 313D204E   
21E5 4F542036   
21E9 340D       
21EB 041A       =1  4966    DW      1050 
21ED 52455455   =1  4967    DB     'RETURN' ,0DH
21F1 524E0D     
21F4 07D0       =1  4968    DW      2000 
LILBASIC        LilBasic (c)2002                                                                              PAGE 103

21F6 52454D20   =1  4969    DB     'REM GET BUTTON STATE' ,0DH
21FA 47455420   
21FE 42555454   
2202 4F4E2053   
2206 54415445   
220A 0D         
220B 07DA       =1  4970    DW      2010 
220D 423D2850   =1  4971    DB     'B=(PORT1 AND 2) -1' ,0DH
2211 4F525431   
2215 20414E44   
2219 20322920   
221D 2D310D     
2220 07E4       =1  4972    DW      2020 
2222 49462054   =1  4973    DB     'IF T = B THEN GOTO 2050' ,0DH
2226 203D2042   
222A 20544845   
222E 4E20474F   
2232 544F2032   
2236 3035300D   
223A 07EE       =1  4974    DW      2030 
223C 533D4E4F   =1  4975    DB     'S=NOT S' ,0DH
2240 5420530D   
2244 07F8       =1  4976    DW      2040 
2246 49462053   =1  4977    DB     'IF S THEN PRINT "BUTTON UP"' ,0DH
224A 20544845   
224E 4E205052   
2252 494E5420   
2256 22425554   
225A 544F4E20   
225E 5550220D   
2262 07FD       =1  4978    DW      2045 
2264 4946204E   =1  4979    DB     'IF NOT S THEN PRINT "BUTTON DOWN"' ,0DH
2268 4F542053   
226C 20544845   
2270 4E205052   
2274 494E5420   
2278 22425554   
227C 544F4E20   
2280 444F574E   
2284 220D       
2286 0802       =1  4980    DW      2050 
2288 54203D20   =1  4981    DB     'T = B' ,0DH
228C 420D       
228E 080C       =1  4982    DW      2060 
2290 52455455   =1  4983    DB     'RETURN' ,0DH
2294 524E0D     
2297 80         =1  4984    DB 80H
  01A2          =1  4985    DEMO_LEN EQU  418 
                    4986 +1 PFILE 'WALK'
2298 29EEF1F2       4987 +1         DB      029H,0EEH,0F1H,0F2H,'P','WALK',00H
229C 5057414C   
22A0 4B00       
                =1  4989    $INCLUDE(DEMOS\walk.ASM)
                =1  4990                                 ;WALK.BAS
                =1  4991                                 ;--------
22A2 000A       =1  4992    DW      10 
22A4 636C733A   =1  4993    DB     'cls:?"Cricket By Neil Q. Richins":?"Written in Lil"Basic":?:?' ,0DH
22A8 3F224372   
LILBASIC        LilBasic (c)2002                                                                              PAGE 104

22AC 69636B65   
22B0 74204279   
22B4 204E6569   
22B8 6C20512E   
22BC 20526963   
22C0 68696E73   
22C4 223A3F22   
22C8 57726974   
22CC 74656E20   
22D0 696E204C   
22D4 696C2242   
22D8 61736963   
22DC 223A3F3A   
22E0 3F0D       
22E2 0014       =1  4994    DW      20 
22E4 66726571   =1  4995    DB     'freq=20:mask=255:b=30:d=0:pwm0=0:r=timer' ,0DH
22E8 3D32303A   
22EC 6D61736B   
22F0 3D323535   
22F4 3A623D33   
22F8 303A643D   
22FC 303A7077   
2300 6D303D30   
2304 3A723D74   
2308 696D6572   
230C 0D         
230D 001E       =1  4996    DW      30 
230F 613D300D   =1  4997    DB     'a=0' ,0DH
2313 0028       =1  4998    DW      40 
2315 613D612B   =1  4999    DB     'a=a+1' ,0DH
2319 310D       
231B 0032       =1  5000    DW      50 
231D 69662061   =1  5001    DB     'if a>2 then goto 30' ,0DH
2321 3E322074   
2325 68656E20   
2329 676F746F   
232D 2033300D   
2331 003C       =1  5002    DW      60 
2333 52656D20   =1  5003    DB     'Rem check to see what foot to move' ,0DH
2337 63686563   
233B 6B20746F   
233F 20736565   
2343 20776861   
2347 7420666F   
234B 6F742074   
234F 6F206D6F   
2353 76650D     
2356 0046       =1  5004    DW      70 
2358 69662061   =1  5005    DB     'if a=1 then x=50' ,0DH
235C 3D312074   
2360 68656E20   
2364 783D3530   
2368 0D         
2369 005A       =1  5006    DW      90 
236B 69662061   =1  5007    DB     'if a=2 then x=99' ,0DH
236F 3D322074   
2373 68656E20   
2377 783D3939   
LILBASIC        LilBasic (c)2002                                                                              PAGE 105

237B 0D         
237C 006E       =1  5008    DW      110 
237E 69662061   =1  5009    DB     'if a>4 then goto 30' ,0DH
2382 3E342074   
2386 68656E20   
238A 676F746F   
238E 2033300D   
2392 0078       =1  5010    DW      120 
2394 676F7375   =1  5011    DB     'gosub 1000' ,0DH
2398 62203130   
239C 30300D     
239F 0082       =1  5012    DW      130 
23A1 7A3D300D   =1  5013    DB     'z=0' ,0DH
23A5 008C       =1  5014    DW      140 
23A7 7A3D7A2B   =1  5015    DB     'z=z+1' ,0DH
23AB 310D       
23AD 0096       =1  5016    DW      150 
23AF 6966207A   =1  5017    DB     'if z<b then goto 140' ,0DH
23B3 3C622074   
23B7 68656E20   
23BB 676F746F   
23BF 20313430   
23C3 0D         
23C4 00A0       =1  5018    DW      160 
23C6 643D642B   =1  5019    DB     'd=d+1:pwm0=0' ,0DH
23CA 313A7077   
23CE 6D303D30   
23D2 0D         
23D3 00AA       =1  5020    DW      170 
23D5 69662064   =1  5021    DB     'if d<10 then goto 40' ,0DH
23D9 3C313020   
23DD 7468656E   
23E1 20676F74   
23E5 6F203430   
23E9 0D         
23EA 00B4       =1  5022    DW      180 
23EC 676F7375   =1  5023    DB     'gosub 2000' ,0DH
23F0 62203230   
23F4 30300D     
23F7 00BE       =1  5024    DW      190 
23F9 676F746F   =1  5025    DB     'goto 40' ,0DH
23FD 2034300D   
2401 03E8       =1  5026    DW      1000 
2403 52656D20   =1  5027    DB     'Rem Take a step' ,0DH
2407 54616B65   
240B 20612073   
240F 7465700D   
2413 03F2       =1  5028    DW      1010 
2415 70776D36   =1  5029    DB     'pwm6=x' ,0DH
2419 3D780D     
241C 03FC       =1  5030    DW      1020 
241E 70776D34   =1  5031    DB     'pwm4=x' ,0DH
2422 3D780D     
2425 0406       =1  5032    DW      1030 
2427 72657475   =1  5033    DB     'return' ,0DH
242B 726E0D     
242E 07D0       =1  5034    DW      2000 
2430 52656D20   =1  5035    DB     'Rem Change Direction' ,0DH
LILBASIC        LilBasic (c)2002                                                                              PAGE 106

2434 4368616E   
2438 67652044   
243C 69726563   
2440 74696F6E   
2444 0D         
2445 07DA       =1  5036    DW      2010 
2447 643D300D   =1  5037    DB     'd=0' ,0DH
244B 0BCC       =1  5038    DW      3020 
244D 72656D20   =1  5039    DB     'rem get random number' ,0DH
2451 67657420   
2455 72616E64   
2459 6F6D206E   
245D 756D6265   
2461 720D       
2463 0BD6       =1  5040    DW      3030 
2465 523D2864   =1  5041    DB     'R=(dbyte(R mod 101)+timer)mod 51' ,0DH
2469 62797465   
246D 2852206D   
2471 6F642031   
2475 3031292B   
2479 74696D65   
247D 72296D6F   
2481 64203531   
2485 0D         
2486 07F8       =1  5042    DW      2040 
2488 70776D30   =1  5043    DB     'pwm0=(R mod 8)+90' ,0DH
248C 3D285220   
2490 6D6F6420   
2494 38292B39   
2498 300D       
249A 0802       =1  5044    DW      2050 
249C 72657475   =1  5045    DB     'return' ,0DH
24A0 726E0D     
24A3 80         =1  5046    DB 80H
  0202          =1  5047    WALK_LEN EQU  514 
                    5048 +1 PFILE 'LED'
24A4 29EEF1F2       5049 +1         DB      029H,0EEH,0F1H,0F2H,'P','LED',00H
24A8 504C4544   
24AC 00         
                =1  5051    $INCLUDE(DEMOS\LED.ASM)
                =1  5052                                 ;LED.BAS
                =1  5053                                 ;-------
24AD 000A       =1  5054    DW      10 
24AF 52454D20   =1  5055    DB     'REM Basic LED demo program' ,0DH
24B3 42617369   
24B7 63204C45   
24BB 44206465   
24BF 6D6F2070   
24C3 726F6772   
24C7 616D0D     
24CA 0014       =1  5056    DW      20 
24CC 464F5220   =1  5057    DB     'FOR A=1 TO 254' ,0DH
24D0 413D3120   
24D4 544F2032   
24D8 35340D     
24DB 001E       =1  5058    DW      30 
24DD 433D410D   =1  5059    DB     'C=A' ,0DH
24E1 0028       =1  5060    DW      40 
LILBASIC        LilBasic (c)2002                                                                              PAGE 107

24E3 464F5220   =1  5061    DB     'FOR B=1 TO 8' ,0DH
24E7 423D3120   
24EB 544F2038   
24EF 0D         
24F0 0032       =1  5062    DW      50 
24F2 433D432A   =1  5063    DB     'C=C*2' ,0DH
24F6 320D       
24F8 003C       =1  5064    DW      60 
24FA 433D432B   =1  5065    DB     'C=C+(Z>255)' ,0DH
24FE 285A3E32   
2502 3535290D   
2506 0046       =1  5066    DW      70 
2508 433D4320   =1  5067    DB     'C=C MOD 256' ,0DH
250C 4D4F4420   
2510 3235360D   
2514 0050       =1  5068    DW      80 
2516 504F5254   =1  5069    DB     'PORT1=C' ,0DH
251A 313D430D   
251E 005A       =1  5070    DW      90 
2520 464F5220   =1  5071    DB     'FOR D=1 TO 10' ,0DH
2524 443D3120   
2528 544F2031   
252C 300D       
252E 0064       =1  5072    DW      100 
2530 4E455854   =1  5073    DB     'NEXT D' ,0DH
2534 20440D     
2537 006E       =1  5074    DW      110 
2539 4E455854   =1  5075    DB     'NEXT B' ,0DH
253D 20420D     
2540 0078       =1  5076    DW      120 
2542 4E455854   =1  5077    DB     'NEXT A' ,0DH
2546 20410D     
2549 0082       =1  5078    DW      130 
254B 474F544F   =1  5079    DB     'GOTO 20' ,0DH
254F 2032300D   
2553 80         =1  5080    DB 80H
  00A7          =1  5081    LED_LEN EQU  167 
                    5082 +1 PFILE 'HELLO'
2554 29EEF1F2       5083 +1         DB      029H,0EEH,0F1H,0F2H,'P','HELLO',00H
2558 5048454C   
255C 4C4F00     
                =1  5085    $INCLUDE(DEMOS\HELLO.ASM)
                =1  5086                                 ;HELLO.BAS
                =1  5087                                 ;---------
255F 000A       =1  5088    DW      10 
2561 52454D20   =1  5089    DB     'REM DEMO PROGRAM' ,0DH
2565 44454D4F   
2569 2050524F   
256D 4752414D   
2571 0D         
2572 0014       =1  5090    DW      20 
2574 464F5220   =1  5091    DB     'FOR X = 1 TO 100' ,0DH
2578 58203D20   
257C 3120544F   
2580 20313030   
2584 0D         
2585 001E       =1  5092    DW      30 
2587 464F5220   =1  5093    DB     'FOR Y = 1 TO X' ,0DH
LILBASIC        LilBasic (c)2002                                                                              PAGE 108

258B 59203D20   
258F 3120544F   
2593 20580D     
2596 0028       =1  5094    DW      40 
2598 4E455854   =1  5095    DB     'NEXT Y' ,0DH
259C 20590D     
259F 0032       =1  5096    DW      50 
25A1 3F224845   =1  5097    DB     '?"HELLO"' ,0DH
25A5 4C4C4F22   
25A9 0D         
25AA 003C       =1  5098    DW      60 
25AC 4E455854   =1  5099    DB     'NEXT X' ,0DH
25B0 20580D     
25B3 0046       =1  5100    DW      70 
25B5 464F5220   =1  5101    DB     'FOR X= 1 TO 100' ,0DH
25B9 583D2031   
25BD 20544F20   
25C1 3130300D   
25C5 0050       =1  5102    DW      80 
25C7 464F5220   =1  5103    DB     'FOR Y = 1 TO 101-X' ,0DH
25CB 59203D20   
25CF 3120544F   
25D3 20313031   
25D7 2D580D     
25DA 005A       =1  5104    DW      90 
25DC 4E455854   =1  5105    DB     'NEXT Y' ,0DH
25E0 20590D     
25E3 0064       =1  5106    DW      100 
25E5 3F224845   =1  5107    DB     '?"HELLO"' ,0DH
25E9 4C4C4F22   
25ED 0D         
25EE 006E       =1  5108    DW      110 
25F0 4E455854   =1  5109    DB     'NEXT X' ,0DH
25F4 20580D     
25F7 0078       =1  5110    DW      120 
25F9 474F544F   =1  5111    DB     'GOTO 20' ,0DH
25FD 2032300D   
2601 80         =1  5112    DB 80H
  00A3          =1  5113    HELLO_LEN EQU  163 
                    5114    
                    5115    END                                 ;END of code

VERSION 1.2h ASSEMBLY COMPLETE, 0 ERRORS FOUND
LILBASIC        LilBasic (c)2002                                                                              PAGE 109

ACC. . . . . . . . . . . . . . .  D ADDR  00E0H  PREDEFINED  
ADD_16 . . . . . . . . . . . . .  C ADDR  03F6H  
ADR_ER . . . . . . . . . . . . .  C ADDR  029DH  
AESLEN . . . . . . . . . . . . .    NUMB  00FFH  NOT USED  
AESP . . . . . . . . . . . . . .  D ADDR  001DH  
AESRAM . . . . . . . . . . . . .    NUMB  0000H  NOT USED  
AES_ER . . . . . . . . . . . . .  C ADDR  0FDDH  
ALPHAB . . . . . . . . . . . . .  C ADDR  0663H  
APND_1 . . . . . . . . . . . . .  C ADDR  03BAH  
APND_2 . . . . . . . . . . . . .  C ADDR  03DEH  
APND_4 . . . . . . . . . . . . .  C ADDR  03B8H  
APN_ER . . . . . . . . . . . . .  C ADDR  03E0H  
APOSTRO. . . . . . . . . . . . .  C ADDR  0C97H  NOT USED  
APPEND . . . . . . . . . . . . .  C ADDR  039DH  
ARUN . . . . . . . . . . . . . .  C ADDR  0AB4H  
AR_EXP . . . . . . . . . . . . .  C ADDR  103AH  
ASCTBL . . . . . . . . . . . . .  C ADDR  016BH  
AUTO . . . . . . . . . . . . . .  B ADDR  0051H  
AUTORUN. . . . . . . . . . . . .  C ADDR  00D6H  
B. . . . . . . . . . . . . . . .  D ADDR  00F0H  PREDEFINED  
BASCMD . . . . . . . . . . . . .  C ADDR  0ADCH  
BEL. . . . . . . . . . . . . . .    NUMB  0007H  
BIG_PROBLEM. . . . . . . . . . .  C ADDR  0549H  NOT USED  
BREAK_END. . . . . . . . . . . .  C ADDR  0C2DH  
BREAK_START. . . . . . . . . . .  C ADDR  0C1DH  NOT USED  
BS . . . . . . . . . . . . . . .    NUMB  0008H  
CALL_END . . . . . . . . . . . .  C ADDR  0BD5H  
CALL_START . . . . . . . . . . .  C ADDR  0BBFH  NOT USED  
CHAR . . . . . . . . . . . . . .    REG4         
CHAR_FLG . . . . . . . . . . . .  B ADDR  0059H  
CLEAR. . . . . . . . . . . . . .  C ADDR  0F51H  
CLS_END. . . . . . . . . . . . .  C ADDR  0CB7H  
CLS_START. . . . . . . . . . . .  C ADDR  0CA2H  NOT USED  
CMD_NG . . . . . . . . . . . . .  C ADDR  0AD9H  
CMPR . . . . . . . . . . . . . .  C ADDR  0554H  
CMPR_1 . . . . . . . . . . . . .  C ADDR  057EH  
CMPR_2 . . . . . . . . . . . . .  C ADDR  0584H  
CMPR_4 . . . . . . . . . . . . .  C ADDR  0575H  
CNTRET . . . . . . . . . . . . .  C ADDR  0154H  
CNTRL. . . . . . . . . . . . . .  C ADDR  0147H  
CNTR_2 . . . . . . . . . . . . .  C ADDR  014FH  
COND . . . . . . . . . . . . . .  C ADDR  0A3DH  
CONT . . . . . . . . . . . . . .  C ADDR  0A83H  
CONT_1 . . . . . . . . . . . . .  C ADDR  0AA6H  
COUT_1 . . . . . . . . . . . . .  C ADDR  0146H  
COUT_2 . . . . . . . . . . . . .  C ADDR  013EH  
COUT_3 . . . . . . . . . . . . .  C ADDR  0142H  
CR . . . . . . . . . . . . . . .    NUMB  000DH  
CREATE . . . . . . . . . . . . .  C ADDR  0390H  
CREA_1 . . . . . . . . . . . . .  C ADDR  039CH  
CTRL_R . . . . . . . . . . . . .    NUMB  0012H  
CURS_H . . . . . . . . . . . . .  D ADDR  0016H  
CURS_L . . . . . . . . . . . . .  D ADDR  0015H  
C_IN . . . . . . . . . . . . . .  C ADDR  0119H  
C_IN_END . . . . . . . . . . . .  C ADDR  0127H  
C_OUT. . . . . . . . . . . . . .  C ADDR  012AH  
C_SAVE . . . . . . . . . . . . .  D ADDR  0017H  
DD006. . . . . . . . . . . . . .  C ADDR  012AH  NOT USED  
LILBASIC        LilBasic (c)2002                                                                              PAGE 110

DD007. . . . . . . . . . . . . .  C ADDR  012DH  NOT USED  
DD008. . . . . . . . . . . . . .  C ADDR  0134H  NOT USED  
DD009. . . . . . . . . . . . . .  C ADDR  0137H  NOT USED  
DECIMAL. . . . . . . . . . . . .  C ADDR  0C7BH  
DEL. . . . . . . . . . . . . . .    NUMB  007FH  
DEMOPROG . . . . . . . . . . . .  C ADDR  20F6H  
DEMO_LEN . . . . . . . . . . . .    NUMB  01A2H  NOT USED  
DEST_H . . . . . . . . . . . . .    REG3         
DEST_L . . . . . . . . . . . . .    REG1         
DIV_1. . . . . . . . . . . . . .  C ADDR  051CH  
DIV_2. . . . . . . . . . . . . .  C ADDR  0527H  
DIV_LP . . . . . . . . . . . . .  C ADDR  04E9H  
DIV_NG . . . . . . . . . . . . .  C ADDR  052AH  
DIV_RP . . . . . . . . . . . . .  C ADDR  0500H  
DONE . . . . . . . . . . . . . .  C ADDR  07EBH  
DONE_1 . . . . . . . . . . . . .  C ADDR  07F3H  
DONE_2 . . . . . . . . . . . . .  C ADDR  07F7H  
DPH. . . . . . . . . . . . . . .  D ADDR  0083H  PREDEFINED  
DPL. . . . . . . . . . . . . . .  D ADDR  0082H  PREDEFINED  
DUP. . . . . . . . . . . . . . .  C ADDR  01F6H  NOT USED  
D_BLNK . . . . . . . . . . . . .  C ADDR  060FH  
E0 . . . . . . . . . . . . . . .  C ADDR  102DH  
E1 . . . . . . . . . . . . . . .  C ADDR  103DH  
E2 . . . . . . . . . . . . . . .  C ADDR  104BH  
E3 . . . . . . . . . . . . . . .  C ADDR  1059H  
E4 . . . . . . . . . . . . . . .  C ADDR  1068H  
E5 . . . . . . . . . . . . . . .  C ADDR  1078H  
EA . . . . . . . . . . . . . . .  B ADDR  00AFH  PREDEFINED  
ELN_H. . . . . . . . . . . . . .  D ADDR  001CH  
ELN_L. . . . . . . . . . . . . .  D ADDR  001BH  
ENDCLEAR . . . . . . . . . . . .  C ADDR  0F13H  
ENDLET . . . . . . . . . . . . .  C ADDR  0AF7H  
ENDLOCK. . . . . . . . . . . . .  C ADDR  0F00H  
ENDUNLOCK. . . . . . . . . . . .  C ADDR  0EEEH  
END_END. . . . . . . . . . . . .  C ADDR  0BE2H  
END_START. . . . . . . . . . . .  C ADDR  0BD5H  NOT USED  
ERRENT . . . . . . . . . . . . .  C ADDR  0A7BH  
ERROR. . . . . . . . . . . . . .  D ADDR  001AH  
ERROR_NP . . . . . . . . . . . .  C ADDR  0F92H  
ERROR_PR . . . . . . . . . . . .  C ADDR  0F94H  
ERROUT . . . . . . . . . . . . .  C ADDR  0F84H  
ESC. . . . . . . . . . . . . . .    NUMB  001BH  
ET0. . . . . . . . . . . . . . .  B ADDR  00A9H  PREDEFINED  
EXPR . . . . . . . . . . . . . .  C ADDR  102AH  
EXP_ER . . . . . . . . . . . . .  C ADDR  0FBDH  
EXP_OV . . . . . . . . . . . . .  C ADDR  03EBH  
EXTRAM . . . . . . . . . . . . .    NUMB  2000H  
FACT . . . . . . . . . . . . . .  C ADDR  10B9H  
FACT_1 . . . . . . . . . . . . .  C ADDR  10C6H  
FETBDN . . . . . . . . . . . . .  C ADDR  038BH  
FETCBY . . . . . . . . . . . . .  C ADDR  0385H  
FETCH. . . . . . . . . . . . . .  C ADDR  0339H  
FETDBY . . . . . . . . . . . . .  C ADDR  036CH  
FETDIR . . . . . . . . . . . . .  C ADDR  02AEH  
FETERR . . . . . . . . . . . . .  C ADDR  036AH  NOT USED  
FETJTB . . . . . . . . . . . . .  C ADDR  034DH  
FETRBI . . . . . . . . . . . . .  C ADDR  0372H  
FETSFR . . . . . . . . . . . . .  C ADDR  02B4H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 111

FETVAR . . . . . . . . . . . . .  C ADDR  0352H  
FETXBY . . . . . . . . . . . . .  C ADDR  037EH  
FET_0. . . . . . . . . . . . . .  C ADDR  033BH  
FET_1. . . . . . . . . . . . . .  C ADDR  0348H  
FILES_END. . . . . . . . . . . .  C ADDR  0E0BH  
FILES_EXIT . . . . . . . . . . .  C ADDR  0DEFH  
FILES_LOOK . . . . . . . . . . .  C ADDR  0DC0H  
FILES_START. . . . . . . . . . .  C ADDR  0D89H  NOT USED  
FILE_END . . . . . . . . . . . .  C ADDR  0C6CH  
FILE_ERROR . . . . . . . . . . .  C ADDR  0C69H  
FILE_START . . . . . . . . . . .  C ADDR  0C2DH  NOT USED  
FIN. . . . . . . . . . . . . . .  C ADDR  0A5CH  
FIND_COMP_C. . . . . . . . . . .  C ADDR  11A9H  
FIND_CONT. . . . . . . . . . . .  C ADDR  11BAH  NOT USED  
FIND_FILE. . . . . . . . . . . .  C ADDR  118EH  
FIND_LOOP. . . . . . . . . . . .  C ADDR  119AH  
FIND_NEXT_TAG. . . . . . . . . .  C ADDR  1164H  
FIND_NO_FILE . . . . . . . . . .  C ADDR  11BFH  
FLAGS. . . . . . . . . . . . . .  D ADDR  002BH  
FNDDON . . . . . . . . . . . . .  C ADDR  099BH  
FNDLBL . . . . . . . . . . . . .  C ADDR  0979H  
FND_1. . . . . . . . . . . . . .  C ADDR  0981H  
FOUND_FILE . . . . . . . . . . .  C ADDR  11C1H  
FULLLIST . . . . . . . . . . . .  C ADDR  0BF9H  
GETLN. . . . . . . . . . . . . .  C ADDR  082FH  
GETL_0 . . . . . . . . . . . . .  C ADDR  0835H  
GETL_1 . . . . . . . . . . . . .  C ADDR  083DH  
GETL_2 . . . . . . . . . . . . .  C ADDR  0885H  
GETL_3 . . . . . . . . . . . . .  C ADDR  087CH  
GETL_4 . . . . . . . . . . . . .  C ADDR  0873H  
GETL_5 . . . . . . . . . . . . .  C ADDR  085CH  
GETL_6 . . . . . . . . . . . . .  C ADDR  084DH  
GETL_7 . . . . . . . . . . . . .  C ADDR  0866H  
GETROM . . . . . . . . . . . . .  C ADDR  05D4H  
GET_BUF. . . . . . . . . . . . .  C ADDR  05C3H  
GET_C. . . . . . . . . . . . . .  C ADDR  05BBH  
GET_XTOP . . . . . . . . . . . .  C ADDR  126EH  
GOSUB_ST . . . . . . . . . . . .  C ADDR  0AFEH  NOT USED  
GOTO_ST. . . . . . . . . . . . .  C ADDR  0B0BH  
GO_COMMON. . . . . . . . . . . .  C ADDR  0B12H  
GO_END . . . . . . . . . . . . .  C ADDR  0B1DH  
GO_ERR . . . . . . . . . . . . .  C ADDR  0B1AH  
GO_ST. . . . . . . . . . . . . .  C ADDR  0AF7H  NOT USED  
HELLO_LEN. . . . . . . . . . . .    NUMB  00A3H  NOT USED  
HELPTEXT . . . . . . . . . . . .  C ADDR  127BH  
HELPTEXTCMD. . . . . . . . . . .  C ADDR  13BCH  
HELPTEXTFUNC . . . . . . . . . .  C ADDR  1849H  
HELPTEXTOPER . . . . . . . . . .  C ADDR  1947H  
HELPTEXTVARS . . . . . . . . . .  C ADDR  1C58H  
HELP_0 . . . . . . . . . . . . .  C ADDR  0D0FH  
HELP_1 . . . . . . . . . . . . .  C ADDR  0CB7H  NOT USED  
HELP_2 . . . . . . . . . . . . .  C ADDR  0CD4H  
HELP_3 . . . . . . . . . . . . .  C ADDR  0CE8H  
HELP_4 . . . . . . . . . . . . .  C ADDR  0CFCH  
HELP_END . . . . . . . . . . . .  C ADDR  0D1AH  
HELP_START . . . . . . . . . . .  C ADDR  0CB7H  NOT USED  
HEXDECIMAL . . . . . . . . . . .  C ADDR  0C6CH  NOT USED  
HEXDEC_END . . . . . . . . . . .  C ADDR  0C8AH  
LILBASIC        LilBasic (c)2002                                                                              PAGE 112

HEXMOD . . . . . . . . . . . . .  B ADDR  0054H  
HEXOUT . . . . . . . . . . . . .  C ADDR  017BH  NOT USED  
H_FLG. . . . . . . . . . . . . .  B ADDR  005DH  
IABS . . . . . . . . . . . . . .  C ADDR  0437H  
IADD . . . . . . . . . . . . . .  C ADDR  03EFH  
IAND . . . . . . . . . . . . . .  C ADDR  0410H  
ICPL . . . . . . . . . . . . . .  C ADDR  0448H  
IDIV . . . . . . . . . . . . . .  C ADDR  04C0H  
IDIV_0 . . . . . . . . . . . . .  C ADDR  04C2H  
IFDN_1 . . . . . . . . . . . . .  C ADDR  0802H  
IFDN_2 . . . . . . . . . . . . .  C ADDR  0806H  
IFDONE . . . . . . . . . . . . .  C ADDR  07FCH  
IFEXIT . . . . . . . . . . . . .  C ADDR  0B7DH  
IFST . . . . . . . . . . . . . .  C ADDR  0B5FH  NOT USED  
IF_FALSE . . . . . . . . . . . .  C ADDR  0B78H  
IF_TF. . . . . . . . . . . . . .  C ADDR  0B72H  
IINC . . . . . . . . . . . . . .  C ADDR  0465H  
IINC_1 . . . . . . . . . . . . .  C ADDR  0475H  
IMOD . . . . . . . . . . . . . .  C ADDR  04BCH  
IMPLEXT. . . . . . . . . . . . .  C ADDR  0ADCH  
IMPLST . . . . . . . . . . . . .  C ADDR  0AC8H  NOT USED  
IMUL . . . . . . . . . . . . . .  C ADDR  04ADH  
IMUL_ERR . . . . . . . . . . . .  C ADDR  0483H  
IMUL_MUL . . . . . . . . . . . .  C ADDR  0490H  
IMUL_SWAP. . . . . . . . . . . .  C ADDR  0486H  
INDEX. . . . . . . . . . . . . .  C ADDR  07A7H  
INDTBL . . . . . . . . . . . . .  C ADDR  0260H  
INIT . . . . . . . . . . . . . .  C ADDR  0952H  NOT USED  
INIT_LOOP_1. . . . . . . . . . .  C ADDR  095DH  
INNUM. . . . . . . . . . . . . .  C ADDR  0914H  
INPEXIT. . . . . . . . . . . . .  C ADDR  0BAFH  
INPUTST. . . . . . . . . . . . .  C ADDR  0B7DH  NOT USED  
INPUT_COMMA. . . . . . . . . . .  C ADDR  0B9CH  NOT USED  
INPUT_END. . . . . . . . . . . .  C ADDR  0BAAH  
INPUT_ERR. . . . . . . . . . . .  C ADDR  0BA7H  
INPUT_LOOP . . . . . . . . . . .  C ADDR  0B87H  
INPUT_SEMI . . . . . . . . . . .  C ADDR  0B96H  
INSL_1 . . . . . . . . . . . . .  C ADDR  0A11H  
INSRT. . . . . . . . . . . . . .  C ADDR  0A1AH  
INSR_1 . . . . . . . . . . . . .  C ADDR  0A23H  
INSR_2 . . . . . . . . . . . . .  C ADDR  0A26H  
INSR_4 . . . . . . . . . . . . .  C ADDR  0A3AH  
INSR_L . . . . . . . . . . . . .  C ADDR  0A00H  
INUM_0 . . . . . . . . . . . . .  C ADDR  091BH  
INUM_1 . . . . . . . . . . . . .  C ADDR  0937H  
INUM_2 . . . . . . . . . . . . .  C ADDR  0940H  
INUM_3 . . . . . . . . . . . . .  C ADDR  0926H  
INUM_4 . . . . . . . . . . . . .  C ADDR  092BH  
INUM_5 . . . . . . . . . . . . .  C ADDR  0932H  
INUM_6 . . . . . . . . . . . . .  C ADDR  0947H  
IOR. . . . . . . . . . . . . . .  C ADDR  041DH  
ISALPHA. . . . . . . . . . . . .  C ADDR  00F2H  
ISALPHANUM . . . . . . . . . . .  C ADDR  00E6H  
ISALPHANUM_NO. . . . . . . . . .  C ADDR  010AH  
ISALPHANUM_YES . . . . . . . . .  C ADDR  0108H  
ISLOWER. . . . . . . . . . . . .  C ADDR  00FEH  
ISUB . . . . . . . . . . . . . .  C ADDR  0401H  
IS_TAG . . . . . . . . . . . . .  C ADDR  1172H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 113

IXOR . . . . . . . . . . . . . .  C ADDR  042AH  
KILL_2 . . . . . . . . . . . . .  C ADDR  09A5H  
KILL_3 . . . . . . . . . . . . .  C ADDR  09B4H  
KILL_9 . . . . . . . . . . . . .  C ADDR  09BFH  
KILL_L . . . . . . . . . . . . .  C ADDR  099EH  
LABL_H . . . . . . . . . . . . .  D ADDR  0019H  
LABL_L . . . . . . . . . . . . .  D ADDR  0018H  
LED_LEN. . . . . . . . . . . . .    NUMB  00A7H  NOT USED  
LF . . . . . . . . . . . . . . .    NUMB  000AH  
LINI_1 . . . . . . . . . . . . .  C ADDR  081EH  
LISTEND. . . . . . . . . . . . .  C ADDR  0BFDH  
LISTSTART. . . . . . . . . . . .  C ADDR  0BE2H  NOT USED  
LIT. . . . . . . . . . . . . . .  C ADDR  0210H  
LIT_1. . . . . . . . . . . . . .  C ADDR  0223H  
LNDONE . . . . . . . . . . . . .  C ADDR  07F1H  
LOAD_BADFN . . . . . . . . . . .  C ADDR  0E37H  
LOAD_CARY. . . . . . . . . . . .  C ADDR  0E19H  
LOAD_END . . . . . . . . . . . .  C ADDR  0E4EH  
LOAD_EXIT. . . . . . . . . . . .  C ADDR  0E33H  NOT USED  
LOAD_PNTR. . . . . . . . . . . .  C ADDR  05B4H  
LOAD_START . . . . . . . . . . .  C ADDR  0E0BH  NOT USED  
LOCK . . . . . . . . . . . . . .  C ADDR  0F38H  
LP_CNT . . . . . . . . . . . . .    REG5         
LST. . . . . . . . . . . . . . .  C ADDR  0903H  
LSTLIN . . . . . . . . . . . . .  C ADDR  08E9H  
LSTL_1 . . . . . . . . . . . . .  C ADDR  0902H  
LSTL_2 . . . . . . . . . . . . .  C ADDR  08F9H  
LSTRET . . . . . . . . . . . . .  C ADDR  0911H  
LST_1. . . . . . . . . . . . . .  C ADDR  0908H  
L_CURS . . . . . . . . . . . . .  D ADDR  0013H  
L_INIT . . . . . . . . . . . . .  C ADDR  0819H  
MLCALL . . . . . . . . . . . . .  C ADDR  0A61H  
MODE . . . . . . . . . . . . . .  D ADDR  002AH  
MOD_FLG. . . . . . . . . . . . .  B ADDR  005CH  
MOVE_CONT. . . . . . . . . . . .  C ADDR  11D1H  
MOVE_CONT_2. . . . . . . . . . .  C ADDR  11EFH  
MOVE_P . . . . . . . . . . . . .  C ADDR  11C3H  
MOVE_ROM . . . . . . . . . . . .  C ADDR  11CFH  
MOVE_XRAM. . . . . . . . . . . .  C ADDR  11CCH  NOT USED  
MSKTBL . . . . . . . . . . . . .  C ADDR  02CEH  
MSK_PC . . . . . . . . . . . . .  C ADDR  02CBH  
MUL_16 . . . . . . . . . . . . .  C ADDR  0476H  
NEG. . . . . . . . . . . . . . .  C ADDR  044BH  
NEG_0. . . . . . . . . . . . . .  C ADDR  044EH  
NEG_IF_NEG . . . . . . . . . . .  C ADDR  0444H  
NEWEND . . . . . . . . . . . . .  C ADDR  0C1DH  
NEWSTART . . . . . . . . . . . .  C ADDR  0C07H  NOT USED  
NIBOUT . . . . . . . . . . . . .  C ADDR  015CH  
NIBO_1 . . . . . . . . . . . . .  C ADDR  0167H  
NIBO_2 . . . . . . . . . . . . .  C ADDR  0163H  
NIBO_3 . . . . . . . . . . . . .  C ADDR  016AH  
NLINE. . . . . . . . . . . . . .  C ADDR  0128H  
NL_NXT . . . . . . . . . . . . .  C ADDR  0820H  
NOTSYM . . . . . . . . . . . . .  C ADDR  07A5H  NOT USED  
NOTVAR . . . . . . . . . . . . .  C ADDR  0672H  
NOT_TAG. . . . . . . . . . . . .  C ADDR  118CH  
NO_PROBLEM . . . . . . . . . . .  C ADDR  054DH  
NO_SFR . . . . . . . . . . . . .    NUMB  000EH  
LILBASIC        LilBasic (c)2002                                                                              PAGE 114

NXT. . . . . . . . . . . . . . .  C ADDR  0823H  
NXT_1. . . . . . . . . . . . . .  C ADDR  082CH  
OPEN_1 . . . . . . . . . . . . .  C ADDR  09E5H  
OPEN_2 . . . . . . . . . . . . .  C ADDR  09F4H  
OPEN_3 . . . . . . . . . . . . .  C ADDR  09C5H  
OPEN_4 . . . . . . . . . . . . .  C ADDR  09D6H  
OPEN_5 . . . . . . . . . . . . .  C ADDR  09CEH  
OPEN_6 . . . . . . . . . . . . .  C ADDR  09F9H  
OPEN_L . . . . . . . . . . . . .  C ADDR  09C0H  
OV . . . . . . . . . . . . . . .  B ADDR  00D2H  PREDEFINED  
OV_ER. . . . . . . . . . . . . .  C ADDR  100EH  
OV_TST . . . . . . . . . . . . .  C ADDR  03E4H  
P0 . . . . . . . . . . . . . . .  D ADDR  0080H  PREDEFINED  
P2 . . . . . . . . . . . . . . .  D ADDR  00A0H  PREDEFINED  
PNTR_H . . . . . . . . . . . . .    REG2         
PNTR_L . . . . . . . . . . . . .    REG0         
POP_ACC. . . . . . . . . . . . .  C ADDR  01D6H  
POP_TOS. . . . . . . . . . . . .  C ADDR  01C1H  
PORT1. . . . . . . . . . . . . .  C ADDR  0676H  NOT USED  
PORT1_END. . . . . . . . . . . .  C ADDR  068AH  
PRINT_CHECK_SEMI . . . . . . . .  C ADDR  0B54H  
PRINT_COMMA. . . . . . . . . . .  C ADDR  0B51H  
PRINT_END. . . . . . . . . . . .  C ADDR  0B5BH  
PRINT_EXIT . . . . . . . . . . .  C ADDR  0B5FH  
PRINT_LOOP . . . . . . . . . . .  C ADDR  0B2FH  
PRINT_SEMI . . . . . . . . . . .  C ADDR  0B5DH  
PRINT_START. . . . . . . . . . .  C ADDR  0B1DH  NOT USED  
PRN. . . . . . . . . . . . . . .  C ADDR  0895H  
PRNHEX . . . . . . . . . . . . .  C ADDR  08C5H  
PRNH_1 . . . . . . . . . . . . .  C ADDR  08D6H  
PRNRET . . . . . . . . . . . . .  C ADDR  08E8H  
PRNTOS . . . . . . . . . . . . .  C ADDR  089DH  
PRN_1. . . . . . . . . . . . . .  C ADDR  08AEH  
PRT_MSK. . . . . . . . . . . . .  D ADDR  0028H  
PSW. . . . . . . . . . . . . . .  D ADDR  00D0H  PREDEFINED  
PUSH_C . . . . . . . . . . . . .  C ADDR  0586H  
PUSH_TOS . . . . . . . . . . . .  C ADDR  01DFH  
PUTROM . . . . . . . . . . . . .  C ADDR  0604H  
PUT_BUF. . . . . . . . . . . . .  C ADDR  05F3H  
PWM0 . . . . . . . . . . . . . .  D ADDR  0020H  
PWM1 . . . . . . . . . . . . . .  D ADDR  0021H  
PWM2 . . . . . . . . . . . . . .  D ADDR  0022H  
PWM3 . . . . . . . . . . . . . .  D ADDR  0023H  
PWM4 . . . . . . . . . . . . . .  D ADDR  0024H  
PWM5 . . . . . . . . . . . . . .  D ADDR  0025H  
PWM6 . . . . . . . . . . . . . .  D ADDR  0026H  
PWM7 . . . . . . . . . . . . . .  D ADDR  0027H  
PWM_E0 . . . . . . . . . . . . .  B ADDR  0040H  NOT USED  
PWM_E1 . . . . . . . . . . . . .  B ADDR  0041H  NOT USED  
PWM_E2 . . . . . . . . . . . . .  B ADDR  0042H  NOT USED  
PWM_E3 . . . . . . . . . . . . .  B ADDR  0043H  NOT USED  
PWM_E4 . . . . . . . . . . . . .  B ADDR  0044H  NOT USED  
PWM_E5 . . . . . . . . . . . . .  B ADDR  0045H  NOT USED  
PWM_E6 . . . . . . . . . . . . .  B ADDR  0046H  NOT USED  
PWM_E7 . . . . . . . . . . . . .  B ADDR  0047H  NOT USED  
RAMLIM . . . . . . . . . . . . .    NUMB  7FFFH  
RAMROM . . . . . . . . . . . . .  B ADDR  005EH  
RAM_INIT . . . . . . . . . . . .  C ADDR  0955H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 115

RAM_PROGRAM. . . . . . . . . . .  C ADDR  0C5AH  
RDCHDN . . . . . . . . . . . . .  C ADDR  05F0H  
READ_CHAR. . . . . . . . . . . .  C ADDR  05E5H  
READ_LABEL . . . . . . . . . . .  C ADDR  080AH  
RELOP. . . . . . . . . . . . . .  C ADDR  111DH  
REL_1. . . . . . . . . . . . . .  C ADDR  1128H  
REL_2. . . . . . . . . . . . . .  C ADDR  1134H  
REL_3. . . . . . . . . . . . . .  C ADDR  1140H  
REL_4. . . . . . . . . . . . . .  C ADDR  114BH  
REL_5. . . . . . . . . . . . . .  C ADDR  1157H  
REL_6. . . . . . . . . . . . . .  C ADDR  1162H  
REMARK_END . . . . . . . . . . .  C ADDR  0CA2H  
REMARK_START . . . . . . . . . .  C ADDR  0C8AH  NOT USED  
REREAD . . . . . . . . . . . . .  C ADDR  05F1H  
RETURN_END . . . . . . . . . . .  C ADDR  0BBFH  
RETURN_START . . . . . . . . . .  C ADDR  0BAFH  NOT USED  
REWIND . . . . . . . . . . . . .  C ADDR  058FH  
REWIND_FIND_FILE . . . . . . . .  C ADDR  05A4H  
REWROM . . . . . . . . . . . . .  C ADDR  0599H  
RI . . . . . . . . . . . . . . .  B ADDR  0098H  PREDEFINED  
RND. . . . . . . . . . . . . . .  C ADDR  052CH  
ROM_PROGRAM. . . . . . . . . . .  C ADDR  0C36H  NOT USED  
RSTR . . . . . . . . . . . . . .  C ADDR  0A54H  
RUNEND . . . . . . . . . . . . .  C ADDR  0C07H  
RUNMOD . . . . . . . . . . . . .  B ADDR  0053H  
RUNSTART . . . . . . . . . . . .  C ADDR  0BFDH  NOT USED  
RWXROM . . . . . . . . . . . . .  C ADDR  05A1H  
S8 . . . . . . . . . . . . . . .  C ADDR  0B5FH  NOT USED  
SAV. . . . . . . . . . . . . . .  C ADDR  0A4DH  
SAVE_BADFN . . . . . . . . . . .  C ADDR  0E83H  NOT USED  
SAVE_CARY. . . . . . . . . . . .  C ADDR  0E5CH  
SAVE_END . . . . . . . . . . . .  C ADDR  0EA2H  
SAVE_EXIT. . . . . . . . . . . .  C ADDR  0E81H  NOT USED  
SAVE_PNTR. . . . . . . . . . . .  C ADDR  05ADH  
SAVE_START . . . . . . . . . . .  C ADDR  0E4EH  NOT USED  
SAVE_XTOP. . . . . . . . . . . .  C ADDR  125BH  
SBUF . . . . . . . . . . . . . .  D ADDR  0099H  PREDEFINED  
SCON . . . . . . . . . . . . . .  D ADDR  0098H  PREDEFINED  
SEED_H . . . . . . . . . . . . .  D ADDR  0011H  
SEED_L . . . . . . . . . . . . .  D ADDR  0010H  
SEQ_FETCH. . . . . . . . . . . .  C ADDR  0335H  NOT USED  
SEQ_FLG. . . . . . . . . . . . .  B ADDR  005BH  
SEQ_STORE. . . . . . . . . . . .  C ADDR  02D6H  NOT USED  
SETRBI . . . . . . . . . . . . .  C ADDR  0328H  
SET_TAG. . . . . . . . . . . . .  C ADDR  11FDH  
SET_TAG_EOFN . . . . . . . . . .  C ADDR  124FH  NOT USED  
SET_TAG_JMP. . . . . . . . . . .  C ADDR  1239H  
SET_TAG_LOOP . . . . . . . . . .  C ADDR  123AH  
SFID_1 . . . . . . . . . . . . .  C ADDR  028FH  
SFID_2 . . . . . . . . . . . . .  C ADDR  0298H  
SFRTBL . . . . . . . . . . . . .  C ADDR  0228H  
SFR_ID . . . . . . . . . . . . .  C ADDR  028AH  
SGN_FLG. . . . . . . . . . . . .  B ADDR  005AH  
SKPLIN . . . . . . . . . . . . .  C ADDR  0619H  
SKPTXT . . . . . . . . . . . . .  C ADDR  061DH  
SP . . . . . . . . . . . . . . .  D ADDR  0081H  PREDEFINED  
SPACE. . . . . . . . . . . . . .    NUMB  0020H  
SPC. . . . . . . . . . . . . . .  C ADDR  0155H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 116

SPLIT_DBA. . . . . . . . . . . .  C ADDR  02BAH  
SPLSFR . . . . . . . . . . . . .  C ADDR  02C4H  
SP_BASE. . . . . . . . . . . . .    NUMB  002BH  
SP_INI . . . . . . . . . . . . .  C ADDR  00B6H  NOT USED  
START. . . . . . . . . . . . . .  C ADDR  0A7BH  
START_COMMAND_SEG. . . . . . . .  C ADDR  00CCH  NOT USED  
START_OF_PROGRAMS. . . . . . . .  C ADDR  20ECH  
STCLEAR. . . . . . . . . . . . .  C ADDR  0F00H  NOT USED  
STK_ER . . . . . . . . . . . . .  C ADDR  01F2H  
STLET. . . . . . . . . . . . . .  C ADDR  0ADCH  NOT USED  
STLOCK . . . . . . . . . . . . .  C ADDR  0EEEH  NOT USED  
STMT . . . . . . . . . . . . . .  C ADDR  0AB9H  
STORE. . . . . . . . . . . . . .  C ADDR  02DAH  
STOR_0 . . . . . . . . . . . . .  C ADDR  02DCH  
STOR_1 . . . . . . . . . . . . .  C ADDR  02EFH  
STRCBY . . . . . . . . . . . . .  C ADDR  032DH  
STRDBY . . . . . . . . . . . . .  C ADDR  0312H  
STRDIR . . . . . . . . . . . . .  C ADDR  02A0H  
STRJTB . . . . . . . . . . . . .  C ADDR  02F4H  
STRLEN . . . . . . . . . . . . .  D ADDR  0012H  
STROUT . . . . . . . . . . . . .  C ADDR  018BH  
STROUT2. . . . . . . . . . . . .  C ADDR  019DH  
STRO_1 . . . . . . . . . . . . .  C ADDR  018FH  
STRO_2 . . . . . . . . . . . . .  C ADDR  0199H  
STRRAM . . . . . . . . . . . . .    NUMB  0100H  NOT USED  
STRRBI . . . . . . . . . . . . .  C ADDR  0318H  
STRSFR . . . . . . . . . . . . .  C ADDR  02A8H  
STRTBL . . . . . . . . . . . . .  C ADDR  0236H  
STRVAR . . . . . . . . . . . . .  C ADDR  02F9H  
STRXBY . . . . . . . . . . . . .  C ADDR  032DH  
STUNLOCK . . . . . . . . . . . .  C ADDR  0EDAH  NOT USED  
SYN_ER . . . . . . . . . . . . .  C ADDR  0FF4H  
SYN_NG . . . . . . . . . . . . .  C ADDR  111AH  
S_INIT . . . . . . . . . . . . .  C ADDR  008CH  
T0_EXIT. . . . . . . . . . . . .  C ADDR  0087H  
TABCNT . . . . . . . . . . . . .  D ADDR  0014H  
TABSIZ . . . . . . . . . . . . .    NUMB  0008H  
TAG_FOUND. . . . . . . . . . . .  C ADDR  116EH  NOT USED  
TCHK0. . . . . . . . . . . . . .  C ADDR  005FH  NOT USED  
TCHK1. . . . . . . . . . . . . .  C ADDR  0064H  
TCHK2. . . . . . . . . . . . . .  C ADDR  0069H  
TCHK3. . . . . . . . . . . . . .  C ADDR  006EH  
TCHK4. . . . . . . . . . . . . .  C ADDR  0073H  
TCHK5. . . . . . . . . . . . . .  C ADDR  0078H  
TCHK6. . . . . . . . . . . . . .  C ADDR  007DH  
TCHK7. . . . . . . . . . . . . .  C ADDR  0082H  
TCLR0. . . . . . . . . . . . . .  C ADDR  0032H  NOT USED  
TCLR1. . . . . . . . . . . . . .  C ADDR  0037H  
TCLR2. . . . . . . . . . . . . .  C ADDR  003CH  
TCLR3. . . . . . . . . . . . . .  C ADDR  0041H  
TCLR4. . . . . . . . . . . . . .  C ADDR  0046H  
TCLR5. . . . . . . . . . . . . .  C ADDR  004BH  
TCLR6. . . . . . . . . . . . . .  C ADDR  0050H  
TCLR7. . . . . . . . . . . . . .  C ADDR  0055H  
TERM . . . . . . . . . . . . . .  C ADDR  1079H  
TERM_0 . . . . . . . . . . . . .  C ADDR  107CH  
TERM_1 . . . . . . . . . . . . .  C ADDR  108AH  
TERM_2 . . . . . . . . . . . . .  C ADDR  1098H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 117

TERM_3 . . . . . . . . . . . . .  C ADDR  10A8H  
TERM_4 . . . . . . . . . . . . .  C ADDR  10B8H  
TEST_PROGRAM . . . . . . . . . .  C ADDR  0C48H  
TH0. . . . . . . . . . . . . . .  D ADDR  008CH  PREDEFINED  
TH1. . . . . . . . . . . . . . .  D ADDR  008DH  PREDEFINED  
TI . . . . . . . . . . . . . . .  B ADDR  0099H  PREDEFINED  
TIMER0 . . . . . . . . . . . . .  D ADDR  001EH  
TIMER1 . . . . . . . . . . . . .  D ADDR  001FH  
TIMER_0. . . . . . . . . . . . .  C ADDR  0024H  
TMOD . . . . . . . . . . . . . .  D ADDR  0089H  PREDEFINED  
TMP0 . . . . . . . . . . . . . .  D ADDR  0008H  
TMP1 . . . . . . . . . . . . . .  D ADDR  0009H  
TMP2 . . . . . . . . . . . . . .  D ADDR  000AH  
TMP3 . . . . . . . . . . . . . .  D ADDR  000BH  
TMP4 . . . . . . . . . . . . . .  D ADDR  000CH  
TMP5 . . . . . . . . . . . . . .  D ADDR  000DH  
TMP6 . . . . . . . . . . . . . .  D ADDR  000EH  NOT USED  
TMP7 . . . . . . . . . . . . . .  D ADDR  000FH  NOT USED  
TMP_0. . . . . . . . . . . . . .  B ADDR  0048H  NOT USED  
TMP_1. . . . . . . . . . . . . .  B ADDR  0049H  NOT USED  
TMP_2. . . . . . . . . . . . . .  B ADDR  004AH  NOT USED  
TMP_3. . . . . . . . . . . . . .  B ADDR  004BH  NOT USED  
TMP_4. . . . . . . . . . . . . .  B ADDR  004CH  NOT USED  
TMP_5. . . . . . . . . . . . . .  B ADDR  004DH  NOT USED  
TMP_6. . . . . . . . . . . . . .  B ADDR  004EH  NOT USED  
TMP_7. . . . . . . . . . . . . .  B ADDR  004FH  NOT USED  
TMP_MSK. . . . . . . . . . . . .  D ADDR  0029H  
TOKEN. . . . . . . . . . . . . .  C ADDR  0ABDH  
TOS_H. . . . . . . . . . . . . .    REG7         
TOS_L. . . . . . . . . . . . . .    REG6         
TO_CHK . . . . . . . . . . . . .  C ADDR  005DH  
TO_CLR . . . . . . . . . . . . .  C ADDR  0030H  NOT USED  
TR0. . . . . . . . . . . . . . .  B ADDR  008CH  PREDEFINED  
TR1. . . . . . . . . . . . . . .  B ADDR  008EH  PREDEFINED  
TRAM_OK. . . . . . . . . . . . .  C ADDR  00A7H  
TST. . . . . . . . . . . . . . .  C ADDR  0623H  
TSTN . . . . . . . . . . . . . .  C ADDR  07B7H  
TSTN_1 . . . . . . . . . . . . .  C ADDR  07C0H  
TSTS . . . . . . . . . . . . . .  C ADDR  07CCH  
TSTS_1 . . . . . . . . . . . . .  C ADDR  07DCH  
TSTS_2 . . . . . . . . . . . . .  C ADDR  07E3H  
TSTV . . . . . . . . . . . . . .  C ADDR  0654H  
TSTV_1 . . . . . . . . . . . . .  C ADDR  07ACH  
TST_1. . . . . . . . . . . . . .  C ADDR  062FH  
TST_CBYTE. . . . . . . . . . . .  C ADDR  0799H  NOT USED  
TST_CBYTE_END. . . . . . . . . .  C ADDR  07A5H  
TST_DBYTE. . . . . . . . . . . .  C ADDR  0770H  NOT USED  
TST_DBYTE_END. . . . . . . . . .  C ADDR  077EH  
TST_ERROR. . . . . . . . . . . .  C ADDR  068AH  NOT USED  
TST_ERROR_END. . . . . . . . . .  C ADDR  069EH  
TST_FREQ . . . . . . . . . . . .  C ADDR  06B2H  NOT USED  
TST_FREQ_END . . . . . . . . . .  C ADDR  06C5H  
TST_MASK . . . . . . . . . . . .  C ADDR  06C5H  NOT USED  
TST_MASK_END . . . . . . . . . .  C ADDR  06D8H  
TST_PWM0 . . . . . . . . . . . .  C ADDR  06D8H  NOT USED  
TST_PWM1 . . . . . . . . . . . .  C ADDR  06EBH  
TST_PWM2 . . . . . . . . . . . .  C ADDR  06FEH  
TST_PWM3 . . . . . . . . . . . .  C ADDR  0711H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 118

TST_PWM4 . . . . . . . . . . . .  C ADDR  0724H  
TST_PWM5 . . . . . . . . . . . .  C ADDR  0737H  
TST_PWM6 . . . . . . . . . . . .  C ADDR  074AH  
TST_PWM7 . . . . . . . . . . . .  C ADDR  075DH  
TST_PWM_END. . . . . . . . . . .  C ADDR  0770H  
TST_RBIT . . . . . . . . . . . .  C ADDR  077EH  NOT USED  
TST_RBIT_END . . . . . . . . . .  C ADDR  078BH  
TST_TIMER. . . . . . . . . . . .  C ADDR  069EH  NOT USED  
TST_TIMER_END. . . . . . . . . .  C ADDR  06B2H  
TST_XBYTE. . . . . . . . . . . .  C ADDR  078BH  NOT USED  
TST_XBYTE_END. . . . . . . . . .  C ADDR  0799H  
T_BAD. . . . . . . . . . . . . .  C ADDR  0647H  
T_GOOD . . . . . . . . . . . . .  C ADDR  0643H  
UNLOCK . . . . . . . . . . . . .  C ADDR  0F13H  
UNUSED . . . . . . . . . . . . .  B ADDR  0050H  NOT USED  
UPPER. . . . . . . . . . . . . .  C ADDR  010CH  
UPPER_EXIT . . . . . . . . . . .  C ADDR  0118H  
VAR. . . . . . . . . . . . . . .  C ADDR  10D5H  
VARRAM . . . . . . . . . . . . .    NUMB  1C00H  
VAR_0. . . . . . . . . . . . . .  C ADDR  10DEH  
VAR_1. . . . . . . . . . . . . .  C ADDR  10E4H  
VAR_1A . . . . . . . . . . . . .  C ADDR  10FCH  
VAR_2. . . . . . . . . . . . . .  C ADDR  110BH  
VERS . . . . . . . . . . . . . .    NUMB  0030H  
VER_END. . . . . . . . . . . . .  C ADDR  0D89H  
VER_MSG. . . . . . . . . . . . .  C ADDR  0D2AH  
VER_ST . . . . . . . . . . . . .  C ADDR  0D1AH  NOT USED  
WAIT1MS. . . . . . . . . . . . .  C ADDR  01A6H  NOT USED  
WAIT1MS_LOOP2. . . . . . . . . .  C ADDR  01AEH  
WAIT3MS. . . . . . . . . . . . .  C ADDR  01BAH  NOT USED  
WAIT5MS. . . . . . . . . . . . .  C ADDR  01B6H  
WAITMS . . . . . . . . . . . . .  C ADDR  01A8H  
WALK_LEN . . . . . . . . . . . .    NUMB  0202H  NOT USED  
WIPEALL_CONT . . . . . . . . . .  C ADDR  0ECEH  
WIPEALL_END. . . . . . . . . . .  C ADDR  0EDAH  
WIPEALL_LOOP . . . . . . . . . .  C ADDR  0EBEH  
WIPEALL_START. . . . . . . . . .  C ADDR  0EA2H  NOT USED  
WRCH_1 . . . . . . . . . . . . .  C ADDR  060EH  
WRITE_CHAR . . . . . . . . . . .  C ADDR  0607H  
XAUTO. . . . . . . . . . . . . .  B ADDR  0052H  
XEC. . . . . . . . . . . . . . .  C ADDR  0AB7H  
XFER . . . . . . . . . . . . . .  C ADDR  0A43H  
XFERNG . . . . . . . . . . . . .  C ADDR  0A4AH  
XINIT. . . . . . . . . . . . . .  C ADDR  0970H  
XRAD_1 . . . . . . . . . . . . .  C ADDR  03C4H  
XRAM . . . . . . . . . . . . . .    NUMB  8002H  
XTOP . . . . . . . . . . . . . .    NUMB  8000H  
YES_TAG. . . . . . . . . . . . .  C ADDR  118AH  NOT USED  
ZERSUP . . . . . . . . . . . . .  B ADDR  0058H  
