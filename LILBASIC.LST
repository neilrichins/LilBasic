LILBASIC        LilBasic (c)2002                                                                              PAGE 1

                       1    ;
                       2    ;
                       3    ;           LIL'BASIC INTERPRETER
                       4    ;       LIL'BASIC INTERPRETER PROGRAM
                       5    ;       ==============================
  0032                 6    VERS    EQU     32H
                       7    
                       8    $MOD51                          ;8051 Registers
                       9    $NODEBUG                        ;No Emulateion code
                      10    $TITLE(LilBasic (c)2002)
                      11    
                      12    ;======================================================================================
                      13    ;                          Macros!
                      14    ;======================================================================================
                      15    ;IJMP   (LBL)
                      16    ;       Jump to the (potentially distant) IL instruction at location LBL.
                      17    ;Note:  In this implementation IL addresses are equivalent to machine
                      18    ;       language addresses, so IJMP performs a generic JMP.
                      19    ;
                      20    ;
                      21    ;===============
                      22    ;
                      23    ;HOP    (LBL)
                      24    ;       Perform a branch to the IL instruction at (nearby) location LBL.
                      25    ;Note:  In this implementation IL addresses are equivalent to machine
                      26    ;       language addresses, so HOP performs a simple relative SJMP.
                      27    ;
                      28    ;
                      29    ;===============
                      30    ;
                      31    ;ICALL  (LBL)
                      32    ;       Call the IL subroutine starting at instruction LBL.
                      33    ;       Save the location of the next IL instruction on the control stack.
                      34    ;Note:  In this implementation, IL addresses are identical with
                      35    ;       machine language addresses, and are saved on the MCS-51 hardware stack.
                      36    ;
                      37    ;
                      38    ;===============
                      39    ;
                      40    ;IRET
                      41    ;       Return from IL subroutine to location on top of control stack.
                      42    ;Note:  In this implementation, IL addresses are identical with machine
                      43    ;       language addresses, which are saved on the hardware stack.
                      44    ;
                      45    ;
                =1    46    $INCLUDE(MACROS\MACROS.ASM)
                =1    47    PFILE   MACRO   NAME
                =1    48            DB      029H,0EEH,0F1H,0F2H,'P',NAME,00H
                =1    49            ENDM
                =1    50    DFILE   MACRO   NAME
                =1    51            DB      029H,0EEH,0F1H,0F2H,'D',NAME,00H
                =1    52            ENDM
                =1    53    
                =1    54    PAGE    MACRO   PG
                =1    55            MOV     P2,PG
                =1    56            ENDM
                =1    57    
                =1    58    
LILBASIC        LilBasic (c)2002                                                                              PAGE 2

                =1    59    LIT_    MACRO   K
                =1    60            CALL    LIT
                =1    61            DB      K
                =1    62            ENDM
                =1    63    
                =1    64    TSTV_   MACRO   LBL
                =1    65            CALL    TSTV
                =1    66            JNC     LBL
                =1    67            ENDM
                =1    68    
                =1    69    TSTN_   MACRO   LBL
                =1    70            CALL    TSTN
                =1    71            JNC     LBL
                =1    72            ENDM
                =1    73    
                =1    74    TSTL_   MACRO   LBL
                =1    75            CALL    TSTN
                =1    76            JNC     LBL
                =1    77            ENDM
                =1    78    
                =1    79    TSTS_   MACRO   LBL
                =1    80            CALL    TSTS
                =1    81            JC      LBL
                =1    82            ENDM
                =1    83    
                =1    84    IFDONE_ MACRO   LBL
                =1    85            CALL    IFDONE
                =1    86            JNC     LBL
                =1    87            ENDM
                =1    88    
                =1    89    LINIT_  MACRO
                =1    90            CALL   L_INIT
                =1    91            JC      ERRENT
                =1    92            ENDM
                =1    93    
                =1    94    COND_   MACRO   LBL
                =1    95            CALL   COND
                =1    96            JNC    LBL
                =1    97            ENDM
                =1    98    
                =1    99    NEXT_LOOP_       MACRO   LBL
                =1   100            CALL   LOOP
                =1   101            JC     LBL
                =1   102            ENDM
                =1   103    
                =1   104    IJMP_   MACRO   LBL
                =1   105            JMP     LBL
                =1   106            ENDM
                =1   107    
                =1   108    HOP_    MACRO   LBL
                =1   109            SJMP    LBL
                =1   110            ENDM
                =1   111    
                =1   112    ICALL_  MACRO   LBL
                =1   113            CALL    LBL
                =1   114            ENDM
                =1   115    
                =1   116    MLCALL_ MACRO
LILBASIC        LilBasic (c)2002                                                                              PAGE 3

                =1   117            CALL    MLCALL
                =1   118            ANL     PSW,#11100111B
                =1   119            ENDM
                     120    
                     121    
                     122    ;======================================================================================
                     123    ;       GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
                     124    ;======================================================================================;
                     125    ;               Intended System Configuration Constants:
                     126    
  0000               127    AESRAM  EQU     0000H           ;AES STACK 256 Bytes... BIG stack !
  0100               128    STRRAM  EQU     0100H           ;String memory 26vars * 256 bytes = 6656 or 1A00
  1C00               129    VARRAM  EQU     1C00H           ;Start of memory for INT Variables
  2000               130    EXTRAM  EQU     2000H           ;Start of program buffer.
  7FFF               131    RAMLIM  EQU     7FFFH           ;Top of Program ram = 32K.
  8000               132    XTOP    EQU     8000H           ;Address of 2 byte pointer to top of XRAM
  8002               133    XRAM    EQU     8002H           ;Start of MFS ram Area
  0008               134    TABSIZ  EQU     8               ;Formatted column spacing.
  00FF               135    AESLEN  EQU     0FFH            ;AES Length = 256 bytes!!!!
                     136    
                     137    ;===========================================================================================
                                                                               ========
                     138    
                     139    ;       Working Register Definitions.
                     140    ;
                     141    PNTR_L  EQU     R0              ;Program buffer pointer.
                     142    DEST_L  EQU     R1              ;Destination pointer for line insertion.
                     143    PNTR_H  EQU     R2              ;High-order pointer byte (temp. cursor)
                     144    DEST_H  EQU     R3
                     145    CHAR    EQU     R4              ;BASIC source string character being parsed.
                     146    LP_CNT  EQU     R5
                     147    TOS_L   EQU     R6              ;Variable popped from stack for math routines.
                     148    TOS_H   EQU     R7
                     149    
                     150    ; First 8 bytes reserved for R1 to R8
                     151    ;                               START OF DATA SEGMENT  128 Bytes !!!
                     152    
                     153    
                     154    ;
----                 155            DSEG
0008                 156            ORG     08H
                     157    ;
                     158    ;       Temporary variables used in MUL,DIV and other routines.
                     159    ;
0008                 160    TMP0:   DS      1
0009                 161    TMP1:   DS      1
000A                 162    TMP2:   DS      1
000B                 163    TMP3:   DS      1
000C                 164    TMP4:   DS      1
000D                 165    TMP5:   DS      1
000E                 166    TMP6:   DS      1               ; Not used in MUL or DIV reserved for use in basic commands.
                                                                               
000F                 167    TMP7:   DS      1               ; Not used in MUL or DIV reserved for use in basic commands.
                                                                               
                     168    
0010                 169    SEED_L: DS      1               ;Random number key.
0011                 170    SEED_H: DS      1
                     171    
LILBASIC        LilBasic (c)2002                                                                              PAGE 4

                     172    
0012                 173    STRLEN: DS      1               ;Length of text string in L_BUF.
                     174    
0013                 175    L_CURS: DS      1               ;Cursor for line buffer.
                     176    
0014                 177    TABCNT: DS      1               ;Column formatting count.
                     178    
0015                 179    CURS_L: DS      1               ;CURSOR Source line cursor.
0016                 180    CURS_H: DS      1
0017                 181    C_SAVE: DS      1               ;CHAR saved during SAVE_PNTR.
                     182    
0018                 183    LABL_L: DS      1               ;BASIC program source line counter.
0019                 184    LABL_H: DS      1               ;  "       "       "     high byte.
                     185    
001A                 186    ERROR:  DS      1               ;Error Code
001B                 187    ELN_L:  DS      1               ;Error Line number Low byte
001C                 188    ELN_H:  DS      1               ;Error Line number Low byte
001D                 189    AESP:   DS      1               ;AES Stack Pointer
                     190    
001E                 191    TIMER0: DS      1               ;Timer counter passed to basic
001F                 192    TIMER1: DS      1
                     193    
0020                 194    PWM0:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 1
0021                 195    PWM1:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 1
0022                 196    PWM2:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 2
0023                 197    PWM3:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 3
0024                 198    PWM4:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 4
0025                 199    PWM5:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 5
0026                 200    PWM6:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 6
0027                 201    PWM7:   DS      1               ;ON/OFF  THRESHOLD FOR PWM PIN 7
                     202    
                     203    ;===========================================================================================
                                                                               ========
0028                 204    PRT_MSK:DS      1               ;Port Mask (enabled pins for PWM )  (MUST BE AFTER ADDR 32 d
                                                                               ec/ 20 HEX)
                     205    
  0040               206    PWM_E0          BIT     PRT_MSK.0          ;Pin 0
  0041               207    PWM_E1          BIT     PRT_MSK.1          ;Pin 1
  0042               208    PWM_E2          BIT     PRT_MSK.2          ;pin 2
  0043               209    PWM_E3          BIT     PRT_MSK.3          ;Pin 3
  0044               210    PWM_E4          BIT     PRT_MSK.4          ;Pin 4
  0045               211    PWM_E5          BIT     PRT_MSK.5          ;Pin 5
  0046               212    PWM_E6          BIT     PRT_MSK.6          ;Pin 6
  0047               213    PWM_E7          BIT     PRT_MSK.7          ;Pin 7
                     214    
                     215    ;===========================================================================================
                                                                               ========
0029                 216    TMP_MSK:DS      1               ;Temporary mask for bit manulipation
                     217    
  0048               218    TMP_0          BIT     TMP_MSK.0
  0049               219    TMP_1          BIT     TMP_MSK.1
  004A               220    TMP_2          BIT     TMP_MSK.2
  004B               221    TMP_3          BIT     TMP_MSK.3
  004C               222    TMP_4          BIT     TMP_MSK.4
  004D               223    TMP_5          BIT     TMP_MSK.5
  004E               224    TMP_6          BIT     TMP_MSK.6
  004F               225    TMP_7          BIT     TMP_MSK.7
                     226    
LILBASIC        LilBasic (c)2002                                                                              PAGE 5

                     227    ;===========================================================================================
                                                                               ========
002A                 228    MODE:   DS      1               ;Operating mode bits.
                     229    
  0050               230    UNUSED          BIT     MODE.0          ;
  0051               231    AUTO            BIT     MODE.1          ; Set when BASIC programs auto executed.
  0052               232    XAUTO           BIT     MODE.2          ; Set when BASIC programs auto executed from XMEM.
  0053               233    RUNMOD          BIT     MODE.3          ; Set when stored BASIC program is running.
  0054               234    HEXMOD          BIT     MODE.4          ; Set when operations should use HEX radix.
                     235    
                     236    
                     237    ;===========================================================================================
                                                                               ========
002B                 238    FLAGS:  DS      1               ;Interroutine communication flags.  ;
                     239    
  0058               240    ZERSUP          BIT     FLAGS.0         ; If set, suppress printing leading zeroes.
  0059               241    CHAR_FLG        BIT     FLAGS.1         ; Set when CHAR has not been processed.
  005A               242    SGN_FLG         BIT     FLAGS.2         ; Keeps track of operand(s) sign during math.
  005B               243    SEQ_FLG         BIT     FLAGS.3         ;
  005C               244    MOD_FLG         BIT     FLAGS.4         ; Set if divide routine should return MOD value.
  005D               245    H_FLG           BIT     FLAGS.5         ; Used to sense allow 'H' suffix in HEX mode.
  005E               246    RAMROM          BIT     FLAGS.6         ; Set when moving program from ROM to RAM Clear = Fr
                                                                               om Ram to Ram
                     247    
                     248    ;===========================================================================================
                                                                               ========
                     249    ;
                     250    ;                       Start of Code Segment
                     251    ;
                     252    ;       Line Buffer Variables:
                     253    ;
  002B               254    SP_BASE EQU     $-1             ;Initialization value for hardware SP.   ( STACK = 34 TO 128
                                                                               )
                     255    ;
  000D               256    CR      EQU     0DH             ;ASCII CODE FOR <CARRIAGE RETURN>.
  000A               257    LF      EQU     0AH             ;  "    "    "  <LINE FEED>.
  0007               258    BEL     EQU     07H             ;  "    "    "  <BELL>.
  001B               259    ESC     EQU     1BH             ;  "    "    "  <ESC>
  0008               260    BS      EQU     08H             ;  "    "    "  <BS>
  0020               261    SPACE   EQU     20H             ;  "    "    "  <SPACE>
  0012               262    CTRL_R  EQU     12H             ;  "    "    "  <CTRL> <R>
  007F               263    DEL     EQU     7FH             ;  "    "    "  <DEL>
                     264    ;
                     265    ;$SAVE NOGEN
                     266    ;===========================================================================================
                                                                               ========
                     267    ;
                     268    ;       Interrupt routine expansion hooks:
                     269    ;
                     270    ;===========================================================================================
                                                                               ========
                     271    
----                 272            CSEG
0000                 273            ORG     0000H           ;System initialization / reset routine.
0000 02008C          274            JMP     S_INIT
                     275    
0003                 276            ORG     0003H           ;External interrupt 0 service routine.
0003 32              277            RETI
LILBASIC        LilBasic (c)2002                                                                              PAGE 6

                     278    
000B                 279            ORG     000BH           ;Timer 0 service routine.
000B 020024          280            JMP    TIMER_0
                     281    
0013                 282            ORG     0013H           ;External interrupt 1 service routine.
0013 32              283            RETI
                     284    
001B                 285            ORG     001BH           ;Timer 1 service routine.
001B 32              286            RETI
                     287    
0023                 288            ORG     0023H           ;Serial port interrupt service routine.
0023 32              289            RETI
                     290    
                =1   291    $INCLUDE(INT\TIMER0.ASM)  ;Timer 0  Auto reload timer used for PWM
                =1   292    ;===================================================================
                =1   293    ;I          TIMER 0 INTERRUPT VECTOR --> PWM   9216.Hz/255
                =1   294    ;===================================================================
0024            =1   295    TIMER_0:
0024 C0D0       =1   296            PUSH    PSW                     ;Save Flags
0026 C0E0       =1   297            PUSH    Acc                     ;Save Acc so we can use it
0028 D51E32     =1   298            DJNZ    TIMER0,TO_CHK           ;Bump counter, if TIMER not 0 then Check to see if t
                                                                               ime to toggle PWM
002B 051F       =1   299            INC     TIMER1                  ;Else increase timer 1
002D 751E64     =1   300            MOV     TIMER0,#100             ;Reset Timer0 back to 100 (1% to 99% threshold)
                =1   301    
                =1   302    ; Toggle all pins being used for PWM to 'reset' them
0030            =1   303    TO_CLR:
0030 7464       =1   304            MOV     A,#100                  ;Preload A with FF for easy compairson
                =1   305    
0032            =1   306    TCLR0:
0032 B52002     =1   307            CJNE    A,PWM0,TCLR1            ;Skip if not used
0035 B280       =1   308            cpl     P0.0                    ;Else set bit
                =1   309    
0037            =1   310    TCLR1:
0037 B52102     =1   311            CJNE    A,PWM1,TCLR2           ;Skip if not used
003A B281       =1   312            cpl     P0.1                   ;Toggle pin 1
                =1   313    
                =1   314    
003C            =1   315    TCLR2:
003C B52202     =1   316            CJNE    A,PWM2,TCLR3           ;Skip if not used
003F B282       =1   317            cpl     P0.2                   ;Toggle pin 2
                =1   318    
                =1   319    
0041            =1   320    TCLR3:
0041 B52302     =1   321            CJNE    A,PWM3,TCLR4           ;Skip if not used
0044 B283       =1   322            cpl     P0.3                   ;Toggle pin 3
                =1   323    
0046            =1   324    TCLR4:
0046 B52402     =1   325            CJNE    A,PWM4,TCLR5            ;Skip if not used
0049 B284       =1   326            cpl     P0.4                    ;Toggle pin 4
                =1   327    
004B            =1   328    TCLR5:
004B B52502     =1   329            CJNE    A,PWM5,TCLR6            ;Skip if not used
004E B285       =1   330            cpl     P0.5                    ;Toggle pin 6
                =1   331    
0050            =1   332    TCLR6:
0050 B46402     =1   333            CJNE    A,#100,TCLR7            ;Skip if not used
0053 B286       =1   334            cpl     P0.6                    ;Toggle pin 6
LILBASIC        LilBasic (c)2002                                                                              PAGE 7

                =1   335    
0055            =1   336    TCLR7:
0055 B4642F     =1   337            CJNE    A,#100,T0_EXIT           ;Skip if not used
0058 B287       =1   338            cpl     P0.7                    ;Toggle pin 7
005A 020087     =1   339            JMP     T0_EXIT                 ;Restore vars & exit
                =1   340    
                =1   341    ; Check all 8 pins to see if they need toggled.
005D            =1   342    TO_CHK:
005D E51E       =1   343            MOV     A,TIMER0                ;Copy TIMER0 to A for eazy access
                =1   344    
005F            =1   345    TCHK0:
005F B52002     =1   346            CJNE    A,PWM0,TCHK1            ;Skip if not at threshold
0062 B280       =1   347            cpl     P0.0                    ;Else set bit
                =1   348    
0064            =1   349    TCHK1:
0064 B52102     =1   350            CJNE    A,PWM1,TCHK2            ;Skip if not at threshold
0067 B281       =1   351            cpl     P0.1                    ;Toggle pin 1
                =1   352    
                =1   353    
0069            =1   354    TCHK2:
0069 B52202     =1   355            CJNE    A,PWM2,TCHK3            ;Skip if not at threshold
006C B282       =1   356            cpl     P0.2                    ;Toggle pin 2
                =1   357    
006E            =1   358    TCHK3:
006E B52302     =1   359            CJNE    A,PWM3,TCHK4            ;Skip if not at threshold
0071 B283       =1   360            cpl     P0.3                    ;Toggle pin 3
                =1   361    
0073            =1   362    TCHK4:
0073 B52402     =1   363            CJNE    A,PWM4,TCHK5            ;Skip if not at threshold
0076 B284       =1   364            cpl     P0.4                    ;Toggle pin 4
                =1   365    
0078            =1   366    TCHK5:
0078 B52502     =1   367            CJNE    A,PWM5,TCHK6            ;Skip if not at threshold
007B B285       =1   368            cpl     P0.5                    ;Toggle pin 6
                =1   369    
007D            =1   370    TCHK6:
007D B52602     =1   371            CJNE    A,PWM6,TCHK7            ;Skip if not at threshold
0080 B286       =1   372            cpl     P0.6                    ;Toggle pin 6
                =1   373    
0082            =1   374    TCHK7:
0082 B52702     =1   375            CJNE    A,PWM7,T0_EXIT          ;Skip if not at threshold
0085 B287       =1   376            cpl     P0.7                    ;Toggle pin 7
                =1   377    
0087            =1   378    T0_EXIT:
0087 D0E0       =1   379            POP     Acc                     ;Restore Acc
0089 D0D0       =1   380            POP     PSW                     ;Restore Flags
008B 32         =1   381            RETI                            ;Exit
                =1   382    $INCLUDE(INT\RESET.ASM)   ;Power Up and Reset
                =1   383    ;===================================================================
                =1   384    ;I                 RESET INTERRUPT VECTOR                          I
                =1   385    ;===================================================================
008C            =1   386    S_INIT:
                =1   387    
008C 758C0F     =1   388            MOV     TH0,#0FH        ;Load Timer0 overload value for timer 0 (1/120 th sec)
008F D2AF       =1   389            SETB    EA              ;Enable interupts
0091 D2A9       =1   390            SETB    ET0             ;Enable Timer0 Interupt for TIMER
0093 D28C       =1   391            SETB    TR0             ;Enable Timer0 interrupt
                =1   392    
LILBASIC        LilBasic (c)2002                                                                              PAGE 8

0095 D252       =1   393            SETB    XAUTO           ;Default run program from shared Xmem
                =1   394    
0097 908002     =1   395            MOV     DPTR,#XRAM       ;Set DPTR to start of XRAM heap
009A 1211AC     =1   396            CALL    IS_TAG
009D 4008       =1   397            JC      TRAM_OK         ;If Tag at start of Xram, don't reset HEAP
009F 908002     =1   398            MOV     DPTR,#XRAM      ;No Program, so default NVram
00A2 121295     =1   399            CALL    SAVE_XTOP       ;Reset Xtop to start of XRAM heap
00A5 C252       =1   400            CLR     XAUTO           ;If no program in Xmem run from ROM
                =1   401    
                =1   402    
                =1   403    
00A7            =1   404     TRAM_OK:
                =1   405    
00A7 E4         =1   406            CLR     A
00A8 F5D0       =1   407            MOV     PSW,A
00AA F528       =1   408            MOV     PRT_MSK,A       ;Clear Port bit mask
00AC C253       =1   409            CLR     RUNMOD          ;Execution set to command line
00AE C254       =1   410            CLR     HEXMOD          ;Default I/O to Decimal
00B0 75812B     =1   411            MOV     SP,#SP_BASE     ;Initialize hardware stack.
00B3 751D00     =1   412            MOV     AESP,#0H        ;Initialize Arithmatic Expression Stack.
                =1   413    
                =1   414    
00B6            =1   415    SP_INI:
00B6 7890       =1   416            MOV     R0,#144
00B8 752B00     =1   417            MOV     FLAGS,#0         ;Interroutine flags.
                =1   418    
                =1   419    
00BB C28E       =1   420            CLR     TR1             ;
00BD 75985A     =1   421            MOV     SCON,#01011010B ;TI set indicates transmitter ready.
00C0 758922     =1   422            MOV     TMOD,#00100010B ;Timer 0 & 1 Set to auto-reload timer mode.
00C3 758DFD     =1   423            MOV     TH1,#0FDH       ;9600 bps.
00C6 D28E       =1   424            SETB    TR1
                =1   425    
00C8 E51F       =1   426            MOV     A,TIMER1        ; If timer =0 then must be a powerup , Else Just a reset
00CA 600A       =1   427            JZ      AUTORUN
                =1   428    
                =1   429    
                =1   430    ;======================================================================================
                =1   431    ;
00CC            =1   432    START_COMMAND_SEG:
                =1   433    
00CC 120D57     =1   434            CALL    VER_MSG
00CF C251       =1   435            CLR     AUTO            ;Don't Auto Rum program
00D1 C252       =1   436            CLR     XAUTO           ;Don't Run program from shared Xmem
00D3 020A7A     =1   437            JMP     START
                =1   438    
                =1   439    ;======================================================================================
                =1   440    ;
00D6            =1   441    AUTORUN:
                =1   442                                            ;Clear Program in RAM space
00D6 758200     =1   443            MOV     DPL,#LOW(EXTRAM)        ;Move DPTR to beginning of program
00D9 758320     =1   444            MOV     DPH,#HIGH(EXTRAM)
00DC 74FF       =1   445            MOV     A,#0FFH                 ;Token for end of basic program
00DE F0         =1   446            MOVX    @DPTR,A                 ;Put END token at start of program
                =1   447    
00DF D251       =1   448            SETB    AUTO            ;Auto Rum program
00E1 D252       =1   449            SETB    XAUTO           ;Default run program from shared Xmem
00E3 020AB6     =1   450            JMP     XEC
LILBASIC        LilBasic (c)2002                                                                              PAGE 9

                     451    ;===========================================================================================
                                                                               ========
                     452    ;                       Basic Input / Output Routines
                     453    ;===========================================================================================
                                                                               ========;
                     454    ;ISALPHANUM
                     455    ;       Evaluates A
                     456    ;               C is 0 if in  Alphanumeric range
                     457    ;               C is 1 if not
                     458    ;ISALPHA
                     459    ;       Evaluates A
                     460    ;               C is 0 if  'A' to 'Z' or 'a' to 'z'
                     461    ;               C is 1 if not
                     462    ;ISLOWER
                     463    ;       Evaluates A
                     464    ;               C is 0 if Lowercase
                     465    ;               C is 1 if not
                     466    ;
                     467    ; USES: nothing
                =1   468    $INCLUDE(BIOS\ALPHANUM.ASM)
                =1   469    ;ISALPHANUM
                =1   470    ;       Evaluates A
                =1   471    ;               C is 1 if in  Alphanumeric range
                =1   472    ;               C is 0 if not
                =1   473    ;ISALPHA
                =1   474    ;       Evaluates A
                =1   475    ;               C is 1 if  'A' to 'Z' or 'a' to 'z'
                =1   476    ;               C is 0 if not
                =1   477    ;ISLOWER
                =1   478    ;       Evaluates A
                =1   479    ;               C is 1 if Lowercase
                =1   480    ;               C is 0 if not
                =1   481    ;
                =1   482    ; USES: nothing
                =1   483    
                =1   484    
                =1   485    
00E6            =1   486    ISALPHANUM:
                =1   487    
00E6 B43000     =1   488            CJNE    A,#'0',$+3                                      ; Is A < '0'
00E9 401F       =1   489            JC      ISALPHANUM_NO                                   ;
                =1   490    
00EB B43A1A     =1   491            CJNE    A,#'9'+1,ISALPHANUM_YES                         ; IS A > '9'
00EE 5002       =1   492            JNC     ISALPHA                                         ; Yes, then check if it is a
                                                                                letter
00F0 8016       =1   493            SJMP     ISALPHANUM_YES                                  ; No, must be a number '0' 
                                                                               to '9'
00F2            =1   494    ISALPHA:
00F2 B44100     =1   495            CJNE    A,#'A',$+3                                      ; Is A < 'A'
00F5 4013       =1   496            JC      ISALPHANUM_NO                                   ;
                =1   497    
00F7 B45B0E     =1   498            CJNE    A,#'Z'+1,ISALPHANUM_YES                         ; IS A > 'Z'
00FA 5002       =1   499            JNC     ISLOWER                                         ; Yes, then check if it is l
                                                                               owercase
00FC 800A       =1   500            SJMP     ISALPHANUM_YES                                  ; No, must be a Letter 'A' 
                                                                               to 'Z'
                =1   501    
00FE            =1   502    ISLOWER:
LILBASIC        LilBasic (c)2002                                                                              PAGE 10

00FE B46100     =1   503            CJNE    A,#'a',$+3                                      ; Is A < 'z'
0101 4007       =1   504            JC      ISALPHANUM_NO                                   ;
                =1   505    
0103 B47B04     =1   506            CJNE    A,#'z'+1,ISALPHANUM_NO                         ; IS A > 'z'
0106 5002       =1   507            JNC     ISALPHANUM_NO                                  ; Yes, then not in range.
                =1   508            ;SJMP     ISALPHANUM_YES                                 ; No, must be a Letter 'A' 
                                                                               to 'Z'
                =1   509    
0108            =1   510    ISALPHANUM_YES:
0108 D3         =1   511            SETB    C
0109 22         =1   512            RET
                =1   513    
010A            =1   514    ISALPHANUM_NO:
010A C3         =1   515            CLR     C
010B 22         =1   516            RET
                     517    
                     518    ;=======
                     519    
                     520    ;UPPER:
                     521    ;       Convert CHAR in Acc to uppercase !
                     522    ;
                =1   523    $INCLUDE(BIOS\UPPER.ASM)
                =1   524    
010C            =1   525    UPPER:                          ;Convert CHAR in ACC to uppercase !
010C B46100     =1   526            CJNE    A,#'a',$+3      ;Check for lower-case alphabetics.
010F 4007       =1   527            JC      UPPER_EXIT
0111 B47B00     =1   528            CJNE    A,#'z'+1,$+3
0114 5002       =1   529            JNC     UPPER_EXIT
0116 54DF       =1   530            ANL     A,#11011111B    ;Force to upper-case.
0118            =1   531    UPPER_EXIT:
0118 22         =1   532            RET
                     533    ;=======
                     534     ;C_IN:
                     535    ;       Console character input routine.
                     536    ;       Waits for next input from console device and returns with character
                     537    ;       code in accumulator.
                =1   538     $INCLUDE(BIOS\C_IN.ASM)
0119            =1   539    C_IN:
                =1   540    ;       Console character input routine.
                =1   541    ;       Waits for next input from console device and returns with character
                =1   542    ;       code in accumulator.
                =1   543    ;
                =1   544    ;
                =1   545    ;
0119 3098FD     =1   546            JNB     RI,$            ;Wait until character received.
011C E599       =1   547            MOV     A,SBUF          ;Read input character.
011E C298       =1   548            CLR     RI              ;Clear reception flag.
0120 547F       =1   549            ANL     A,#7FH          ;Mask off data bits.
0122 B40A02     =1   550            CJNE    A,#LF,C_IN_END  ;Proceee Linefeeds as Spaces
0125 7400       =1   551            MOV     A,#0
0127            =1   552    C_IN_END:
0127 22         =1   553            RET                     ;Return to calling routine.
                =1   554    ;
                     555    ;=======
                     556    ;NLINE: Transmit <CR><LF> sequence to console device.
                     557    ;C_OUT:
                     558    ;       Console character output routine.
                     559    ;       Outputs character received in accumulator to console output device.
LILBASIC        LilBasic (c)2002                                                                              PAGE 11

                =1   560    $INCLUDE(BIOS\C_OUT.ASM)
0128            =1   561    NLINE:
                =1   562    ;       Transmit <CR><LF> sequence to console device.
                =1   563    ;
0128 740D       =1   564            MOV     A,#CR
012A            =1   565    C_OUT:
                =1   566    ;       Console character output routine.
                =1   567    ;       Outputs character received in accumulator to console output device.
                =1   568    ;
012A 3099FD     =1   569    DD006:  JNB     TI,$            ;Wait until transmission completed.
012D C299       =1   570    DD007:  CLR     TI              ;Clear interrupt flag.
012F F599       =1   571            MOV     SBUF,A          ;Write out character.
0131 B40D0A     =1   572            CJNE    A,#CR,COUT_2
0134 3099FD     =1   573    DD008:  JNB     TI,$
0137 C299       =1   574    DD009:  CLR     TI
0139 75990A     =1   575            MOV     SBUF,#LF        ;Output linefeed.
013C 8004       =1   576            SJMP    COUT_3
                =1   577    ;
013E C3         =1   578    COUT_2: CLR     C
013F D51404     =1   579            DJNZ    TABCNT,COUT_1   ;Monitor output field position.
0142 751408     =1   580    COUT_3: MOV     TABCNT,#TABSIZ  ;Reload field counter.
0145 D3         =1   581            SETB    C
0146 22         =1   582    COUT_1: RET
                     583    ;=======
                     584    ;
                     585    ;
0147 30980A          586    CNTRL:  JNB     RI,CNTRET       ;Poll whether character has been typed.
014A 3119            587            CALL    C_IN
014C B41305          588            CJNE    A,#13H,CNTRET   ;Check if char. is <CNTRL-S>.
014F 3119            589    CNTR_2: CALL    C_IN            ;If so, hang up...
0151 B411FB          590            CJNE    A,#11H,CNTR_2   ;    ...until <CNTRL-Q> received.
0154 22              591    CNTRET: RET
                     592    ;
                     593    ;=======
                     594    ;SPC:
                     595    ;       Transmit one or more space characters to console to move console
                     596    ;       cursor to start of next field.
                =1   597    $INCLUDE(BIOS\TAB.ASM)
                =1   598    
0155            =1   599    SPC:
                =1   600    ;       Transmit one or more space characters to console to move console
                =1   601    ;       cursor to start of next field.
                =1   602    ;
0155 7420       =1   603            MOV     A,#SPACE         ;Load ASCII code for space character.
0157 312A       =1   604            CALL    C_OUT
0159 50FA       =1   605            JNC     SPC             ;Repeat until at TAB boundary.
015B 22         =1   606            RET
                =1   607    ;
                     608    ;===============
                     609    ;NIBOUT:
                     610    ;       If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
                     611    ;       output the corresponding ASCII value and clear ZERSUP flag.
                     612    ;       Otherwise return without affecting output or ZERSUP.
                =1   613    $INCLUDE(BIOS\NIBOUT.ASM)       ;USES C_OUT
                =1   614    ;
                =1   615    ;NIBOUT
                =1   616    ;       If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
                =1   617    ;       output the corresponding ASCII value and clear ZERSUP flag.
LILBASIC        LilBasic (c)2002                                                                              PAGE 12

                =1   618    ;       Otherwise return without affecting output or ZERSUP.
                =1   619    ;
015C 540F       =1   620    NIBOUT: ANL     A,#0FH          ;Mask out low-order bits.
015E 7003       =1   621            JNZ     NIBO_2          ;Output ASCII code for Acc contents.
0160 205807     =1   622            JB      ZERSUP,NIBO_3
0163 C258       =1   623    NIBO_2: CLR     ZERSUP          ;Mark that non-zero character encountered.
0165 2403       =1   624            ADD     A,#(ASCTBL-(NIBO_1+1))  ;Offset to start of table.
0167 83         =1   625    NIBO_1: MOVC    A,@A+PC         ;Look up corresponding code.
0168 312A       =1   626            CALL    C_OUT           ;Output character.
016A 22         =1   627    NIBO_3: RET
                =1   628    ;
016B 30313233   =1   629    ASCTBL: DB      '0123456789ABCDEF'
016F 34353637   
0173 38394142   
0177 43444546   
                =1   630    ;
                     631    
                     632    ;
                     633    ;HEXOUT:
                     634    ;       Output Hexdecimal value in ACC
                     635    ;       USES   TMP0
                     636    ;       CALLS   NIBOUT
                =1   637    $INCLUDE(BIOS\HEXOUT.ASM)
                =1   638    ;
                =1   639    ;HEXOUT:
                =1   640    ;       Output Hexdecimal value in ACC
                =1   641    ;USES   TMP0
                =1   642    
017B            =1   643    HEXOUT:
017B F508       =1   644            MOV TMP0,A              ;Save ACC
017D C258       =1   645            CLR     ZERSUP
017F 315C       =1   646            CALL    NIBOUT          ;Send 1st nib
0181 E508       =1   647            MOV A,TMP0
0183 C4         =1   648            SWAP A                  ;Xchange HI & LOW nibbs in A
0184 C258       =1   649            CLR     ZERSUP
0186 315C       =1   650            CALL    NIBOUT          ;Send 2nt nib
0188 E508       =1   651            MOV A,TMP0              ;Restore A
018A 22         =1   652            RET
                =1   653    
                     654    
                     655    ;=======
                     656    ;STROUT
                     657    ;       Copy in-line character string to console output device.
                     658    ;       Maximum Lenght is 254 Chars + 2 for return addr !!!!
                     659    ;       (8 bit INC to DPTR)
                =1   660    $INCLUDE(BIOS\STROUT.ASM)       ;USES C_OUT
                =1   661    ;STROUT
                =1   662    ;       Copy in-line character string to console output device.
                =1   663    ;       Maximum Lenght is 254 Chars + 2 for return addr !!!!
                =1   664    ;
                =1   665    ;
018B D083       =1   666    STROUT: POP     DPH             ;Access in-line string.
018D D082       =1   667            POP     DPL
018F E4         =1   668    STRO_1: CLR     A
0190 93         =1   669            MOVC    A,@A+DPTR       ;Read next byte.
0191 A3         =1   670            INC     DPTR            ;Bump pointer.
0192 10E704     =1   671            JBC     ACC.7,STRO_2    ;Escape after last character.
0195 312A       =1   672            CALL    C_OUT           ;Output character.
LILBASIC        LilBasic (c)2002                                                                              PAGE 13

0197 80F6       =1   673            SJMP    STRO_1          ;Loop until done.
                =1   674    ;
0199 312A       =1   675    STRO_2: CALL    C_OUT           ;Output Last character.
019B E4         =1   676            CLR     A
019C 73         =1   677            JMP     @A+DPTR         ;Return to program.
                =1   678    ;
                     679    ;=======
                     680    ;STROUT2
                     681    ;       Copy character string to console output device.
                     682    ;       Start @ DPTR
                     683    ;       Stop at char  00H
                     684    ;       255 char limit on length of text!
                =1   685    $INCLUDE(BIOS\STROUT2.ASM)      ;USES C_OUT
                =1   686    ;STROUT2
                =1   687    ;       Copy character string to console output device.
                =1   688    ;       Start @ DPTR
                =1   689    ;       Stop at char  00H
                =1   690    ;       255 char limit on length of text!
                =1   691    ;
019D            =1   692    STROUT2:
019D E4         =1   693            CLR     A
019E 93         =1   694            MOVC    A,@A+DPTR       ;Read next byte.
019F 312A       =1   695            CALL    C_OUT           ;Output character.
01A1 A3         =1   696            INC     DPTR            ;Get next char.
01A2 B400F8     =1   697            CJNE    a,#00H,STROUT2
01A5 22         =1   698            RET                     ;Return To Program
                     699    ;=======
                     700    ;wait1ms
                     701    ;       Wait one MS and exit with out changing anything!!!!
                     702    ;       Assumes:  Clock fq=11.0592mhz
                     703    ;                 1.089us per mcycle  (1us if 12mhz xtal)
                     704    ;                 1ms = 1000us
                     705    ;                 918.2736 mcycles = 1ms
                =1   706    $INCLUDE(BIOS\1ms.ASM)      ;USES C_OUT
                =1   707    
01A6            =1   708    WAIT1MS:
                =1   709    ;         ÿÿÿÿWait one MS and exit with out changing anything!!!!
                =1   710    ;       Assumes:  Clock fq=11.0592mhz
                =1   711    ;                 1.089us per mcycle  (1us if 12mhz xtal)
                =1   712    ;                 1ms = 1000us
                =1   713    ;                 918.2736 mcycles = 1ms
                =1   714    ;                2754.8209 mcycles = 3ms
                =1   715    ;                4591.3680 mcycles = 5ms
                =1   716    
                =1   717                                    ;(2) Two cycles required to call this subroutine
                =1   718    
01A6 00         =1   719            nop                     ;(1) Total of 10 Overhead cycles
01A7 00         =1   720            nop                     ;(1)
01A8            =1   721    WAITMS:
01A8 00         =1   722            nop                     ;(1)
                =1   723    
01A9 C0E0       =1   724            PUSH ACC                ;(2) Save Registers    ( A --> stack)
01AB CA         =1   725            XCH A,R2                ;(1)                   (R2 --> A)
                =1   726    
01AC 7AE4       =1   727            MOV R2,#228             ;(1) wait (226 *4)+14 = 918 mcycles
                =1   728    
                =1   729    
01AE            =1   730    WAIT1MS_LOOP2:                  ;    wait 4 * R2 mcycles
LILBASIC        LilBasic (c)2002                                                                              PAGE 14

01AE 00         =1   731            nop                     ;    (1)
01AF 00         =1   732            nop                     ;    (1)
01B0 DAFC       =1   733            DJNZ R2,wait1ms_loop2   ;    (2)
                =1   734    
                =1   735    
01B2 CA         =1   736            XCH A,R2                ;(1) Restore Registers (R2 <-- A)
01B3 D0E0       =1   737            POP ACC                 ;(2)                   (A <-- Stack)
                =1   738    
01B5 22         =1   739            RET                     ;(2)
                =1   740    
                =1   741    
                =1   742    
01B6            =1   743    WAIT5MS:                       ; 4591 mcycles =  4.9996ms
01B6 31A8       =1   744            CALL waitms ;(2)+916ms
01B8 31A8       =1   745            CALL waitms ;(2)+916ms
01BA            =1   746    WAIT3MS:                       ; 2755 mcycles =  3.0002ms
01BA 00         =1   747            nop         ;(1)
01BB 31A8       =1   748            CALL waitms ;(2)+916ms
01BD 31A8       =1   749            CALL waitms ;(2)+916ms
01BF 80E7       =1   750            sjmp waitms ;(2)+916ms
                =1   751    ;
                     752    ;=======
                     753    ;
                     754    ;       ARITHMETIC SUBROUTINE PACKAGE
                     755    ;
                     756    ;=======
                     757    ;POP_TOS:
                     758    ;       Verify that stack holds at least on (16-bit) entry.
                     759    ;       (Call AES_ER otherwise.)
                     760    ;       Pop TOS into registers TOS_H and TOS_L,
                     761    ;       update AESP,
                     762    ;       and return with R1 pointing to low-order byte of previous NOS.
                     763    ;       Do not affect accumulator contents.
                =1   764    $INCLUDE(AES\POP_TOS.ASM)
01C1            =1   765    POP_TOS:
                =1   766    ;       Verify that stack holds at least on (16-bit) entry.
                =1   767    ;       (Call AES_ER otherwise.)
                =1   768    ;       Pop TOS into registers TOS_H and TOS_L,
                =1   769    ;       update AESP,
                =1   770    ;       and return with R1 pointing to low-order byte of previous NOS.
                =1   771    ;       Do not affect accumulator contents.
                =1   772    ;
                =1   773 +1         PAGE    #0H             ;ZERO PAGE for AES
01C1 75A000     =1   774 +1         MOV     P2,#0H
01C4 A91D       =1   776            MOV     R1,AESP         ;Get current stack pos.
01C6 B90100     =1   777            CJNE    R1,#01H,$+3     ;Compare pointer with min. legal level.
01C9 4027       =1   778            JC      STK_ER          ;If <1 goto error
01CB FE         =1   779            MOV     TOS_L,A         ;Save Tos
01CC E3         =1   780            MOVX    A,@R1           ;Get High Byte
01CD FF         =1   781            MOV     TOS_H,A
01CE 19         =1   782            DEC     R1
01CF E3         =1   783            MOVX    A,@R1           ;Get Low Byte
01D0 CE         =1   784            XCH     A,TOS_L         ;Store byte and reload ACC.
01D1 19         =1   785            DEC     R1
01D2 891D       =1   786            MOV     AESP,R1
01D4 19         =1   787            DEC     R1              ; ?????? whaddup?
01D5 22         =1   788            RET
                =1   789    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 15

                     790    ;=======
                     791    ;POP_ACC:
                     792    ;       Pop TOS into accumulator and update AESP.
                =1   793    $INCLUDE(AES\POP_ACC.ASM)
01D6            =1   794    POP_ACC:
                =1   795    ;       Pop TOS into accumulator and update AESP.
                =1   796    ;
                =1   797 +1         PAGE    #0H             ;ZERO PAGE for AES
01D6 75A000     =1   798 +1         MOV     P2,#0H
01D9 A91D       =1   800            MOV     R1,AESP
01DB E3         =1   801            MOVX    A,@R1
01DC 151D       =1   802            DEC     AESP
01DE 22         =1   803            RET
                =1   804    ;
                     805    ;=======
                     806    ;PUSH_TOS:
                     807    ;       Verify that the AES is not full,
                     808    ;       push registers TOS_H and TOS_L onto AES,
                     809    ;       and update AESP.
                =1   810    $INCLUDE(AES\PUSH_TOS.ASM)
01DF            =1   811    PUSH_TOS:
                =1   812    ;       Verify that the AES is not full,
                =1   813    ;       push registers TOS_H and TOS_L onto AES,
                =1   814    ;       and update AESP.
                =1   815    ;
                =1   816 +1         PAGE    #0H             ;ZERO PAGE for AES
01DF 75A000     =1   817 +1         MOV     P2,#0H
01E2 A91D       =1   819            MOV     R1,AESP
01E4 B9FD00     =1   820            CJNE    R1,#0FDH,$+3    ;Compare pointer with max. legal level.
01E7 5009       =1   821            JNC     STK_ER
01E9 09         =1   822            INC     R1
01EA EE         =1   823            MOV     A,TOS_L         ;Push low-order byte.
01EB F3         =1   824            MOVX    @R1,A
01EC 09         =1   825            INC     R1
01ED EF         =1   826            MOV     A,TOS_H         ;Push high-order byte.
01EE F3         =1   827            MOVX    @R1,A
01EF 891D       =1   828            MOV     AESP,R1
01F1 22         =1   829            RET
                =1   830    ;
01F2 121017     =1   831    STK_ER: CALL    AES_ER
01F5 0F         =1   832            DB      0FH
                =1   833    ;
                     834    ;=======
                     835    ;DUP:   (K)
                     836    ;       Verify that the AES is not full,
                     837    ;       then duplicate the top element and update AESP.
                =1   838    $INCLUDE(AES\DUP.ASM)
01F6            =1   839    DUP:
                =1   840    ;       Verify that the AES is not full,
                =1   841    ;       then duplicate the top element and update AESP.
                =1   842    ;
                =1   843 +1         PAGE    #0H             ;ZERO PAGE for AES
01F6 75A000     =1   844 +1         MOV     P2,#0H
01F9 A91D       =1   846            MOV     R1,AESP
01FB B9FD00     =1   847            CJNE    R1,#0FDH,$+3    ;Compare pointer with max. legal level.
01FE 50F2       =1   848            JNC     STK_ER
                =1   849    
0200 D082       =1   850            POP     DPL
LILBASIC        LilBasic (c)2002                                                                              PAGE 16

0202 D083       =1   851            POP     DPH
0204 E4         =1   852            CLR     A
0205 93         =1   853            MOVC    A,@A+DPTR       ;Read next character from in-line code.
                =1   854    
0206 29         =1   855            ADD     A,R1            ;Compute offset
0207 F9         =1   856            MOV     R1,A            ;save in register
0208 E3         =1   857            MOVX    A,@R1           ;copy byte
0209 A91D       =1   858            MOV     R1,AESP         ;Get current Pos
020B 09         =1   859            INC     R1              ;Bump pointer to next #.
020C F3         =1   860            MOVX    @R1,A           ;Store Byte
020D 891D       =1   861            MOV     AESP,R1         ;Save stack pointer.
020F 22         =1   862            RET
                =1   863    ;
                     864    ;=======
                     865    ;LIT:    (K)
                     866    ;       Report error if arithmetic expression stack is full.
                     867    ;       Otherwise push the one-byte constant K onto AES.
                     868    ;       Return with carry=1, since LIT marks a successful match.
                =1   869    $INCLUDE(AES\LIT.ASM)
                =1   870    ;LIT:    (K)
                =1   871    ;       Report error if arithmetic expression stack is full.
                =1   872    ;       Otherwise push the one-byte constant K onto AES.
                =1   873    ;       Return with carry=1, since LIT marks a successful match.
                =1   874    ;
                =1   875 +1 LIT:    PAGE    #0H             ;ZERO PAGE for AES
0210 75A000     =1   876 +1         MOV     P2,#0H
                =1   878    
0213 D083       =1   879            POP     DPH             ;Get parameter address.
0215 D082       =1   880            POP     DPL
                =1   881    
0217 E4         =1   882            CLR     A
0218 93         =1   883            MOVC    A,@A+DPTR       ;Read literal value.
0219 051D       =1   884            INC     AESP            ;Reserve storage on top of AES.
021B A91D       =1   885            MOV     R1,AESP         ;Point to free entry on stack.
021D B9FF03     =1   886            CJNE    R1,#0FFH,LIT_1
0220 021017     =1   887            JMP     AES_ER
                =1   888    ;
0223 F3         =1   889    LIT_1:  MOVX    @R1,A           ;Store literal.
0224 7401       =1   890            MOV     A,#1            ;Branch over constant on return.
0226 D3         =1   891            SETB    C
0227 73         =1   892            JMP     @A+DPTR         ;Return to IL program.
                =1   893    ;
                     894    ;=======
                     895    
                     896    ;
                     897    ;       BASIC VARIABLE ACCESSING OPERATIONS
                     898    ;       ===== ======== ========= ==========
                     899    ;=======
                     900    ;Special Function Register Table
                =1   901    $INCLUDE(AES\SFR_TBL.ASM)
                =1   902    ;       Direct address mode emulation tables:
                =1   903    ;
0228 80         =1   904    SFRTBL: DB      80H
0229 90         =1   905            DB      90H
022A A0         =1   906            DB      0A0H
022B B0         =1   907            DB      0B0H
022C 88         =1   908            DB      88H
022D 98         =1   909            DB      98H
LILBASIC        LilBasic (c)2002                                                                              PAGE 17

022E A8         =1   910            DB      0A8H
022F B8         =1   911            DB      0B8H
0230 89         =1   912            DB      89H
0231 8A         =1   913            DB      8AH
0232 8B         =1   914            DB      8BH
0233 8C         =1   915            DB      8CH
0234 8D         =1   916            DB      8DH
0235 99         =1   917            DB      99H
  000E          =1   918    NO_SFR  EQU     $-SFRTBL
                =1   919    ;
                =1   920    ;===
                =1   921    ;
0236 8E80       =1   922    STRTBL: MOV     80H,TOS_L
0238 22         =1   923            RET
0239 8E90       =1   924            MOV     90H,TOS_L
023B 22         =1   925            RET
023C 8EA0       =1   926            MOV     0A0H,TOS_L
023E 22         =1   927            RET
023F 8EB0       =1   928            MOV     0B0H,TOS_L
0241 22         =1   929            RET
0242 8E88       =1   930            MOV     88H,TOS_L
0244 22         =1   931            RET
0245 8E98       =1   932            MOV     98H,TOS_L
0247 22         =1   933            RET
0248 8EA8       =1   934            MOV     0A8H,TOS_L
024A 22         =1   935            RET
024B 8EB8       =1   936            MOV     0B8H,TOS_L
024D 22         =1   937            RET
024E 8E89       =1   938            MOV     89H,TOS_L
0250 22         =1   939            RET
0251 8E8A       =1   940            MOV     8AH,TOS_L
0253 22         =1   941            RET
0254 8E8B       =1   942            MOV     8BH,TOS_L
0256 22         =1   943            RET
0257 8E8C       =1   944            MOV     8CH,TOS_L
0259 22         =1   945            RET
025A 8E8D       =1   946            MOV     8DH,TOS_L
025C 22         =1   947            RET
025D 8E99       =1   948            MOV     99H,TOS_L
025F 22         =1   949            RET
                =1   950    ;
                =1   951    ;===
                =1   952    ;
0260 E580       =1   953    INDTBL: MOV     A,80H
0262 22         =1   954            RET
0263 E590       =1   955            MOV     A,90H
0265 22         =1   956            RET
0266 E5A0       =1   957            MOV     A,0A0H
0268 22         =1   958            RET
0269 E5B0       =1   959            MOV     A,0B0H
026B 22         =1   960            RET
026C E588       =1   961            MOV     A,88H
026E 22         =1   962            RET
026F E598       =1   963            MOV     A,98H
0271 22         =1   964            RET
0272 E5A8       =1   965            MOV     A,0A8H
0274 22         =1   966            RET
0275 E5B8       =1   967            MOV     A,0B8H
LILBASIC        LilBasic (c)2002                                                                              PAGE 18

0277 22         =1   968            RET
0278 E589       =1   969            MOV     A,89H
027A 22         =1   970            RET
027B E58A       =1   971            MOV     A,8AH
027D 22         =1   972            RET
027E E58B       =1   973            MOV     A,8BH
0280 22         =1   974            RET
0281 E58C       =1   975            MOV     A,8CH
0283 22         =1   976            RET
0284 E58D       =1   977            MOV     A,8DH
0286 22         =1   978            RET
0287 E599       =1   979            MOV     A,99H
0289 22         =1   980            RET
                =1   981    ;
                     982    ;=======
                     983    ;SFR_ID:
                     984    ;       Identify which SFR is indicated by the contents of R1.
                     985    ;       Return with acc holding (Index of said register)*3.
                     986    ;       Call error routine if register number not found.
                =1   987    $INCLUDE(AES\SFR_ID.ASM)
028A            =1   988    SFR_ID:
                =1   989    ;       Identify which SFR is indicated by the contents of R1.
                =1   990    ;       Return with acc holding (Index of said register)*3.
                =1   991    ;       Call error routine if register number not found.
                =1   992    ;
028A 900228     =1   993            MOV     DPTR,#SFRTBL
028D E4         =1   994            CLR     A
028E FD         =1   995            MOV     LP_CNT,A
028F ED         =1   996    SFID_1: MOV     A,LP_CNT
0290 93         =1   997            MOVC    A,@A+DPTR
0291 69         =1   998            XRL     A,R1
0292 7004       =1   999            JNZ     SFID_2
0294 ED         =1  1000            MOV     A,LP_CNT
0295 23         =1  1001            RL      A
0296 2D         =1  1002            ADD     A,LP_CNT
0297 22         =1  1003            RET
                =1  1004    ;
0298 0D         =1  1005    SFID_2: INC     LP_CNT
0299 ED         =1  1006            MOV     A,LP_CNT
029A B40EF2     =1  1007            CJNE    A,#NO_SFR,SFID_1
029D 020FF7     =1  1008    ADR_ER: JMP     EXP_ER
                =1  1009    ;
                    1010    ;=======
                    1011    ;STRDIR:
                    1012    ;       Store data byte in ACC into direct on-chip RAM (and SFR) address held in R1.
                =1  1013    $INCLUDE(AES\STR_DIR.ASM)
02A0            =1  1014    STRDIR:
                =1  1015    ;       Store data byte in ACC into direct on-chip RAM address held in R1.
                =1  1016    ;
02A0 FE         =1  1017            MOV     TOS_L,A
02A1 E9         =1  1018            MOV     A,R1
02A2 20E703     =1  1019            JB      ACC.7,STRSFR    ;Direct addresses above 7FH are SFRs.
02A5 EE         =1  1020            MOV     A,TOS_L
02A6 F7         =1  1021            MOV     @R1,A           ;Store low-order byte in RAM.
02A7 22         =1  1022            RET
                =1  1023    ;
02A8 518A       =1  1024    STRSFR: CALL    SFR_ID
02AA 900236     =1  1025            MOV     DPTR,#STRTBL
LILBASIC        LilBasic (c)2002                                                                              PAGE 19

02AD 73         =1  1026            JMP     @A+DPTR         ;Jump into store sequence.
                    1027    ;=======
                    1028    ;FETDIR:
                    1029    ;       Fetch on-chip directly addressed byte (and SFR)indicated by R1 into Acc.
                =1  1030    $INCLUDE(AES\FET_DIR.ASM)
02AE            =1  1031    FETDIR:
                =1  1032    ;       Fetch on-chip directly addressed byte indicated by R1 into Acc.
                =1  1033    ;       and return.
                =1  1034    ;
                =1  1035    
02AE E9         =1  1036            MOV     A,R1
02AF 20E702     =1  1037            JB      ACC.7,FETSFR
02B2 E7         =1  1038            MOV    A,@R1
02B3 22         =1  1039            RET
                =1  1040    ;
02B4 518A       =1  1041    FETSFR: CALL    SFR_ID
02B6 900260     =1  1042            MOV     DPTR,#INDTBL
02B9 73         =1  1043            JMP     @A+DPTR
                =1  1044    ;
                    1045    ;=======
                    1046    ;SPLIT_DBA:
                    1047    ;       Called with TOS_L containing a direct on-chip bit address.
                    1048    ;       Return the direct &byte& address of encompassing
                    1049    ;       register in R1, and load B with a mask containing a single 1
                    1050    ;       corresponding to the bit's position in a field of zeroes.
                =1  1051    $INCLUDE(AES\SPL_DBA.ASM)
                =1  1052    ;
02BA            =1  1053    SPLIT_DBA:
                =1  1054    ;       Called with TOS_L containing a direct on-chip bit address.
                =1  1055    ;       Return the direct &byte& address of encompassing
                =1  1056    ;       register in R1, and load B with a mask containing a single 1
                =1  1057    ;       corresponding to the bit's position in a field of zeroes.
                =1  1058    ;
02BA EE         =1  1059            MOV     A,TOS_L
02BB 54F8       =1  1060            ANL     A,#11111000B
02BD 20E704     =1  1061            JB      ACC.7,SPLSFR
02C0 23         =1  1062            RL      A
02C1 C4         =1  1063            SWAP    A
02C2 2420       =1  1064            ADD     A,#20H          ;Address of bit-address space.
02C4 F9         =1  1065    SPLSFR: MOV     R1,A
02C5 EE         =1  1066            MOV     A,TOS_L
02C6 5407       =1  1067            ANL     A,#07H          ;Mask off bit-displacement field.
02C8 2403       =1  1068            ADD     A,#MSKTBL-MSK_PC
02CA 83         =1  1069            MOVC    A,@A+PC         ;Read mask byte.
02CB            =1  1070    MSK_PC:
02CB F5F0       =1  1071            MOV     B,A
02CD 22         =1  1072            RET
                    1073    ;=======
                    1074    ;MSKTBL:
                    1075    ;       Mask Table for 2^x
                =1  1076    $INCLUDE(AES\MSK_TBL.ASM)
02CE            =1  1077    MSKTBL:
02CE 01         =1  1078            DB      00000001B
02CF 02         =1  1079            DB      00000010B
02D0 04         =1  1080            DB      00000100B
02D1 08         =1  1081            DB      00001000B
02D2 10         =1  1082            DB      00010000B
02D3 20         =1  1083            DB      00100000B
LILBASIC        LilBasic (c)2002                                                                              PAGE 20

02D4 40         =1  1084            DB      01000000B
02D5 80         =1  1085            DB      10000000B
                    1086    ;=======
                    1087    ;SEQ_STORE:
                    1088    ;       Same as STORE, below, except that index is retained
                    1089    ;       rather than being popped.
                    1090    ;STORE:
                    1091    ;       When STORE is called, AES contains
                    1092    ;       (TOS:)  2 byte VALUE to be stored,
                    1093    ;               2 byte INDEX of destination variable,
                    1094    ;               1 byte TYPE code for variable space.
                    1095    ;                       (0=BASIC variable,
                    1096    ;                        1=DBYTE,
                    1097    ;                        2=RBIT,
                    1098    ;                        3=XBYTE,
                    1099    ;                        4=CBYTE.)
                    1100    ;       Store (VAR_1) into appropriate variable memory at location of (INDEX).
                =1  1101    $INCLUDE(AES\STORE.ASM)
                =1  1102    ;
                =1  1103    ;
02D6            =1  1104    SEQ_STORE:
                =1  1105    ;       Same as STORE, below, except that index is retained
                =1  1106    ;       rather than being popped.
02D6 D25B       =1  1107            SETB    SEQ_FLG
02D8 8002       =1  1108            SJMP    STOR_0
                =1  1109    
                =1  1110    
02DA            =1  1111    STORE:
                =1  1112    ;       When STORE is called, AES contains
                =1  1113    ;       (TOS:)  2 byte VALUE to be stored,
                =1  1114    ;               2 byte INDEX of destination variable,
                =1  1115    ;               1 byte TYPE code for variable space.
                =1  1116    ;                       (0=BASIC variable,
                =1  1117    ;                        1=DBYTE,
                =1  1118    ;                        2=RBIT,
                =1  1119    ;                        3=XBYTE,
                =1  1120    ;                        4=CBYTE.)
                =1  1121    ;       Store (VAR_1) into appropriate variable memory at location of (INDEX).
                =1  1122    ;
02DA C25B       =1  1123            CLR     SEQ_FLG
02DC 31C1       =1  1124    STOR_0: CALL    POP_TOS
02DE 8E08       =1  1125            MOV     TMP0,TOS_L
02E0 8F09       =1  1126            MOV     TMP1,TOS_H
02E2 31C1       =1  1127            CALL    POP_TOS
02E4 31D6       =1  1128            CALL    POP_ACC         ;Load TYPE code.
02E6 305B06     =1  1129            JNB     SEQ_FLG,STOR_1  ;Jump forward if simple store.
02E9 051D       =1  1130            INC     AESP
02EB 051D       =1  1131            INC     AESP
02ED 051D       =1  1132            INC     AESP
                =1  1133    
                =1  1134    
02EF 9002F4     =1  1135    STOR_1: MOV     DPTR,#STRJTB
02F2 93         =1  1136            MOVC    A,@A+DPTR
02F3 73         =1  1137            JMP     @A+DPTR
                =1  1138    ;
02F4 05         =1  1139    STRJTB: DB      STRVAR-STRJTB
02F5 1E         =1  1140            DB      STRDBY-STRJTB
02F6 24         =1  1141            DB      STRRBI-STRJTB
LILBASIC        LilBasic (c)2002                                                                              PAGE 21

02F7 39         =1  1142            DB      STRXBY-STRJTB
02F8 39         =1  1143            DB      STRCBY-STRJTB
                =1  1144    ;
                =1  1145    ;=======
                =1  1146    ;
                =1  1147    ;       All of the following routines are called with
                =1  1148    ;       TOS_L holding the low-order address of the destination,
                =1  1149    ;       TOS_H holding the high-order address (if necessary),
                =1  1150    ;       and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
                =1  1151    ;
02F9 EE         =1  1152    STRVAR: MOV     A,TOS_L         ;Get Low byte of Variable number 0 to 25
02FA C3         =1  1153            CLR     C               ;Clear carry bit.
02FB 33         =1  1154            RLC     A               ;Multiply by two for 2 byte wide variables.  (0 - 50)
02FC F9         =1  1155            MOV     R1,A            ;Move A into R1
02FD EF         =1  1156            MOV     A,TOS_H         ;Get High byte of Variable number.
02FE 33         =1  1157            RLC     A               ;Multiply by 2 also
                =1  1158    
02FF C3         =1  1159            CLR     C               ;Clear carry bit again before adding offset
0300 C9         =1  1160            XCH     A,R1            ;Swap bytes to get low byte again
                =1  1161    
0301 3400       =1  1162            ADDC    A,#LOW(VARRAM)  ;Add offset to variable table in ram
0303 F582       =1  1163            MOV     DPL,A           ;Save low byte of data pointer
                =1  1164    
0305 E9         =1  1165            MOV     A,R1            ;Get Highbyte
0306 341C       =1  1166            ADDC    A,#HIGH(VARRAM) ;Add offset (with carry bit) to var. table
0308 F583       =1  1167            MOV     DPH,A           ;Save High byte of data pointer
                =1  1168    
                =1  1169    
030A E508       =1  1170            MOV     A,TMP0          ;Get lowbyte of value
                =1  1171    
030C F0         =1  1172            MOVX    @DPTR,A         ;Store into variable array
030D A3         =1  1173            INC     DPTR            ;Bump pointer to next byte.
030E E509       =1  1174            MOV     A,TMP1          ;Move high-order byte into variable array.
0310 F0         =1  1175            MOVX    @DPTR,A
0311 22         =1  1176            RET
                =1  1177    ;
                =1  1178    ;===
                =1  1179    ;
0312 EE         =1  1180    STRDBY: MOV     A,TOS_L         ;Load acc. with low-order dest. addr.
0313 F9         =1  1181            MOV     R1,A
0314 E508       =1  1182            MOV     A,TMP0
0316 8088       =1  1183            JMP     STRDIR
                =1  1184    ;
                =1  1185    ;===
                =1  1186    ;
0318 51BA       =1  1187    STRRBI: CALL    SPLIT_DBA
031A 51AE       =1  1188            CALL    FETDIR
031C FE         =1  1189            MOV     TOS_L,A
031D E508       =1  1190            MOV     A,TMP0
031F 20E006     =1  1191            JB      ACC.0,SETRBI
                =1  1192    ;
                =1  1193    ;       Clear RBIT.
                =1  1194    ;
0322 E5F0       =1  1195            MOV     A,B
0324 F4         =1  1196            CPL     A
0325 5E         =1  1197            ANL     A,TOS_L
0326 41A0       =1  1198            JMP     STRDIR
                =1  1199    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 22

0328 E5F0       =1  1200    SETRBI: MOV     A,B
032A 4E         =1  1201            ORL     A,TOS_L
032B 41A0       =1  1202            JMP     STRDIR
                =1  1203    ;
                =1  1204    ;===
                =1  1205    ;
032D            =1  1206    STRXBY:
032D 8F83       =1  1207    STRCBY: MOV     DPH,TOS_H
032F 8E82       =1  1208            MOV     DPL,TOS_L
0331 E508       =1  1209            MOV     A,TMP0
0333 F0         =1  1210            MOVX    @DPTR,A
0334 22         =1  1211            RET
                =1  1212    ;
                    1213    ;===============
                    1214    ;SEQ_FETCH:
                    1215    ;       Same as FETCH, below, except that index is retained
                    1216    ;       rather than being popped.
                    1217    ;FETCH:
                    1218    ;       When FETCH is called, AES contains
                    1219    ;       (TOS:)  2 byte INDEX of source variable,
                    1220    ;               1 byte TYPE code for variable space.
                    1221    ;                       (0=BASIC variable,
                    1222    ;                        1=DBYTE,
                    1223    ;                        2=RBIT,
                    1224    ;                        3=XBYTE,
                    1225    ;                        4=CBYTE.)
                    1226    ;       Read 8- or 16-bit variable from the appropriate variable
                    1227    ;       memory at location of (INDEX) and return on AES.
                =1  1228    $INCLUDE(AES\FETCH.ASM)
0335            =1  1229    SEQ_FETCH:
                =1  1230    ;       Same as FETCH, below, except that index is retained
                =1  1231    ;       rather than being popped.
0335 D25B       =1  1232            SETB    SEQ_FLG
0337 8002       =1  1233            SJMP    FET_0
                =1  1234    ;
                =1  1235    ;
0339            =1  1236    FETCH:
                =1  1237    ;       When FETCH is called, AES contains
                =1  1238    ;       (TOS:)  2 byte INDEX of source variable,
                =1  1239    ;               1 byte TYPE code for variable space.
                =1  1240    ;                       (0=BASIC variable,
                =1  1241    ;                        1=DBYTE,
                =1  1242    ;                        2=RBIT,
                =1  1243    ;                        3=XBYTE,
                =1  1244    ;                        4=CBYTE.)
                =1  1245    ;       Read 8- or 16-bit variable from the appropriate variable
                =1  1246    ;       memory at location of (INDEX) and return on AES.
                =1  1247    ;
0339 C25B       =1  1248            CLR     SEQ_FLG
033B 31C1       =1  1249    FET_0:  CALL    POP_TOS
033D 31D6       =1  1250            CALL    POP_ACC
033F 305B06     =1  1251            JNB     SEQ_FLG,FET_1   ;Jump forward if simple store.
0342 051D       =1  1252            INC     AESP
0344 051D       =1  1253            INC     AESP
0346 051D       =1  1254            INC     AESP
0348 90034D     =1  1255    FET_1:  MOV     DPTR,#FETJTB
034B 93         =1  1256            MOVC    A,@A+DPTR
034C 73         =1  1257            JMP     @A+DPTR
LILBASIC        LilBasic (c)2002                                                                              PAGE 23

                =1  1258    ;
034D 05         =1  1259    FETJTB: DB      FETVAR-FETJTB
034E 1F         =1  1260            DB      FETDBY-FETJTB
034F 25         =1  1261            DB      FETRBI-FETJTB
0350 31         =1  1262            DB      FETXBY-FETJTB
0351 38         =1  1263            DB      FETCBY-FETJTB
                =1  1264    ;
                =1  1265    ;=======
                =1  1266    ;
                =1  1267    ;       All of the following routines are called with
                =1  1268    ;       TOS_L holding the low-order index of the desired variable,
                =1  1269    ;       and TOS_H holding the high-order index (if necessary).
                =1  1270    ;
0352 EE         =1  1271    FETVAR: MOV     A,TOS_L         ;Get Low Byte of var #
0353 C3         =1  1272            CLR     C               ;Clear carry bit
0354 33         =1  1273            RLC     A               ;Multiply by 2 for 16bit vars.
0355 F9         =1  1274            MOV     R1,A            ;Save in R1.
                =1  1275    
0356 EF         =1  1276            MOV     A,TOS_H         ;Get High byte
0357 33         =1  1277            RLC     A               ;Multiply High byte.
                =1  1278    
0358 C3         =1  1279            CLR     C               ;Clear carry bit again for 16bit add
0359 C9         =1  1280            XCH     A,R1            ;Swap bytes to get high byte again
                =1  1281    
035A 3400       =1  1282            ADDC    A,#LOW(VARRAM)  ;Add offset to low byte
035C F582       =1  1283            MOV     DPL,A           ;Save low byte address of pointer
                =1  1284    
035E E9         =1  1285            MOV     A,R1            ;Get high byte
035F 341C       =1  1286            ADDC    A,#HIGH(VARRAM) ;Add offset
0361 F583       =1  1287            MOV     DPH,A           ;Save high byte address of pointer
                =1  1288    
0363 E0         =1  1289            MOVX    A,@DPTR         ;Load low-order byte of variable.
0364 FE         =1  1290            MOV     TOS_L,A         ;And store on AES.
0365 A3         =1  1291            INC     DPTR            ;bump data pointer.
0366 E0         =1  1292            MOVX    A,@DPTR         ;Transfer high-order byte of variable.
0367 FF         =1  1293            MOV     TOS_H,A
0368 21DF       =1  1294            JMP     PUSH_TOS
                =1  1295    ;
036A 419D       =1  1296    FETERR: JMP     ADR_ER
                =1  1297    ;
                =1  1298    ;===
                =1  1299    ;
036C EE         =1  1300    FETDBY: MOV     A,TOS_L
036D F9         =1  1301            MOV     R1,A
036E 51AE       =1  1302            CALL    FETDIR
0370 8019       =1  1303            SJMP    FETBDN          ;Byte fetch done.
                =1  1304    ;
                =1  1305    ;===
                =1  1306    ;
0372 51BA       =1  1307    FETRBI: CALL    SPLIT_DBA
0374 51AE       =1  1308            CALL    FETDIR
0376 55F0       =1  1309            ANL     A,B
0378 24FF       =1  1310            ADD     A,#0FFH
037A E4         =1  1311            CLR     A
037B 33         =1  1312            RLC     A
037C 800D       =1  1313            SJMP    FETBDN
                =1  1314    ;
                =1  1315    ;===
LILBASIC        LilBasic (c)2002                                                                              PAGE 24

                =1  1316    ;
037E 8F83       =1  1317    FETXBY: MOV     DPH,TOS_H
0380 8E82       =1  1318            MOV     DPL,TOS_L
0382 E0         =1  1319            MOVX    A,@DPTR
0383 8006       =1  1320            SJMP    FETBDN
                =1  1321    ;
                =1  1322    ;===
                =1  1323    ;
0385 8F83       =1  1324    FETCBY: MOV     DPH,TOS_H
0387 8E82       =1  1325            MOV     DPL,TOS_L
0389 E4         =1  1326            CLR     A
038A 93         =1  1327            MOVC    A,@A+DPTR
038B 7F00       =1  1328    FETBDN: MOV     TOS_H,#00H      ;FETCH sequence for Bytes Done.
038D FE         =1  1329            MOV     TOS_L,A         ;FETCH sequence for words done.
038E 21DF       =1  1330            JMP     PUSH_TOS
                =1  1331    ;
                    1332    ;=======
                    1333    ;CREATE
                    1334    ;       Test the contents of Acc.
                    1335    ;       If CHAR holds the ASCII code for a legitimate decimal digit,
                    1336    ;       create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
                    1337    ;       and return with CY set.
                    1338    ;       Otherwise, return with CY cleared.
                =1  1339    $INCLUDE(AES\CREATE.ASM)
                =1  1340    ;CREATE
                =1  1341    ;       Test the contents of Acc.
                =1  1342    ;       If CHAR holds the ASCII code for a legitimate decimal digit,
                =1  1343    ;       create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
                =1  1344    ;       and return with CY set.
                =1  1345    ;       Otherwise, return with CY cleared.
                =1  1346    ;
0390 24D0       =1  1347    CREATE: ADD     A,#-'0'         ;Correct for ASCII digit offset.
0392 B40A00     =1  1348            CJNE    A,#10,$+3       ;Compare to maximum legal digit.
0395 5005       =1  1349            JNC     CREA_1          ;Abort if first char is not decimal digit.
0397 FE         =1  1350            MOV     TOS_L,A         ;Save initial digit read.
0398 7F00       =1  1351            MOV     TOS_H,#0        ;Clear high-order bits.
039A C25D       =1  1352            CLR     H_FLG
039C 22         =1  1353    CREA_1: RET
                =1  1354    ;
                    1355    ;===============
                    1356    ;APPEND
                    1357    ;       Test ASCII code in Acc.
                    1358    ;       If it is a legal digit in the current radix,
                    1359    ;       modify <TOS_H><TOS_L> to include this digit and return with CY set.
                    1360    ;       Otherwise leave AES and CHAR unchanged and return with CY cleared.
                    1361    ;       Operating mode determined by HEXMOD flag (1=Hex).
                =1  1362    $INCLUDE(AES\APPEND.ASM)
                =1  1363    ;APPEND
                =1  1364    ;       Test ASCII code in Acc.
                =1  1365    ;       If it is a legal digit in the current radix,
                =1  1366    ;       modify <TOS_H><TOS_L> to include this digit and return with CY set.
                =1  1367    ;       Otherwise leave AES and CHAR unchanged and return with CY cleared.
                =1  1368    ;       Operating mode determined by HEXMOD flag (1=Hex).
                =1  1369    ;
039D 205D3E     =1  1370    APPEND: JB      H_FLG,APND_2    ;Nothing allowed after trailing 'H' received.
03A0 24D0       =1  1371            ADD     A,#-'0'         ;Correct for ASCII offset.
03A2 B40A00     =1  1372            CJNE    A,#10,$+3       ;Verify whether legal digit.
03A5 4013       =1  1373            JC      APND_1          ;Insert decimal digit as is.
LILBASIC        LilBasic (c)2002                                                                              PAGE 25

03A7 305434     =1  1374            JNB     HEXMOD,APND_2   ;If in decimal mode, character isn't legal.
03AA 24EF       =1  1375            ADD     A,#'0'-'A'      ;Acc now equals 0 if 'A' received.
03AC B40600     =1  1376            CJNE    A,#6,$+3
03AF 4007       =1  1377            JC      APND_4          ;Process Hex digit.
                =1  1378    ;
                =1  1379    ;       Char was not hexidecimal digit, but if it was the first 'H', that's OK.
                =1  1380    ;
03B1 B4072A     =1  1381            CJNE    A,#'H'-'A',APND_2       ;Compare original input with 'H'.
03B4 D25D       =1  1382            SETB    H_FLG           ;Mark that 'H' was detected but don't process.
03B6 D3         =1  1383            SETB    C
03B7 22         =1  1384            RET
                =1  1385    ;
03B8 240A       =1  1386    APND_4: ADD     A,#10           ;Value of lowest hex digit.
03BA CE         =1  1387    APND_1: XCH     A,TOS_L         ;Save nibble to be appended.
03BB 75F00A     =1  1388            MOV     B,#10           ;(Assuming radix=decimal.)
03BE 305403     =1  1389            JNB     HEXMOD,XRAD_1   ;Skip ahead if assumption correct.
03C1 75F010     =1  1390            MOV     B,#16           ;If mode is actually hex.
03C4 C0F0       =1  1391    XRAD_1: PUSH    B               ;Save for re-use.
03C6 A4         =1  1392            MUL     AB              ;Multiply by radix.
03C7 2E         =1  1393            ADD     A,TOS_L         ;Append new digit.
03C8 FE         =1  1394            MOV     TOS_L,A         ;Save low-order shifted value.
03C9 E4         =1  1395            CLR     A
03CA 35F0       =1  1396            ADDC    A,B             ;Incremented high-order product if carry.
03CC CF         =1  1397            XCH     A,TOS_H
03CD D0F0       =1  1398            POP     B
03CF A4         =1  1399            MUL     AB
03D0 2F         =1  1400            ADD     A,TOS_H
03D1 FF         =1  1401            MOV     TOS_H,A
03D2 72E7       =1  1402            ORL     C,ACC.7         ;Detect if most significant bit set.
03D4 E5F0       =1  1403            MOV     A,B
03D6 34FF       =1  1404            ADDC    A,#0FFH         ;Simulate "ORL  C,NZ" instruction.
03D8 B054       =1  1405            ANL     C,/HEXMOD       ;Overflow only relevent in decimal mode.
03DA 4004       =1  1406            JC      APN_ER          ;Error if bit 7 overflow occurred.
03DC D3         =1  1407            SETB    C               ;CHAR processed as legal character.
03DD 22         =1  1408            RET
                =1  1409    ;
03DE C3         =1  1410    APND_2: CLR     C
03DF 22         =1  1411            RET
                =1  1412    ;
                =1  1413    ;
03E0 120FF7     =1  1414    APN_ER: CALL    EXP_ER          ;Indicate illegal entry.
03E3 02         =1  1415            DB      2
                =1  1416    ;
                =1  1417    
                =1  1418    ;
03E4            =1  1419    OV_TST:
                =1  1420    ;       If OV is set and operation is BCD mode then call EXP_ER routine.
                =1  1421    ;
03E4 A2D2       =1  1422            MOV     C,OV
03E6 B054       =1  1423            ANL     C,/HEXMOD
03E8 4001       =1  1424            JC      EXP_OV
03EA 22         =1  1425            RET
                =1  1426    ;
03EB 120FF7     =1  1427    EXP_OV: CALL    EXP_ER
03EE 06         =1  1428            DB      6
                =1  1429    ;
                    1430    ;=======
                    1431    ;IADD:
LILBASIC        LilBasic (c)2002                                                                              PAGE 26

                    1432    ;       Pop VAR from AES (two bytes).
                    1433    ;       TOS <= TOS + VAR
                =1  1434    $INCLUDE(AES\IADD.ASM)
03EF            =1  1435    IADD:
                =1  1436    ;       Pop VAR from AES (two bytes).
                =1  1437    ;       TOS <= TOS + VAR
                =1  1438    ;
03EF 31C1       =1  1439            CALL    POP_TOS
03F1 1203F6     =1  1440            CALL    ADD_16
03F4 80EE       =1  1441            JMP     OV_TST
                =1  1442    
                =1  1443 +1 ADD_16: PAGE    #0H             ;ZERO PAGE for AES
03F6 75A000     =1  1444 +1         MOV     P2,#0H
03F9 E3         =1  1446            MOVX    A,@R1           ;Add low-order bytes.
03FA 2E         =1  1447            ADD     A,TOS_L
03FB F3         =1  1448            MOVX    @R1,A           ;Save sum.
03FC 09         =1  1449            INC     R1
03FD E3         =1  1450            MOVX    A,@R1           ;Add high-order bytes.
03FE 3F         =1  1451            ADDC    A,TOS_H
03FF F3         =1  1452            MOVX    @R1,A           ;Save sum.
0400 22         =1  1453            RET
                    1454    ;===============
                    1455    ;ISUB
                    1456    ;       Pop VAR from AES (two bytes).
                    1457    ;       TOS <= TOS - VAR
                =1  1458    $INCLUDE(AES\ISUB.ASM)
                =1  1459    ;ISUB
                =1  1460    ;       Pop VAR from AES (two bytes).
                =1  1461    ;       TOS <= TOS - VAR
                =1  1462    ;
                =1  1463    ;
                =1  1464 +1 ISUB:   PAGE    #0H             ;ZERO PAGE for AES
0401 75A000     =1  1465 +1         MOV     P2,#0H
0404 31C1       =1  1467            ACALL   POP_TOS
0406 C3         =1  1468            CLR     C               ;Set up for subtraction with borrow.
0407 E3         =1  1469            MOVX    A,@R1           ;Subtract low-order bytes.
0408 9E         =1  1470            SUBB    A,TOS_L
0409 F3         =1  1471            MOVX    @R1,A           ;Save difference.
040A 09         =1  1472            INC     R1              ;Bump pointers.
040B E3         =1  1473            MOVX    A,@R1           ;Subtract high-order bytes.
040C 9F         =1  1474            SUBB    A,TOS_H
040D F3         =1  1475            MOVX    @R1,A           ;Save difference.
040E 80D4       =1  1476            JMP     OV_TST
                =1  1477    ;
                    1478    ;=======
                    1479    ;IAND:
                    1480    ;       Pop VAR from AES (two bytes).
                    1481    ;       TOS <= TOS AND VAR
                =1  1482    $INCLUDE(AES\IAND.ASM)
0410            =1  1483    IAND:
                =1  1484    ;       Pop VAR from AES (two bytes).
                =1  1485    ;       TOS <= TOS AND VAR
                =1  1486    ;
                =1  1487 +1         PAGE    #0H             ;ZERO PAGE for AES
0410 75A000     =1  1488 +1         MOV     P2,#0H
0413 31C1       =1  1490            CALL    POP_TOS
0415 E3         =1  1491            MOVX    A,@R1           ;AND low-order bytes.
0416 5E         =1  1492            ANL     A,TOS_L
LILBASIC        LilBasic (c)2002                                                                              PAGE 27

0417 F3         =1  1493            MOVX    @R1,A           ;Save result.
0418 09         =1  1494            INC     R1
0419 E3         =1  1495            MOVX    A,@R1           ;AND high-order bytes.
041A 5F         =1  1496            ANL     A,TOS_H
041B F3         =1  1497            MOVX    @R1,A           ;Save result.
041C 22         =1  1498            RET
                =1  1499    ;
                    1500    ;=======
                    1501    ;IOR:
                    1502    ;       Pop VAR from AES (two bytes).
                    1503    ;       TOS <= TOS OR VAR
                =1  1504    $INCLUDE(AES\IOR.ASM)
041D            =1  1505    IOR:
                =1  1506    ;       Pop VAR from AES (two bytes).
                =1  1507    ;       TOS <= TOS OR VAR
                =1  1508    ;
                =1  1509 +1         PAGE    #0H             ;ZERO PAGE for AES
041D 75A000     =1  1510 +1         MOV     P2,#0H
0420 31C1       =1  1512            CALL    POP_TOS
0422 E3         =1  1513            MOVX    A,@R1           ;OR low-order bytes.
0423 4E         =1  1514            ORL     A,TOS_L
0424 F3         =1  1515            MOVX    @R1,A           ;Save result.
0425 09         =1  1516            INC     R1
0426 E3         =1  1517            MOVX    A,@R1           ;OR high-order bytes.
0427 4F         =1  1518            ORL     A,TOS_H
0428 F3         =1  1519            MOVX    @R1,A           ;Save result.
0429 22         =1  1520            RET
                =1  1521    ;
                    1522    ;=======
                    1523    ;IXOR:
                    1524    ;       Pop VAR from AES (two bytes).
                    1525    ;       TOS <= TOS XOR VAR
                =1  1526    $INCLUDE(AES\IXOR.ASM)
042A            =1  1527    IXOR:
                =1  1528    ;       Pop VAR from AES (two bytes).
                =1  1529    ;       TOS <= TOS XOR VAR
                =1  1530    ;
                =1  1531 +1         PAGE    #0H             ;ZERO PAGE for AES
042A 75A000     =1  1532 +1         MOV     P2,#0H
042D 31C1       =1  1534            CALL    POP_TOS
042F E3         =1  1535            MOVX    A,@R1           ;XOR low-order bytes.
0430 6E         =1  1536            XRL     A,TOS_L
0431 F3         =1  1537            MOVX    @R1,A           ;Save result.
0432 09         =1  1538            INC     R1
0433 E3         =1  1539            MOVX    A,@R1           ;XOR high-order bytes.
0434 6F         =1  1540            XRL     A,TOS_H
0435 F3         =1  1541            MOVX    @R1,A           ;Save result.
0436 22         =1  1542            RET
                =1  1543    ;
                    1544    ;===============
                    1545    ;ICPL:
                    1546    ;       TOS <= /TOS  (ones complement)
                    1547    ;IABS:
                    1548    ;       If in decimal mode and TOS < 0
                    1549    ;       then complement SGN_FLG and negate TOS.
                    1550    ;NEG_IF_NEG:
                    1551    ;       If SGN_FLG is set then negate TOS and complement SGN_FLG,
                    1552    ;       else return with TOS unchanged.
LILBASIC        LilBasic (c)2002                                                                              PAGE 28

                =1  1553    $INCLUDE(AES\NEG.ASM)
0437            =1  1554    IABS:
                =1  1555    ;       If in decimal mode and TOS < 0
                =1  1556    ;       then complement SGN_FLG and negate TOS.
                =1  1557    ;
                =1  1558 +1         PAGE    #0H             ;ZERO PAGE for AES
0437 75A000     =1  1559 +1         MOV     P2,#0H
043A A91D       =1  1561            MOV     R1,AESP
043C E3         =1  1562            MOVX    A,@R1
043D A2E7       =1  1563            MOV     C,ACC.7
043F B054       =1  1564            ANL     C,/HEXMOD
0441 4008       =1  1565            JC      NEG
0443 22         =1  1566            RET
                =1  1567    ;
                =1  1568    ;=======
                =1  1569    ;
0444            =1  1570    NEG_IF_NEG:
                =1  1571    ;       If SGN_FLG is set then negate TOS and complement SGN_FLG,
                =1  1572    ;       else return with TOS unchanged.
0444 205A04     =1  1573            JB      SGN_FLG,NEG
0447 22         =1  1574            RET
                =1  1575    ;
                =1  1576    
0448            =1  1577    ICPL:
                =1  1578    ;       TOS <= /TOS  (ones complement)
0448 D3         =1  1579            SETB    C
0449 8003       =1  1580            SJMP    NEG_0
                =1  1581    ;
                =1  1582    
044B            =1  1583    NEG:
                =1  1584    ;       TOS <= -TOS
                =1  1585    ;
044B C3         =1  1586            CLR     C
044C B25A       =1  1587            CPL     SGN_FLG
044E            =1  1588    NEG_0:
                =1  1589 +1         PAGE    #0H             ;ZERO PAGE for AES
044E 75A000     =1  1590 +1         MOV     P2,#0H
0451 A91D       =1  1592            MOV     R1,AESP         ;Compute variable address.
0453 19         =1  1593            DEC     R1              ;Index for low-order byte of VAR_1.
0454 E3         =1  1594            MOVX    A,@R1           ;Get low byte
0455 F5F0       =1  1595            MOV     B,A             ;Save in B
0457 E4         =1  1596            CLR     A               ;Subtract VAR_1 from 0000H.
0458 95F0       =1  1597            SUBB    A,B
045A F3         =1  1598            MOVX     @R1,A           ;Save difference.
045B 09         =1  1599            INC     R1              ;Bump pointer.
                =1  1600    
045C E3         =1  1601            MOVX    A,@R1           ;Get High byte
045D F5F0       =1  1602            MOV     B,A             ;Save in B
045F E4         =1  1603            CLR     A               ;Subtract VAR_1 from 0000H.
0460 95F0       =1  1604            SUBB    A,B
0462 F3         =1  1605            MOVX    @R1,A           ;Save difference.
0463 61E4       =1  1606            JMP     OV_TST
                =1  1607    ;
                    1608    ;===============
                    1609    ;IINC:
                    1610    ;       TOS <= TOS+1
                =1  1611    $INCLUDE(AES\IINC.ASM)
0465            =1  1612    IINC:
LILBASIC        LilBasic (c)2002                                                                              PAGE 29

                =1  1613    ;       TOS <= TOS+1
                =1  1614    ;
                =1  1615 +1         PAGE    #0H             ;ZERO PAGE for AES
0465 75A000     =1  1616 +1         MOV     P2,#0H
0468 A91D       =1  1618            MOV     R1,AESP         ;Compute variable address.
046A 19         =1  1619            DEC     R1              ;Index for low-order byte of VAR_1.
046B E3         =1  1620            MOVX    A,@R1           ;Get low byte
046C 04         =1  1621            INC     A               ;Add 1
046D F3         =1  1622            MOVX    @R1,A           ;Store
046E B40004     =1  1623            CJNE    A,#00,IINC_1    ;If not rollover FF -> 00 then Exit
0471 09         =1  1624            INC     R1              ;Bump pointer.
0472 E3         =1  1625            MOVX    A,@R1           ;Get high byte
0473 04         =1  1626            INC     A               ;Add 1
0474 F3         =1  1627            MOVX    @R1,A           ;Store
0475 22         =1  1628    IINC_1: RET
                =1  1629    ;
                    1630    ;=======
                    1631    ;IMUL:
                    1632    ;       Pop VAR from AES (two bytes).
                    1633    ;       TOS <= TOS * VAR
                =1  1634    $INCLUDE(AES\IMUL.ASM)
0476            =1  1635    MUL_16:
                =1  1636    ;       Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
                =1  1637    ;       on top of stack, and return with product on stack.
                =1  1638    ;       If product exceeds 16-bits, set OV flag.
                =1  1639    ;
                =1  1640    
0476 8F08       =1  1641            MOV     TMP0,TOS_H      ;Save first Part of equasion
0478 8E09       =1  1642            MOV     TMP1,TOS_L
047A 31C1       =1  1643            CALL    POP_TOS         ;Get other Part of equasion
                =1  1644    
                =1  1645                                    ;High-order byte of atleast one paramater must be 0.
047C E508       =1  1646            MOV     A,TMP0          ;Get High byte of first param
047E 6006       =1  1647            JZ      IMUL_SWAP       ;If 0 then reverse params before multipling
                =1  1648    
0480 EF         =1  1649            MOV     A,TOS_H         ;Get High byte of second param
0481 600D       =1  1650            JZ      IMUL_MUL        ;if 0 then pocede with multiply
                =1  1651                                    ;Error! Both values too large!
                =1  1652    
0483            =1  1653    IMUL_ERR:                       ;Jump to overflow erroe handeler
0483 021048     =1  1654            JMP     OV_ER
                =1  1655    
0486            =1  1656    IMUL_SWAP:                      ;Swap paramaters so that TOS_H is ALLWAYS zero!
0486 E508       =1  1657            MOV     A,TMP0          ;Swap high bytes
0488 8F08       =1  1658            MOV     TMP0,TOS_H
048A FF         =1  1659            MOV     TOS_H,A
                =1  1660    
048B E509       =1  1661            MOV     A,TMP1          ;Swap low bytes
048D 8E09       =1  1662            MOV     TMP1,TOS_L
048F FE         =1  1663            MOV     TOS_L,A
                =1  1664    
0490            =1  1665    IMUL_MUL:                       ;16 bit multiply
                =1  1666    
0490 E509       =1  1667            MOV     A,TMP1
0492 8EF0       =1  1668            MOV     B,TOS_L
0494 A4         =1  1669            MUL     AB              ;multiply low order bytes
0495 85F00A     =1  1670            MOV     TMP2,B          ;Save High Byte
0498 F50B       =1  1671            MOV     TMP3,A          ;Save Low Byte
LILBASIC        LilBasic (c)2002                                                                              PAGE 30

                =1  1672    
049A EE         =1  1673            MOV     A,TOS_L
049B 8508F0     =1  1674            MOV     B,TMP0
049E A4         =1  1675            MUL     AB              ;Multiply high bytes.
                =1  1676    
049F 10D2E1     =1  1677            JBC    OV,IMUL_ERR      ;Overflow Error! Somthing in B!; answer will be 3 bytes wide
                                                                                !
                =1  1678    
04A2 C3         =1  1679            CLR     C               ;Clear carry flag
04A3 350A       =1  1680            ADDC    A,TMP2          ;Add high bytes
04A5 40DC       =1  1681            JC      IMUL_ERR        ;Error! answer is 3 bytes wide !
                =1  1682    
04A7 FF         =1  1683            MOV     TOS_H,A         ;Get High byte of answer
04A8 AE0B       =1  1684            MOV     TOS_L,TMP3      ;Get Low byte of answer
                =1  1685    
04AA 31DF       =1  1686            CAll    PUSH_TOS        ;Push answer into stack
                =1  1687    
                =1  1688    
                =1  1689    
04AC 22         =1  1690            RET
                =1  1691    ;
                =1  1692    ;=======
                =1  1693    ;
                =1  1694    ;
04AD            =1  1695    IMUL:
                =1  1696    ;       Pop VAR from AES (two bytes).
                =1  1697    ;       TOS <= TOS * VAR
                =1  1698    ;
04AD C25A       =1  1699            CLR     SGN_FLG         ;Initialize sign monitor flag.
04AF 9137       =1  1700            CALL    IABS            ;Take absolute value of TOS.
04B1 31C1       =1  1701            CALL    POP_TOS         ;Pop top entry.
04B3 9137       =1  1702            CALL    IABS            ;Take absolute value of NOS.
04B5 9176       =1  1703            CALL    MUL_16
04B7 71E4       =1  1704            CALL    OV_TST          ;Check if OV relevent.
04B9 9144       =1  1705            CALL    NEG_IF_NEG
04BB 22         =1  1706            RET
                =1  1707    ;
                    1708    ;===============
                    1709    ;IDIV:
                    1710    ;       Pop VAR from AES (two bytes).
                    1711    ;       TOS <= TOS / VAR
                    1712    ;       If divide-by-zero attempted report error.
                    1713    ;IMOD:
                    1714    ;       Pop VAR from AES (two bytes).
                    1715    ;       TOS <= TOS mod VAR        (remainder)
                    1716    ;       If divide-by-zero attempted report error.
                =1  1717    $INCLUDE(AES\IDIV.ASM)
                =1  1718    
04BC D25C       =1  1719    IMOD:   SETB    MOD_FLG         ;Indicate modulo entry point.
04BE 8002       =1  1720            SJMP    IDIV_0
                =1  1721    ;
                =1  1722    ;=======
                =1  1723    ;
                =1  1724    ;
04C0            =1  1725    IDIV:
                =1  1726    ;       Pop VAR from AES (two bytes).
                =1  1727    ;       TOS <= TOS / VAR
                =1  1728    ;       If divide-by-zero attempted report error.
LILBASIC        LilBasic (c)2002                                                                              PAGE 31

                =1  1729    ;
04C0 C25C       =1  1730            CLR     MOD_FLG         ;Indicate division entry point.
04C2 D25A       =1  1731    IDIV_0: SETB    SGN_FLG         ;Initialize sign monitor flag.
04C4 9137       =1  1732            CALL    IABS
04C6 914B       =1  1733            CALL    NEG
04C8 31C1       =1  1734            CALL    POP_TOS
04CA EE         =1  1735            mov     a,tos_l
04CB 4F         =1  1736            ORL     A,TOS_H
04CC 605C       =1  1737            JZ      DIV_NG
04CE A25A       =1  1738            MOV     C,SGN_FLG
04D0 B05C       =1  1739            ANL     C,/MOD_FLG      ;Clear SGN_FLG if MOD funtion being done.
04D2 925A       =1  1740            MOV     SGN_FLG,C
04D4 9137       =1  1741            CALL    IABS
04D6 F509       =1  1742            MOV     TMP1,A
04D8 19         =1  1743            DEC     R1
                =1  1744 +1         PAGE    #0H             ;ZERO PAGE for AES
04D9 75A000     =1  1745 +1         MOV     P2,#0H
04DC E3         =1  1747            MOVX     A,@R1
04DD F508       =1  1748            MOV     TMP0,A
04DF E4         =1  1749            CLR     A
04E0 F50B       =1  1750            MOV     TMP3,A
04E2 F50A       =1  1751            MOV     TMP2,A
04E4 7D11       =1  1752            MOV     LP_CNT,#17
04E6 C3         =1  1753            CLR     C
04E7 8017       =1  1754            SJMP    DIV_RP
                =1  1755    ;
04E9 E50A       =1  1756    DIV_LP: MOV     A,TMP2
04EB 33         =1  1757            RLC     A
04EC F50A       =1  1758            MOV     TMP2,A
04EE C50B       =1  1759            XCH     A,TMP3
04F0 33         =1  1760            RLC     A
04F1 C50B       =1  1761            XCH     A,TMP3
04F3 2E         =1  1762            ADD     A,TOS_L
04F4 F50C       =1  1763            MOV     TMP4,A
04F6 E50B       =1  1764            MOV     A,TMP3
04F8 3F         =1  1765            ADDC    A,TOS_H
04F9 5005       =1  1766            JNC     DIV_RP
04FB 850C0A     =1  1767            MOV     TMP2,TMP4
04FE F50B       =1  1768            MOV     TMP3,A
0500 E508       =1  1769    DIV_RP: MOV     A,TMP0
0502 33         =1  1770            RLC     A
0503 F508       =1  1771            MOV     TMP0,A
0505 E509       =1  1772            MOV     A,TMP1
0507 33         =1  1773            RLC     A
0508 F509       =1  1774            MOV     TMP1,A
050A DDDD       =1  1775            DJNZ    LP_CNT,DIV_LP
050C 205C0D     =1  1776            JB      MOD_FLG,DIV_1
050F F50D       =1  1777            MOV     TMP5,A                  ;SAVE A
0511 E508       =1  1778            MOV     A,TMP0                  ;Mov TMP0 X data
0513 F3         =1  1779            MOVX     @R1,A
0514 09         =1  1780            INC     R1
0515 E509       =1  1781            MOV     A,TMP1                  ;Mov TMP1 X data
0517 F3         =1  1782            MOVX     @R1,A
0518 E50D       =1  1783            MOV     A,TMP5                  ;Restore A
051A 800B       =1  1784            SJMP    DIV_2
                =1  1785    ;
051C F50D       =1  1786    DIV_1:  MOV     TMP5,A                  ;Save A
051E E50A       =1  1787            MOV     A,TMP2                  ;Store TMP2 in X data
LILBASIC        LilBasic (c)2002                                                                              PAGE 32

0520 F3         =1  1788            MOVX     @R1,A
0521 09         =1  1789            INC     R1
0522 E50B       =1  1790            MOV     A,TMP3
0524 F3         =1  1791            MOVX     @R1,A
0525 E50D       =1  1792            MOV     A,TMP5
0527 9144       =1  1793    DIV_2:  CALL    NEG_IF_NEG
0529 22         =1  1794            RET
                =1  1795    ;
052A 61EB       =1  1796    DIV_NG: AJMP    EXP_OV          ;Report expression overflow.
                =1  1797    ;
                    1798    ;===============
                    1799    ;RND:
                    1800    ;       TOS <= rnd(TOS)
                    1801    ;       Generate a new 16-bit random number from 1 to TOS,
                    1802    ;       and push onto the AES.
                =1  1803    $INCLUDE(AES\RND.ASM)
052C            =1  1804    RND:
                =1  1805    ;       Generate a new 16-bit random number from RND_KEY,
                =1  1806    ;       and push onto the AES.
052C AE10       =1  1807            MOV     TOS_L,SEED_L            ;Get seed
052E AF11       =1  1808            MOV     TOS_H,SEED_H
0530 31DF       =1  1809            CALL    PUSH_TOS
                =1  1810    
0532 7E55       =1  1811            MOV     TOS_L,#LOW(25173)       ;Multiply by 25173
0534 7F62       =1  1812            MOV     TOS_H,#HIGH(25173)
0536 9176       =1  1813            CALL    MUL_16
                =1  1814    
0538 7E19       =1  1815            MOV     TOS_L,#LOW(13849)       ;Add 13894
053A 7F36       =1  1816            MOV     TOS_H,#HIGH(13849)
053C A91D       =1  1817            MOV     R1,AESP
053E 19         =1  1818            DEC     R1
053F 71F6       =1  1819            CALL    ADD_16
                =1  1820    
0541 31C1       =1  1821            CALL    POP_TOS
                =1  1822    ;
                =1  1823    ;???
                =1  1824    ; The code from here to label no_problem to cure a extraneous overflow if seed=8000h.
                =1  1825    ;???
                =1  1826    ;
0543 BE0007     =1  1827            cjne    tos_l,#0,no_problem
0546 BF8004     =1  1828            cjne    tos_h,#80h,no_problem
0549            =1  1829    big_problem:                               ; tos=8000h will generate an overflow
0549 7E2A       =1  1830            mov     tos_l,#low(12586)          ; when control gets to iabs.
054B 7F31       =1  1831            mov     tos_h,#high(12586)         ; Load the precalculated seed.
054D            =1  1832    no_problem:
054D 8E10       =1  1833            MOV     SEED_L,TOS_L
054F 8F11       =1  1834            MOV     SEED_H,TOS_H
0551 31DF       =1  1835            CALL    PUSH_TOS
0553 22         =1  1836            RET
                =1  1837    ;
                    1838    ;===============
                    1839    ;CMPR:
                    1840    ;       When CMPR is called, AES contains:
                    1841    ;       (TOS:)  VAR_2 (two bytes),
                    1842    ;               C_CODE (one byte),
                    1843    ;               VAR_1 (two bytes).
                    1844    ;       Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
                    1845    ;           If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
LILBASIC        LilBasic (c)2002                                                                              PAGE 33

                    1846    ;           If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
                    1847    ;           If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
                    1848    ;           If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
                    1849    ;           If C_CODE=001 then test whether (VAR_1) >  (VAR_2);           If C_CODE=011 then
                                                                                test whether (VAR_1) >= (VAR_2)
                    1850    ;       If true then return 0001H on AES;
                    1851    ;       otherwise return 0000H.
                =1  1852    $INCLUDE(AES\CMPR.ASM)
0554            =1  1853    CMPR:
                =1  1854    ;       When CMPR is called, AES contains:
                =1  1855    ;       (TOS:)  VAR_2 (two bytes),
                =1  1856    ;               C_CODE (one byte),
                =1  1857    ;               VAR_1 (two bytes).
                =1  1858    ;       Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
                =1  1859    ;           If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
                =1  1860    ;           If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
                =1  1861    ;           If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
                =1  1862    ;           If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
                =1  1863    ;           If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
                =1  1864    ;           If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
                =1  1865    ;       If true then return 0001H on AES;
                =1  1866    ;       otherwise return 0000H.
                =1  1867    ;
0554 31C1       =1  1868            CALL    POP_TOS
0556 31D6       =1  1869            CALL    POP_ACC
                =1  1870 +1         PAGE    #0H             ;ZERO PAGE for AES
0558 75A000     =1  1871 +1         MOV     P2,#0H
055B F5F0       =1  1873            MOV     B,A
055D A91D       =1  1874            MOV     R1,AESP
055F 19         =1  1875            DEC     R1
0560 C3         =1  1876            CLR     C               ;...in preparation for string subtract.
0561 E3         =1  1877            MOVX     A,@R1           ;Compare low-order parameter bytes.
0562 9E         =1  1878            SUBB    A,TOS_L
0563 09         =1  1879            INC     R1              ;Bump pointer.
                =1  1880    
0564 F50D       =1  1881            MOV     TMP5,A          ;Save difference and exchange A with @R1
0566 E3         =1  1882            MOVX    A,@R1
0567 C50D       =1  1883            XCH     A,TMP5
0569 F3         =1  1884            MOVX    @R1,A
056A C50D       =1  1885            XCH     A,TMP5
                =1  1886    
056C 205406     =1  1887            JB      HEXMOD,CMPR_4
056F 6480       =1  1888            XRL     A,#80H          ;Offset variable by 80H for unsigned compare.
0571 CF         =1  1889            XCH     A,TOS_H
0572 6480       =1  1890            XRL     A,#80H
0574 CF         =1  1891            XCH     A,TOS_H
0575 9F         =1  1892    CMPR_4: SUBB    A,TOS_H
                =1  1893    
                =1  1894    
0576 450D       =1  1895            ORL     A,TMP5           ;Add any non-zero high-order bits to acc.
0578 7004       =1  1896            JNZ     CMPR_1          ;Jump ahead VAR_1 <> VAR_2.
                =1  1897    ;
                =1  1898    ;       VAR_1 = VAR_2:
                =1  1899    ;
057A A2F1       =1  1900            MOV     C,B.1           ;Load VAR_1 = VAR_2 test flag.
057C 8008       =1  1901            SJMP    PUSH_C
                =1  1902    ;
057E 4004       =1  1903    CMPR_1: JC      CMPR_2          ;Jump ahead if VAR_1 < VAR_2.
LILBASIC        LilBasic (c)2002                                                                              PAGE 34

                =1  1904    ;
                =1  1905    ;       VAR_1 > VAR_2:
                =1  1906    ;
0580 A2F0       =1  1907            MOV     C,B.0           ;Load VAR_1 > VAR_2 test flag.
0582 8002       =1  1908            SJMP    PUSH_C
                =1  1909    ;
                =1  1910    ;       VAR_1 < VAR_2:
                =1  1911    ;
0584 A2F2       =1  1912    CMPR_2: MOV     C,B.2           ;Load VAR_1 < VAR_2 test flag.
0586 E4         =1  1913    PUSH_C: CLR     A
                =1  1914 +1         PAGE    #0H             ;ZERO PAGE for AES
0587 75A000     =1  1915 +1         MOV     P2,#0H
058A F3         =1  1917            MOVX     @R1,A
058B 33         =1  1918            RLC     A
058C 19         =1  1919            DEC     R1
058D F3         =1  1920            MOVX    @R1,A
058E 22         =1  1921            RET
                =1  1922    ;
                    1923    ;===============
                    1924    
                    1925    
                    1926    ;       BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
                    1927    ;       ===== ====== ======= ==== ======= ==========
                    1928    ;
                    1929    ;       The general methodology of the various parsing routines is as follows:
                    1930    ;       The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
                    1931    ;       source character or string to be parsed
                    1932    ;       by routines TST, TSTV, TSTN, TSTL, and TSTS.
                    1933    ;       GET_C reads the indicated character from the appropriate
                    1934    ;       program buffer space into acc. and returns.
                    1935    ;       READ_CHAR reads the character into CHAR as well as acc. and
                    1936    ;       increments the 16-bit pointer.
                    1937    ;       When done, each routine calls D_BLANK to remove any trailing spaces,
                    1938    ;       and leaves READ_CHAR ready to fetch the next non-blank character.
                    1939    ;
                    1940    ;=======
                    1941    ;REWIND
                    1942    ;       Reset Cursor to start of current program buffer space.
                =1  1943    $INCLUDE(AES\REWIND.ASM)
                =1  1944    ;REWIND
                =1  1945    ;       Reset Cursor to start of current program buffer space.
                =1  1946    ;
058F C259       =1  1947    REWIND: CLR     CHAR_FLG
0591 205105     =1  1948            JB      AUTO,REWROM             ;If auto executing from ROM, jump to REWROM
0594 7A20       =1  1949            MOV     PNTR_H,#HIGH(EXTRAM)
0596 7800       =1  1950            MOV     PNTR_L,#LOW(EXTRAM)
0598 22         =1  1951            RET
                =1  1952    ;
0599 205205     =1  1953    REWROM: JB      XAUTO,RWXROM            ;If Auto executig form Shared eXternal memory jump t
                                                                               o RWXROM
059C 7A1E       =1  1954            MOV     PNTR_H,#HIGH(DEMOPROG)
059E 7895       =1  1955            MOV     PNTR_L,#LOW(DEMOPROG)
05A0 22         =1  1956            RET
                =1  1957    ;
05A1 908002     =1  1958    RWXROM: MOV     DPTR,#XRAM      ;Set pointer to start of Xmem
05A4            =1  1959    REWIND_FIND_FILE:
05A4 E0         =1  1960            MOVX    A,@DPTR                 ;Search through mem till first 00H is found
05A5 A3         =1  1961            INC     DPTR
LILBASIC        LilBasic (c)2002                                                                              PAGE 35

05A6 70FC       =1  1962            JNZ     REWIND_FIND_FILE
05A8 AA83       =1  1963            MOV     PNTR_H,DPH              ;Return with pointer to first program in Xmem
05AA A882       =1  1964            MOV     PNTR_L,DPL
                =1  1965    
05AC 22         =1  1966            RET                             ;
                =1  1967    ;
                    1968    ;=======
                    1969    ;SAVE_PNTR:
                    1970    ;       Save PNTR variables in cursor.
                =1  1971    $INCLUDE(AES\SAVPNTR.ASM)
05AD            =1  1972    SAVE_PNTR:
                =1  1973    ;       Save PNTR variables in cursor.
                =1  1974    ;
05AD 8815       =1  1975            MOV     CURS_L,PNTR_L
05AF 8A16       =1  1976            MOV     CURS_H,PNTR_H
05B1 8C17       =1  1977            MOV     C_SAVE,CHAR
05B3 22         =1  1978            RET
                =1  1979    ;
                    1980    ;=======
                    1981    ;LOAD_PNTR:
                    1982    ;       Reload pointer with value saved earlier by SAVE_PNTR.
                =1  1983    $INCLUDE(AES\LOADPNTR.ASM)
05B4            =1  1984    LOAD_PNTR:
                =1  1985    ;       Reload pointer with value saved earlier by SAVE_PNTR.
                =1  1986    ;
05B4 AA16       =1  1987            MOV     PNTR_H,CURS_H
05B6 A815       =1  1988            MOV     PNTR_L,CURS_L
05B8 AC17       =1  1989            MOV     CHAR,C_SAVE
05BA 22         =1  1990            RET
                =1  1991    ;
                    1992    ;=======
                    1993    ;GET_C:
                    1994    ;       Read character from logical buffer space into A and return.
                    1995    ;GET_BUF:
                    1996    ;       Read character from active program buffer space into A and return.
                    1997    ;REREAD:
                    1998    ;       Re-Read charcter into Acc from CHAR
                    1999    ;
                    2000    ;READ_CHAR:
                    2001    ;       READ_CHAR first tests the state of CHAR_FLG.
                    2002    ;       If it is still cleared, the character most recently read from the line
                    2003    ;       buffer or program buffer has been processed, so read the next
                    2004    ;       character, bump the buffer pointer, and return with the character
                    2005    ;       in both Acc. and CHAR and the CHAR_FLG cleared.
                    2006    ;       If CHAR_FLG has been set by the parsing routines,
                    2007    ;       then CHAR still holds a previously read character which has
                    2008    ;       not yet been processed.  Read this character into Acc. and return
                    2009    ;       with CHAR_FLG again cleared.
                =1  2010    $INCLUDE(AES\READCHAR.ASM)
05BB            =1  2011    GET_C:
                =1  2012    ;       Read character from logical buffer space into A and return.
                =1  2013    ;
05BB 205305     =1  2014            JB      RUNMOD,GET_BUF   ; If program running,  Get char from Program (Get_Buff)
                =1  2015 +1         PAGE    #0H              ;Set page to 0 For AES
05BE 75A000     =1  2016 +1         MOV     P2,#0H
05C1 E2         =1  2018            MOVX    A,@PNTR_L        ;Read char from AES stack. Note: this read is in reverse di
                                                                               rection from POP ACC
05C2 22         =1  2019            RET
LILBASIC        LilBasic (c)2002                                                                              PAGE 36

                =1  2020    ;
05C3            =1  2021    GET_BUF:
                =1  2022    ;       Read character from active program buffer space into A and return.
05C3 20520E     =1  2023            JB      XAUTO,GETROM             ;Choose to read char from ROM/RAM space
                =1  2024    
05C6 C082       =1  2025            PUSH    DPL                     ;Save Data Pointer
05C8 C083       =1  2026            PUSH    DPH
05CA 8A83       =1  2027            MOV     DPH,PNTR_H              ;Select Address
05CC 8882       =1  2028            MOV     DPL,PNTR_L
05CE E0         =1  2029            MOVX    A,@DPTR                 ;Read from external address space.
05CF D083       =1  2030            POP     DPH                     ;Restore Data pointer
05D1 D082       =1  2031            POP     DPL
05D3 22         =1  2032            RET
                =1  2033    ;
05D4 E8         =1  2034    GETROM: MOV     A,PNTR_L
05D5 C582       =1  2035            XCH     A,DPL
05D7 CA         =1  2036            XCH     A,PNTR_H
05D8 C583       =1  2037            XCH     A,DPH
05DA F8         =1  2038            MOV     PNTR_L,A
05DB E4         =1  2039            CLR     A
05DC 93         =1  2040            MOVC    A,@A+DPTR
05DD C8         =1  2041            XCH     A,PNTR_L                ;Save char. and load old DPH.
05DE C583       =1  2042            XCH     A,DPH
05E0 CA         =1  2043            XCH     A,PNTR_H
05E1 C582       =1  2044            XCH     A,DPL
05E3 C8         =1  2045            XCH     A,PNTR_L                ;Store DPL and reload byte read.
05E4 22         =1  2046            RET
                =1  2047    ;
                =1  2048    ;=======
                =1  2049    ;
05E5            =1  2050    READ_CHAR:
                =1  2051    ;       READ_CHAR first tests the state of CHAR_FLG.
                =1  2052    ;       If it is still cleared, the character most recently read from the line
                =1  2053    ;       buffer or program buffer has been processed, so read the next
                =1  2054    ;       character, bump the buffer pointer, and return with the character
                =1  2055    ;       in both Acc. and CHAR and the CHAR_FLG cleared.
                =1  2056    ;       If CHAR_FLG has been set by the parsing routines,
                =1  2057    ;       then CHAR still holds a previously read character which has
                =1  2058    ;       not yet been processed.  Read this character into Acc. and return
                =1  2059    ;       with CHAR_FLG again cleared.
                =1  2060    ;
05E5 105909     =1  2061            JBC     CHAR_FLG,REREAD         ;If CHAR_FLG cleared, reread char and exit!
05E8 B1BB       =1  2062            CALL    GET_C                   ;Get Char
05EA FC         =1  2063            MOV     CHAR,A
05EB 08         =1  2064            INC     PNTR_L
05EC B80001     =1  2065            CJNE    PNTR_L,#00,RDCHDN
05EF 0A         =1  2066            INC     PNTR_H
05F0 22         =1  2067    RDCHDN: RET
                =1  2068    ;
05F1 EC         =1  2069    REREAD: MOV     A,CHAR
05F2 22         =1  2070            RET
                =1  2071    ;
                    2072    ;=======
                    2073    ;PUT_BUF:
                    2074    ;       Put the contents of the acc. into program buffer space
                    2075    ;       currently active at the address held in <DEST_H><DEST_L>.
                    2076    ;WRITE_CHAR:
                    2077    ;       Converse of READ_CHAR.
LILBASIC        LilBasic (c)2002                                                                              PAGE 37

                    2078    ;       Write contents of acc. into appropriate memory space (@DEST),
                    2079    ;       increment DEST, and return.
                =1  2080    $INCLUDE(AES\WRITECHR.ASM)
05F3            =1  2081    PUT_BUF:
                =1  2082    ;       Put the contents of the acc. into program buffer space
                =1  2083    ;       currently active at the address held in <DEST_H><DEST_L>.
                =1  2084    ;
05F3 20510E     =1  2085            JB      AUTO,PUTROM           ;If Auto Run, read from ROM
                =1  2086    
05F6 C083       =1  2087            PUSH    DPH
05F8 C082       =1  2088            PUSH    DPL
05FA 8B83       =1  2089            MOV     DPH,DEST_H
05FC 8982       =1  2090            MOV     DPL,DEST_L
05FE F0         =1  2091            MOVX    @DPTR,A
05FF D082       =1  2092            POP     DPL
0601 D083       =1  2093            POP     DPH
                =1  2094    
0603 22         =1  2095            RET
                =1  2096    ;
0604 020FF7     =1  2097    PUTROM: JMP     EXP_ER
                =1  2098    ;
                =1  2099    ;=======
                =1  2100    ;
0607            =1  2101    WRITE_CHAR:
                =1  2102    ;       Converse of READ_CHAR.
                =1  2103    ;       Write contents of acc. into appropriate memory space (@DEST),
                =1  2104    ;       increment DEST, and return.
                =1  2105    ;
0607 B1F3       =1  2106            CALL    PUT_BUF
0609 09         =1  2107            INC     DEST_L
060A B90001     =1  2108            CJNE    DEST_L,#00H,WRCH_1
060D 0B         =1  2109            INC     DEST_H
060E 22         =1  2110    WRCH_1: RET
                =1  2111    ;
                    2112    ;=======
                    2113    ;D_BLNK:
                    2114    ;       Remove leading blanks from BASIC source line, update cursor,
                    2115    ;       load first non-blank character into CHAR,
                    2116    ;       and leave pointer loaded with its address.
                    2117    ;       (This routine is jumped to by parsing routines when successful,
                    2118    ;       so set C before returning to original routines.)
                =1  2119    $INCLUDE(AES\D_BLNK.ASM)
060F            =1  2120    D_BLNK:
                =1  2121    ;       Remove leading blanks from BASIC source line, update cursor,
                =1  2122    ;       load first non-blank character into CHAR,
                =1  2123    ;       and leave pointer loaded with its address.
                =1  2124    ;       (This routine is jumped to by parsing routines when successful,
                =1  2125    ;       so set C before returning to original routines.)
                =1  2126    ;
060F B1E5       =1  2127            CALL    READ_CHAR
0611 6420       =1  2128            XRL     A,#' '          ;Verify that it is non-blank.
0613 60FA       =1  2129            JZ      D_BLNK          ;Loop until non-blank leading character.
0615 D259       =1  2130            SETB    CHAR_FLG
0617 D3         =1  2131            SETB    C
0618 22         =1  2132            RET                     ;Return to scanning code.
                =1  2133    ;
                    2134    ;=======
                    2135    ;SKPLIN
LILBASIC        LilBasic (c)2002                                                                              PAGE 38

                    2136    ;       Skip Cursor over entire BASIC source line, leaving
                    2137    ;       cursor pointing to character after terminating <CR>.
                    2138    ;SKPTXT
                    2139    ;       Skip remainder of line in progress, assuming line number
                    2140    ;       has already been passed over.
                    2141    ;       (Note that either byte of binary line number could be
                    2142    ;       mis-interpreted as a CR.)
                =1  2143    $INCLUDE(AES\SKPLIN.ASM)
                =1  2144    ;
                =1  2145    ;SKPLIN
                =1  2146    ;       Skip Cursor over entire BASIC source line, leaving
                =1  2147    ;       cursor pointing to character after terminating <CR>.
                =1  2148    ;SKPTXT
                =1  2149    ;       Skip remainder of line in progress, assuming line number
                =1  2150    ;       has already been passed over.
                =1  2151    ;       (Note that either byte of binary line number could be
                =1  2152    ;       mis-interpreted as a CR.)
                =1  2153    ;
                =1  2154    ;
0619 B1E5       =1  2155    SKPLIN: CALL    READ_CHAR
061B B1E5       =1  2156            CALL    READ_CHAR
061D B1E5       =1  2157    SKPTXT: CALL    READ_CHAR
061F B40DFB     =1  2158            CJNE    A,#CR,SKPTXT    ;Verify that it is non-<CR>.
0622 22         =1  2159            RET                     ;Return to scanning code.
                =1  2160    ;
                    2161    ;===================================================================================
                    2162    ;       Token recognition and processing routines.
                    2163    ;===================================================================================
                    2164    ;TST:
                    2165    ;       If "TEMPLATE" matches the BASIC character string read by
                    2166    ;       READ_CHAR then move pointer over string and any trailing blanks
                    2167    ;       and continue with the following IL instruction.
                    2168    ;       Otherwise leave pointer unchanged and branch to IL instruction at LBL.
                =1  2169    $INCLUDE(AES\TST.ASM)
0623            =1  2170    TST:
                =1  2171    ;       If "TEMPLATE" matches the BASIC character string read by
                =1  2172    ;       READ_CHAR then move pointer over string and any trailing blanks
                =1  2173    ;       and continue with the following IL instruction.
                =1  2174    ;       Otherwise leave pointer unchanged and branch to IL instruction at LBL.
                =1  2175    ;
0623 D083       =1  2176            POP     DPH             ;Get in-line parameter base address from stack.
0625 D082       =1  2177            POP     DPL
0627 B1E5       =1  2178            CALL    READ_CHAR       ;Get Next Char to be parsed
                =1  2179    
0629 EC         =1  2180            MOV     A,CHAR
062A 310C       =1  2181            CALL    UPPER           ;Convert to uppercase
062C FC         =1  2182            MOV     CHAR,A
                =1  2183    
062D B1AD       =1  2184            CALL    SAVE_PNTR
062F E4         =1  2185    TST_1:  CLR     A
0630 93         =1  2186            MOVC    A,@A+DPTR       ;Read next character from template string.
0631 A2E7       =1  2187            MOV     C,ACC.7         ;Save terminator bit.
0633 547F       =1  2188            ANL     A,#7FH          ;Mask off terminator.
0635 6C         =1  2189            XRL     A,CHAR          ;Compare with template.
0636 700F       =1  2190            JNZ     T_BAD           ;Abort if first characters miscompare.
0638 A3         =1  2191            INC     DPTR            ;Pass over template character just checked.
0639 4008       =1  2192            JC      T_GOOD          ;Done if template character bit 7 set.
063B B1E5       =1  2193            CALL    READ_CHAR       ;Fetch next character for test.
LILBASIC        LilBasic (c)2002                                                                              PAGE 39

                =1  2194    
063D EC         =1  2195            MOV     A,CHAR
063E 310C       =1  2196            CALL    UPPER           ;Convert to uppercase
0640 FC         =1  2197            MOV     CHAR,A
                =1  2198    
0641 80EC       =1  2199            SJMP    TST_1           ;Continue
                =1  2200    ;        CJNE    CHAR,#'.',TST_1 ;Done if input string abbreviated at this point
                =1  2201    ;TST_2:  CLR     A               ;Fetch template characters until end of string
                =1  2202    ;        MOVC    A,@A+DPTR
                =1  2203    ;        INC     DPTR
                =1  2204    ;        JNB     ACC.7,TST_2     ;Loop until last character detected.
0643 D10F       =1  2205    T_GOOD: CALL    D_BLNK
0645 E4         =1  2206            CLR     A
0646 73         =1  2207            JMP     @A+DPTR         ;Return to next IL instruction
                =1  2208    ;
                =1  2209    ;       Strings do not match.  Leave cursor at start of string.
                =1  2210    ;
0647 E4         =1  2211    T_BAD:  CLR     A
0648 93         =1  2212            MOVC    A,@A+DPTR       ;Search for final template character.
0649 A3         =1  2213            INC     DPTR
064A 30E7FA     =1  2214            JNB     ACC.7,T_BAD     ;Loop until terminator found.
064D B1B4       =1  2215            CALL    LOAD_PNTR
064F D259       =1  2216            SETB    CHAR_FLG
0651 C3         =1  2217            CLR     C               ;Mark string not found.
0652 E4         =1  2218            CLR     A
0653 73         =1  2219            JMP     @A+DPTR         ;Return to mismatch branch instruction.
                =1  2220    ;
                    2221    ;=====
                    2222    ;TSTV   (LBL)
                    2223    ;
                    2224    ;       Test if first non-blank string is a legal variable symbol.
                    2225    ;       If so, move cursor over string and any trailing blanks,
                    2226    ;       compute variable index value,
                    2227    ;       push onto arithmetic expression stack,
                    2228    ;       and continue with following IL instruction.
                    2229    ;       Otherwise branch to IL instruction at LBL with cursor unaffected.
                    2230    ;       Contains PASVAL subrutines.
                =1  2231    $INCLUDE(AES\TSTV.ASM)
                =1  2232    ;TSTV   (LBL)
                =1  2233    ;
                =1  2234    ;
0654            =1  2235    TSTV:
                =1  2236    ;       Test if first non-blank string is a legal variable symbol.
                =1  2237    ;       If so, move cursor over string and any trailing blanks,
                =1  2238    ;       compute variable index value,
                =1  2239    ;       push onto arithmetic expression stack,
                =1  2240    ;       and continue with following IL instruction.
                =1  2241    ;       Otherwise branch to IL instruction at LBL with cursor unaffected.
                =1  2242    ;
0654 B1E5       =1  2243            CALL    READ_CHAR       ;Get next parsed char
0656 310C       =1  2244            CALL    UPPER           ;Convert to upper case
0658 24BF       =1  2245            ADD     A,#-'A'         ;Subtract offset for base variable.
065A FE         =1  2246            MOV     TOS_L,A         ;Save index in case needed later.
065B 24E6       =1  2247            ADD     A,#-26
065D 5004       =1  2248            JNC     ALPHAB          ;First character is alphabetic if C=0.
065F D259       =1  2249            SETB    CHAR_FLG
0661 C3         =1  2250            CLR     C
0662 22         =1  2251            RET
LILBASIC        LilBasic (c)2002                                                                              PAGE 40

                =1  2252    ;
0663 B1AD       =1  2253    ALPHAB: CALL    SAVE_PNTR       ;In case variable name not found.
0665 B1E5       =1  2254            CALL    READ_CHAR       ;Verify that next character is not alphabetic.
0667 310C       =1  2255            CALL    UPPER
0669 24BF       =1  2256            ADD     A,#-'A'         ;Alphabetic characters now <= 25.
066B 24E6       =1  2257            ADD     A,#-26          ;Non-alphabetics cause overflow.
066D 5003       =1  2258            JNC     NOTVAR          ;Alphabetic character means illegal var. name.
066F 0207AB     =1  2259            JMP    TSTV_1          ;Jump to exit routine
                =1  2260    
                =1  2261    ;=====
0672 B1B4       =1  2262    NOTVAR: CALL    LOAD_PNTR       ;IF not an Inerger Varable.
0674 D259       =1  2263            SETB    CHAR_FLG
                =1  2264                                    ;Check to see if it is a reserved Variable name
                =2  2265    $INCLUDE(AES\PASVAL\PORT.ASM)
0676            =2  2266    PORT1:
0676 D123       =2  2267            call tst                ; Test it 'PORT' token
0678 504F52D4   =2  2268            db      'POR',('T' OR 80H )
067C 500B       =2  2269            JNC     PORT1_END
                =2  2270 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
067E 5110       =2  2271 +1         CALL    LIT
0680 01         =2  2272 +1         DB      01H
                =2  2274 +1         LIT_    90H             ;Push low byte of ADDR onto Stack
0681 5110       =2  2275 +1         CALL    LIT
0683 90         =2  2276 +1         DB      90H
                =2  2278 +1         LIT_    00H             ;Push high byte of ADDR onto Stack
0684 5110       =2  2279 +1         CALL    LIT
0686 00         =2  2280 +1         DB      00H
0687 8086       =2  2282            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2283                                    ;and continue
0689            =2  2284    PORT1_END:
                =2  2285    $INCLUDE(AES\PASVAL\ERROR.ASM)
                =2  2286    
0689            =2  2287    TST_ERROR:
0689 D123       =2  2288            call tst                ; Test it 'ERROR' token
068B 4552524F   =2  2289            db      'ERRO',('R' OR 80H )
068F D2         
0690 500B       =2  2290            JNC     TST_ERROR_END
                =2  2291 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0692 5110       =2  2292 +1         CALL    LIT
0694 01         =2  2293 +1         DB      01H
                =2  2295 +1         LIT_    LOW(ERROR)      ;Push low byte of ADDR onto Stack
0695 5110       =2  2296 +1         CALL    LIT
0697 1A         =2  2297 +1         DB      LOW(ERROR)
                =2  2299 +1         LIT_    HIGH(ERROR)     ;Push high byte of ADDR onto Stack
0698 5110       =2  2300 +1         CALL    LIT
069A 00         =2  2301 +1         DB      HIGH(ERROR)
069B C10F       =2  2303            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2304                                    ;and continue
069D            =2  2305    TST_ERROR_END:
                =2  2306    $INCLUDE(AES\PASVAL\TIMER.ASM)
                =2  2307    
069D            =2  2308    TST_TIMER:
069D D123       =2  2309            call tst                ; Test it 'TIMER' token
069F 54494D45   =2  2310            db      'TIME',('R' OR 80H )
06A3 D2         
06A4 500B       =2  2311            JNC     TST_TIMER_END
                =2  2312 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06A6 5110       =2  2313 +1         CALL    LIT
LILBASIC        LilBasic (c)2002                                                                              PAGE 41

06A8 01         =2  2314 +1         DB      01H
                =2  2316 +1         LIT_    LOW(TIMER1)     ;Push low byte of ADDR onto Stack
06A9 5110       =2  2317 +1         CALL    LIT
06AB 1F         =2  2318 +1         DB      LOW(TIMER1)
                =2  2320 +1         LIT_    HIGH(TIMER1)    ;Push high byte of ADDR onto Stack
06AC 5110       =2  2321 +1         CALL    LIT
06AE 00         =2  2322 +1         DB      HIGH(TIMER1)
06AF C10F       =2  2324            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2325                                    ;and continue
06B1            =2  2326    TST_TIMER_END:
                =2  2327    $INCLUDE(AES\PASVAL\FREQ.ASM)
                =2  2328    
06B1            =2  2329    TST_FREQ:
06B1 D123       =2  2330            call tst                ; Test it 'FREQ' token
06B3 465245D1   =2  2331            db      'FRE',('Q' OR 80H )
06B7 500B       =2  2332            JNC     TST_FREQ_END
                =2  2333 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06B9 5110       =2  2334 +1         CALL    LIT
06BB 01         =2  2335 +1         DB      01H
                =2  2337 +1         LIT_    LOW(TH0)        ;Push low byte of ADDR onto Stack
06BC 5110       =2  2338 +1         CALL    LIT
06BE 8C         =2  2339 +1         DB      LOW(TH0)
                =2  2341 +1         LIT_    HIGH(TH0)       ;Push high byte of ADDR onto Stack
06BF 5110       =2  2342 +1         CALL    LIT
06C1 00         =2  2343 +1         DB      HIGH(TH0)
06C2 C10F       =2  2345            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2346                                    ;and continue
06C4            =2  2347    TST_FREQ_END:
                =2  2348    $INCLUDE(AES\PASVAL\MASK.ASM)
                =2  2349    
06C4            =2  2350    TST_MASK:
06C4 D123       =2  2351            call tst                ; Test it 'MASK' token
06C6 4D4153CB   =2  2352            db      'MAS',('K' OR 80H )
06CA 500B       =2  2353            JNC     TST_MASK_END
                =2  2354 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06CC 5110       =2  2355 +1         CALL    LIT
06CE 01         =2  2356 +1         DB      01H
                =2  2358 +1         LIT_    LOW(PRT_MSK)    ;Push low byte of ADDR onto Stack
06CF 5110       =2  2359 +1         CALL    LIT
06D1 28         =2  2360 +1         DB      LOW(PRT_MSK)
                =2  2362 +1         LIT_    HIGH(PRT_MSK)   ;Push high byte of ADDR onto Stack
06D2 5110       =2  2363 +1         CALL    LIT
06D4 00         =2  2364 +1         DB      HIGH(PRT_MSK)
06D5 C10F       =2  2366            JMP     D_BLNK          ;Remove leading blanks from source line.
06D7            =2  2367    TST_MASK_END:
                =2  2368    $INCLUDE(AES\PASVAL\PWM.ASM)
                =2  2369    
06D7            =2  2370    TST_PWM0:                       ; Test it 'PWM0' token
06D7 D123       =2  2371            call tst
06D9 50574DB0   =2  2372            db      'PWM',('0' OR 80H )
06DD 500B       =2  2373            JNC     TST_PWM1
                =2  2374 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06DF 5110       =2  2375 +1         CALL    LIT
06E1 01         =2  2376 +1         DB      01H
                =2  2378 +1         LIT_    LOW(PWM0)    ;Push low byte of ADDR onto Stack
06E2 5110       =2  2379 +1         CALL    LIT
06E4 20         =2  2380 +1         DB      LOW(PWM0)
                =2  2382 +1         LIT_    HIGH(PWM0)   ;Push high byte of ADDR onto Stack
LILBASIC        LilBasic (c)2002                                                                              PAGE 42

06E5 5110       =2  2383 +1         CALL    LIT
06E7 00         =2  2384 +1         DB      HIGH(PWM0)
06E8 C10F       =2  2386            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2387    
06EA            =2  2388    TST_PWM1:                       ; Test it 'PWM0' token
06EA D123       =2  2389            call tst
06EC 50574DB1   =2  2390            db      'PWM',('1' OR 80H )
06F0 500B       =2  2391            JNC     TST_PWM2
                =2  2392 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
06F2 5110       =2  2393 +1         CALL    LIT
06F4 01         =2  2394 +1         DB      01H
                =2  2396 +1         LIT_    LOW(PWM2)    ;Push low byte of ADDR onto Stack
06F5 5110       =2  2397 +1         CALL    LIT
06F7 22         =2  2398 +1         DB      LOW(PWM2)
                =2  2400 +1         LIT_    HIGH(PWM2)   ;Push high byte of ADDR onto Stack
06F8 5110       =2  2401 +1         CALL    LIT
06FA 00         =2  2402 +1         DB      HIGH(PWM2)
06FB C10F       =2  2404            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2405    
                =2  2406    ;
                =2  2407    
06FD            =2  2408    TST_PWM2:                       ; Test it 'PWM0' token
06FD D123       =2  2409            call tst
06FF 50574DB2   =2  2410            db      'PWM',('2' OR 80H )
0703 500B       =2  2411            JNC     TST_PWM3
                =2  2412 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0705 5110       =2  2413 +1         CALL    LIT
0707 01         =2  2414 +1         DB      01H
                =2  2416 +1         LIT_    LOW(PWM2)    ;Push low byte of ADDR onto Stack
0708 5110       =2  2417 +1         CALL    LIT
070A 22         =2  2418 +1         DB      LOW(PWM2)
                =2  2420 +1         LIT_    HIGH(PWM2)   ;Push high byte of ADDR onto Stack
070B 5110       =2  2421 +1         CALL    LIT
070D 00         =2  2422 +1         DB      HIGH(PWM2)
070E C10F       =2  2424            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2425    
0710            =2  2426    TST_PWM3:                       ; Test it 'PWM0' token
0710 D123       =2  2427            call tst
0712 50574DB3   =2  2428            db      'PWM',('3' OR 80H )
0716 500B       =2  2429            JNC     TST_PWM4
                =2  2430 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0718 5110       =2  2431 +1         CALL    LIT
071A 01         =2  2432 +1         DB      01H
                =2  2434 +1         LIT_    LOW(PWM3)    ;Push low byte of ADDR onto Stack
071B 5110       =2  2435 +1         CALL    LIT
071D 23         =2  2436 +1         DB      LOW(PWM3)
                =2  2438 +1         LIT_    HIGH(PWM3)   ;Push high byte of ADDR onto Stack
071E 5110       =2  2439 +1         CALL    LIT
0720 00         =2  2440 +1         DB      HIGH(PWM3)
0721 C10F       =2  2442            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2443    
0723            =2  2444    TST_PWM4:                       ; Test it 'PWM0' token
0723 D123       =2  2445            call tst
0725 50574DB4   =2  2446            db      'PWM',('4' OR 80H )
0729 500B       =2  2447            JNC     TST_PWM5
                =2  2448 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
072B 5110       =2  2449 +1         CALL    LIT
072D 01         =2  2450 +1         DB      01H
LILBASIC        LilBasic (c)2002                                                                              PAGE 43

                =2  2452 +1         LIT_    LOW(PWM4)    ;Push low byte of ADDR onto Stack
072E 5110       =2  2453 +1         CALL    LIT
0730 24         =2  2454 +1         DB      LOW(PWM4)
                =2  2456 +1         LIT_    HIGH(PWM4)   ;Push high byte of ADDR onto Stack
0731 5110       =2  2457 +1         CALL    LIT
0733 00         =2  2458 +1         DB      HIGH(PWM4)
0734 C10F       =2  2460            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2461    
0736            =2  2462    TST_PWM5:                       ; Test it 'PWM0' token
0736 D123       =2  2463            call tst
0738 50574DB5   =2  2464            db      'PWM',('5' OR 80H )
073C 500B       =2  2465            JNC     TST_PWM6
                =2  2466 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
073E 5110       =2  2467 +1         CALL    LIT
0740 01         =2  2468 +1         DB      01H
                =2  2470 +1         LIT_    LOW(PWM6)    ;Push low byte of ADDR onto Stack
0741 5110       =2  2471 +1         CALL    LIT
0743 26         =2  2472 +1         DB      LOW(PWM6)
                =2  2474 +1         LIT_    HIGH(PWM6)   ;Push high byte of ADDR onto Stack
0744 5110       =2  2475 +1         CALL    LIT
0746 00         =2  2476 +1         DB      HIGH(PWM6)
0747 C10F       =2  2478            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2479    
0749            =2  2480    TST_PWM6:                       ; Test it 'PWM0' token
0749 D123       =2  2481            call tst
074B 50574DB6   =2  2482            db      'PWM',('6' OR 80H )
074F 500B       =2  2483            JNC     TST_PWM7
                =2  2484 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0751 5110       =2  2485 +1         CALL    LIT
0753 01         =2  2486 +1         DB      01H
                =2  2488 +1         LIT_    LOW(PWM6)    ;Push low byte of ADDR onto Stack
0754 5110       =2  2489 +1         CALL    LIT
0756 26         =2  2490 +1         DB      LOW(PWM6)
                =2  2492 +1         LIT_    HIGH(PWM6)   ;Push high byte of ADDR onto Stack
0757 5110       =2  2493 +1         CALL    LIT
0759 00         =2  2494 +1         DB      HIGH(PWM6)
075A C10F       =2  2496            JMP     D_BLNK          ;Remove leading blanks from source line.
                =2  2497    
075C            =2  2498    TST_PWM7:                       ; Test it 'PWM0' token
075C D123       =2  2499            call tst
075E 50574DB7   =2  2500            db      'PWM',('7' OR 80H )
0762 500B       =2  2501            JNC     TST_PWM_END
                =2  2502 +1         LIT_    01H             ;Push a 1 for DBYTE addr onto stack
0764 5110       =2  2503 +1         CALL    LIT
0766 01         =2  2504 +1         DB      01H
                =2  2506 +1         LIT_    LOW(PWM7)    ;Push low byte of ADDR onto Stack
0767 5110       =2  2507 +1         CALL    LIT
0769 27         =2  2508 +1         DB      LOW(PWM7)
                =2  2510 +1         LIT_    HIGH(PWM7)   ;Push high byte of ADDR onto Stack
076A 5110       =2  2511 +1         CALL    LIT
076C 00         =2  2512 +1         DB      HIGH(PWM7)
076D C10F       =2  2514            JMP     D_BLNK          ;Remove leading blanks from source line.
076F            =2  2515    TST_PWM_END:
                =2  2516    $INCLUDE(AES\PASVAL\DBYTE.ASM)
076F            =2  2517    tst_dbyte:
076F D123       =2  2518            call   tst                ;Test if 'DBYTE' token.
0771 44425954   =2  2519            db      'DBYT',('E' OR 80H)
0775 C5         
LILBASIC        LilBasic (c)2002                                                                              PAGE 44

0776 5005       =2  2520            jnc     tst_dbyte_end
                =2  2521 +1         LIT_    1                 ; Push a 1 onto AES STACK
0778 5110       =2  2522 +1         CALL    LIT
077A 01         =2  2523 +1         DB      1
077B 8029       =2  2525            SJMP    INDEX
077D            =2  2526    tst_dbyte_end:
                =2  2527    $INCLUDE(AES\PASVAL\RBIT.ASM)
077D            =2  2528    TST_RBIT:
077D D123       =2  2529            call   tst                ;Test for RBIT
077F 524249D4   =2  2530            db      'RBI',('T' OR 80H)
0783 5005       =2  2531            jnc     TST_RBIT_END
                =2  2532 +1         LIT_    2                 ; PUSH a 2 onto AES STACK
0785 5110       =2  2533 +1         CALL    LIT
0787 02         =2  2534 +1         DB      2
0788 801C       =2  2536            SJMP    INDEX
078A            =2  2537    TST_RBIT_END:
                =2  2538    $INCLUDE(AES\PASVAL\XBYTE.ASM)
078A            =2  2539    TST_XBYTE:
078A D123       =2  2540            call   tst                ;Test for Xbyte
078C 58425954   =2  2541            db      'XBYT',('E' OR 80H)
0790 C5         
0791 5005       =2  2542            jnc     TST_XBYTE_END
                =2  2543 +1         LIT_    3                 ; PUSH a 3 ONTO AES STACK
0793 5110       =2  2544 +1         CALL    LIT
0795 03         =2  2545 +1         DB      3
0796 800E       =2  2547            SJMP    INDEX
0798            =2  2548    TST_XBYTE_END:
                =2  2549    $INCLUDE(AES\PASVAL\CBYTE.ASM)
0798            =2  2550    TST_CBYTE:
0798 D123       =2  2551            call   tst
079A 43425954   =2  2552            db      'CBYT',('E' OR 80H)
079E C5         
079F 5003       =2  2553            jnc     TST_CBYTE_END
                =2  2554 +1         LIT_    4
07A1 5110       =2  2555 +1         CALL    LIT
07A3 04         =2  2556 +1         DB      4
07A4            =2  2558    TST_CBYTE_END:
                =1  2559    
07A4 C3         =1  2560    NOTSYM: CLR     C               ;Indicate that condition tested wasn't true.
07A5 22         =1  2561            RET
                =1  2562    ;==============================================================================
                =1  2563    ;
07A6 12110F     =1  2564    INDEX:  CALL    VAR               ;Get value of Next variable
07A9 D3         =1  2565            SETB    C                 ;Set to true
07AA 22         =1  2566            RET
                =1  2567    ;==============================================================================
                =1  2568    ;
                =1  2569    ;
                =1  2570    ;       BASIC Variable name is legitimate (A-Z).
                =1  2571    ;
                =1  2572 +1 TSTV_1: LIT_    0               ;Push a 0 onto AES (Varable)
07AB 5110       =1  2573 +1         CALL    LIT
07AD 00         =1  2574 +1         DB      0
07AE 7F00       =1  2576            MOV     TOS_H,#0        ;Clear High byte.
07B0 31DF       =1  2577            CALL    PUSH_TOS        ;Push var. (A-Z) onto stack as 16 bit # 1-26
07B2 D259       =1  2578            SETB    CHAR_FLG        ;
07B4 C10F       =1  2579            JMP     D_BLNK          ;Remove leading blanks from source line.
                =1  2580                                    ;and return
LILBASIC        LilBasic (c)2002                                                                              PAGE 45

                =1  2581    ;
                    2582    ;===============
                    2583    ;TSTN   (LBL)
                    2584    ;       Test if indicated string is an unsigned number.
                    2585    ;       If so, move cursor over string and trailing blanks,
                    2586    ;       compute number's binary value,
                    2587    ;       push onto arithmetic expression stack, and continue with
                    2588    ;       following IL instruction.
                    2589    ;       Otherwise restore cursor and branch to IL instruction at LBL.
                    2590    ;
                    2591    ;TSTL   (LBL)
                    2592    ;       Test if first non-blank string is a BASIC source line number.
                    2593    ;       If so, move cursor over string and following blanks,
                    2594    ;       compute number's binary value,
                    2595    ;       push onto arithmetic expression stack,
                    2596    ;       and continue with next IL instruction.
                    2597    ;       If invalid source line number report syntax error.
                    2598    ;       If line number not present restore cursor
                    2599    ;       and branch to IL instruction at LBL.
                    2600    ;
                =1  2601    $INCLUDE(AES\TSTN.ASM)
                =1  2602    ;TSTN   (LBL)
                =1  2603    ;       Test if indicated string is an unsigned number.
                =1  2604    ;       If so, move cursor over string and trailing blanks,
                =1  2605    ;       compute number's binary value,
                =1  2606    ;       push onto arithmetic expression stack, and continue with
                =1  2607    ;       following IL instruction.
                =1  2608    ;       Otherwise restore cursor and branch to IL instruction at LBL.
                =1  2609    ;
                =1  2610    ;
07B6 B1E5       =1  2611    TSTN:   CALL    READ_CHAR
07B8 7190       =1  2612            CALL    CREATE          ;Create entry on AES if legit. digit.
07BA 4003       =1  2613            JC      TSTN_1          ;Abort if CHAR is not decimal digit.
07BC D259       =1  2614            SETB    CHAR_FLG
07BE 22         =1  2615            RET
                =1  2616    ;
07BF B1E5       =1  2617    TSTN_1: CALL    READ_CHAR       ;Move over matched character.
07C1 719D       =1  2618            CALL    APPEND          ;Append new digit to entry on TOS.
07C3 40FA       =1  2619            JC      TSTN_1          ;Continue processing while legal characters.
07C5 31DF       =1  2620            CALL    PUSH_TOS
07C7 D259       =1  2621            SETB    CHAR_FLG
07C9 C10F       =1  2622            JMP     D_BLNK          ;Remove leading blank characters.
                =1  2623    ;
                    2624    ;===============
                    2625    ;TSTS   (LBL)
                    2626    ;       Test if first character is a quote.
                    2627    ;       If so, print characters from the BASIC source program to the console
                    2628    ;       until a (closing) quote is encountered,
                    2629    ;       pass over any trailing blanks,
                    2630    ;       leave source cursor pointing to first non-blank character,
                    2631    ;       and branch to IL instruction at location (LBL).
                    2632    ;       (Report syntax error if <CR> encountered before quote.)
                    2633    ;       If first character is not a quote, return to next
                    2634    ;       sequential IL instruction with cursor unchanged.
                    2635    ;
                =1  2636    $INCLUDE(AES\TSTS.ASM)
                =1  2637    ;TSTS   (LBL)
                =1  2638    ;       Test if first character is a quote.
LILBASIC        LilBasic (c)2002                                                                              PAGE 46

                =1  2639    ;       If so, print characters from the BASIC source program to the console
                =1  2640    ;       until a (closing) quote is encountered,
                =1  2641    ;       pass over any trailing blanks,
                =1  2642    ;       leave source cursor pointing to first non-blank character,
                =1  2643    ;       and branch to IL instruction at location (LBL).
                =1  2644    ;       (Report syntax error if <CR> encountered before quote.)
                =1  2645    ;       If first character is not a quote, return to next
                =1  2646    ;       sequential IL instruction with cursor unchanged.
                =1  2647    ;
07CB B1E5       =1  2648    TSTS:   CALL    READ_CHAR
07CD F508       =1  2649            MOV     TMP0,A
07CF 6422       =1  2650            XRL     A,#'"'
07D1 6008       =1  2651            JZ      TSTS_1
07D3 6405       =1  2652            XRL     A,#'''' XOR '"'
07D5 6004       =1  2653            JZ      TSTS_1
07D7 C3         =1  2654            CLR     C
07D8 D259       =1  2655            SETB    CHAR_FLG
07DA 22         =1  2656            RET
                =1  2657    ;
07DB B1E5       =1  2658    TSTS_1: CALL    READ_CHAR       ;Read next string character.
07DD B50802     =1  2659            CJNE    A,TMP0,TSTS_2
07E0 C10F       =1  2660            JMP     D_BLNK
                =1  2661    ;
07E2 312A       =1  2662    TSTS_2: CALL    C_OUT           ;Call output routine.
07E4 B40DF4     =1  2663            CJNE    A,#CR,TSTS_1    ;<CR> before closing quote is illegal.
07E7 02102E     =1  2664            JMP     SYN_ER          ;Transmit error message.
                =1  2665    ;
                    2666    ;========
                    2667    ;DONE
                    2668    ;       Delete leading blanks from the BASIC source line.
                    2669    ;       Return with the cursor positioned over the first non-blank
                    2670    ;       character, which must be a colon or <CR> in the source line.
                    2671    ;       If any other characters are encountered report a syntax error.
                =1  2672    $INCLUDE(AES\DONE.ASM)
                =1  2673    ;DONE
                =1  2674    ;       Delete leading blanks from the BASIC source line.
                =1  2675    ;       Return with the cursor positioned over the first non-blank
                =1  2676    ;       character, which must be a colon or <CR> in the source line.
                =1  2677    ;       If any other characters are encountered report a syntax error.
                =1  2678    ;
                =1  2679    ;
                =1  2680    ;
07EA B1E5       =1  2681    DONE:   CALL    READ_CHAR
07EC BC3A03     =1  2682            CJNE    CHAR,#':',DONE_1        ;Colon indicates resume interpretation.
07EF 22         =1  2683            RET                     ;Return to IL.
                =1  2684    ;
07F0 B1E5       =1  2685    LNDONE: CALL    READ_CHAR
07F2 BC0D01     =1  2686    DONE_1: CJNE    CHAR,#CR,DONE_2 ;Any non-colon, non-CR characters are illegal.
07F5 22         =1  2687            RET
                =1  2688    ;
07F6 D259       =1  2689    DONE_2: SETB    CHAR_FLG
07F8 02102E     =1  2690            JMP     SYN_ER          ;Process syntax error if so.
                =1  2691    ;
                    2692    ;=======
                    2693    ;IFDONE (LBL)
                    2694    ;       If the first non-blank character is a colon or <CR> in the source line
                    2695    ;       then branch to the IL instruction specified by (LBL).
                    2696    ;       If any other characters are encountered
LILBASIC        LilBasic (c)2002                                                                              PAGE 47

                    2697    ;       then continue with next IL instruction.
                    2698    ;
                =1  2699    $INCLUDE(AES\IFDONE.ASM)
                =1  2700    ;IFDONE (LBL)
                =1  2701    ;       If the first non-blank character is a colon or <CR> in the source line
                =1  2702    ;       then branch to the IL instruction specified by (LBL).
                =1  2703    ;       If any other characters are encountered
                =1  2704    ;       then continue with next IL instruction.
                =1  2705    ;
                =1  2706    ;
07FB B1E5       =1  2707    IFDONE: CALL    READ_CHAR
07FD BC3A01     =1  2708            CJNE    CHAR,#':',IFDN_1        ;Colon indicates resume interpretation.
0800 22         =1  2709            RET                     ;Return to IL.
                =1  2710    ;
0801 BC0D01     =1  2711    IFDN_1: CJNE    CHAR,#CR,IFDN_2 ;Any non-colon, non-CR characters are illegal.
0804 22         =1  2712            RET
                =1  2713    ;
0805 D259       =1  2714    IFDN_2: SETB    CHAR_FLG
0807 D3         =1  2715            SETB    C
0808 22         =1  2716            RET
                =1  2717    ;
                    2718    ;=======
                    2719    ;READ_LABEL
                    2720    ;       Read next two characters from program buffer into <LABL_H><LABL_L>.
                    2721    ;       Return with carry set if bit 15 of LABL is set (indicating EOF).
                =1  2722    $INCLUDE(AES\R_LABEL.ASM)
0809            =1  2723    READ_LABEL:
                =1  2724    ;       Read next two characters from program buffer into <LABL_H><LABL_L>.
                =1  2725    ;       Return with carry set if bit 15 of LABL is set (indicating EOF).
                =1  2726    ;
0809 1205E5     =1  2727            CALL    READ_CHAR
080C F519       =1  2728            MOV     LABL_H,A
080E 1205E5     =1  2729            CALL    READ_CHAR
0811 F518       =1  2730            MOV     LABL_L,A
0813 E519       =1  2731            MOV     A,LABL_H
0815 A2E7       =1  2732            MOV     C,ACC.7
0817 22         =1  2733            RET
                =1  2734    ;
                    2735    ;=======
                    2736    ;L_INIT:
                    2737    ;       Initialize for execution of new BASIC source line.
                    2738    ;       If none present, or if not in sequential execution mode,
                    2739    ;       then return to line collection operation.
                =1  2740    $INCLUDE(AES\LINIT.ASM)
0818            =1  2741    L_INIT:
                =1  2742    ;       Initialize for execution of new BASIC source line.
                =1  2743    ;       If none present, or if not in sequential execution mode,
                =1  2744    ;       then return to line collection operation.
                =1  2745    ;
0818 305302     =1  2746            JNB     RUNMOD,LINI_1   ;Determine operating mode.
081B 80EC       =1  2747            JMP     READ_LABEL
                =1  2748    ;
081D D3         =1  2749    LINI_1: SETB    C
081E 22         =1  2750            RET
                =1  2751    ;
                    2752    ;=======
                    2753    ;NL_NXT:
                    2754    ;       Output a <CR><LF> and continue with NXT routine.
LILBASIC        LilBasic (c)2002                                                                              PAGE 48

                    2755    ;
                    2756    ;
                    2757    ;NXT:
                    2758    ;       A colon or carriage return has been previously READ_CHARed.
                    2759    ;       If CHAR holds a colon,
                    2760    ;       continue interpretation of source line in current mode
                    2761    ;       from IL program instruction "TOKEN".
                    2762    ;       Otherwise CHAR is a <CR>, and line has been completed.
                    2763    ;       Resume execution from IL instruction "STMT".
                =1  2764    $INCLUDE(AES\NXT.ASM)
081F            =1  2765    NL_NXT:
                =1  2766    ;       Output a <CR><LF> and continue with NXT routine.
                =1  2767    ;
081F 120128     =1  2768            CALL    NLINE
                =1  2769    ;
0822            =1  2770    NXT:
                =1  2771    ;       A colon or carriage return has been previously READ_CHARed.
                =1  2772    ;       If CHAR holds a colon,
                =1  2773    ;       continue interpretation of source line in current mode
                =1  2774    ;       from IL program instruction "TOKEN".
                =1  2775    ;       Otherwise CHAR is a <CR>, and line has been completed.
                =1  2776    ;       Resume execution from IL instruction "STMT".
                =1  2777    ;
0822 BC3A06     =1  2778            CJNE    CHAR,#':',NXT_1 ;Skip ahead unless colon detected.
0825 12060F     =1  2779            CALL    D_BLNK
0828 020ABC     =1  2780            JMP     TOKEN           ;Continue with interpretation.
                =1  2781    ;
082B 020AB8     =1  2782    NXT_1:  JMP     STMT
                =1  2783    ;
                    2784    ;=======
                    2785    ;GETLN:
                    2786    ;       Input a line from console input device and put in line buffer
                    2787    ;       in internal RAM.
                =1  2788    $INCLUDE(AES\GETLN.ASM)
082E            =1  2789    GETLN:
                =1  2790    ;       Input a line from console input device and put in line buffer
                =1  2791    ;       in internal RAM.
                =1  2792    ;
082E E51D       =1  2793            MOV     A,AESP
0830 2404       =1  2794            ADD     A,#4
0832 F508       =1  2795            MOV     TMP0,A
0834            =1  2796    GETL_0:
0834 A808       =1  2797            MOV     R0,TMP0         ;Point to beginning of line buffer.
0836 12018B     =1  2798            CALL    STROUT
0839 2D2DBE     =1  2799            DB      '--',('>' OR 80H)  ;Display Prompt. -->
083C            =1  2800    GETL_1:
083C 120119     =1  2801            CALL    C_IN            ;Get next character from console.
083F 60FB       =1  2802            JZ      GETL_1          ;Skip over nul Chars                            Process Nul 
                                                                               Char
0841 B41217     =1  2803            CJNE    A,#CTRL_R,GETL_5   ;Re-type line on <CNTRL-R>.                  Process CTYR
                                                                               L-R
0844 12018B     =1  2804            CALL    STROUT
0847 8D         =1  2805            DB      (CR OR 80H)     ;Newline.
0848 8815       =1  2806            MOV     CURS_L,R0       ;Save old value of cursor.
084A A808       =1  2807            MOV     R0,TMP0         ;Start at beginning of line buffer.
084C E8         =1  2808    GETL_6: MOV     A,R0            ;Check if re-write done.
084D 6515       =1  2809            XRL     A,CURS_L
084F 60EB       =1  2810            JZ      GETL_1          ;Continue with line input.
LILBASIC        LilBasic (c)2002                                                                              PAGE 49

                =1  2811 +1         PAGE    #0H             ;ZERO PAGE for AES
0851 75A000     =1  2812 +1         MOV     P2,#0H
0854 E2         =1  2814            MOVX     A,@R0           ;Load character to re-write.
0855 12012A     =1  2815            CALL    C_OUT
0858 08         =1  2816            INC     R0
0859 80F1       =1  2817            SJMP    GETL_6          ;Continue until done.
                =1  2818    ;
085B B47F07     =1  2819    GETL_5: CJNE    A,#DEL,GETL_7   ;Cancel whole line on <DEL>.
085E 12018B     =1  2820            CALL    STROUT
0861 238D       =1  2821            DB      '#',(CR OR 80H) ;Advance to next line.
0863 80CF       =1  2822            SJMP    GETL_0
                =1  2823    ;
0865 B40813     =1  2824    GETL_7: CJNE    A,#BS,GETL_3                                                    ;Process Bac
                                                                               k space
0868 E8         =1  2825            MOV     A,R0
0869 B50806     =1  2826            CJNE    A,TMP0,GETL_4   ;Delete previous character (if any).
086C 12018B     =1  2827            CALL    STROUT
086F 87         =1  2828            DB      (BEL OR 80H)    ;Echo <BEL>.
0870 80CA       =1  2829            SJMP    GETL_1          ;Ignore rubouts at beginning of line
                =1  2830    ;
0872 12018B     =1  2831    GETL_4: CALL    STROUT
0875 082088     =1  2832            DB      BS,' ',(BS OR 80H)     ;BKSP,SPC,BKSP
0878 18         =1  2833            DEC     R0              ;Wipeout last char.
0879 80C1       =1  2834            SJMP    GETL_1
                =1  2835    ;
087B B8FE06     =1  2836    GETL_3: CJNE    R0,#0FEH,GETL_2 ;Test if buffer full.
087E 12018B     =1  2837            CALL    STROUT          ;Echo <BEL>.
0881 87         =1  2838            DB      (BEL OR 80H)
0882 80B8       =1  2839            SJMP    GETL_1          ;If so, override character received.
                =1  2840    ;
                =1  2841 +1 GETL_2: PAGE    #0H             ;ZERO PAGE for AES
0884 75A000     =1  2842 +1         MOV     P2,#0H
0887 F2         =1  2844            MOVX     @R0,A           ;Store into line buffer.
0888 12012A     =1  2845            CALL    C_OUT           ;Echo character.
088B 08         =1  2846            INC     R0              ;Bump pointer.
088C B40DAD     =1  2847            CJNE    A,#CR,GETL_1    ;Repeat for next character.
088F A808       =1  2848            MOV     PNTR_L,TMP0     ;Point cursor to beginning of line buffer.
0891 C259       =1  2849            CLR     CHAR_FLG
0893 22         =1  2850            RET
                =1  2851    ;
                    2852    ;===============
                    2853    ;PRN:
                    2854    ;       Pop top of arithmetic expression stack (AES),
                    2855    ;       convert to decimal number,
                    2856    ;       and print to console output device, suppressing leading zeroes.
                    2857    ;
                =1  2858    $INCLUDE(AES\PRN_.ASM)
0894            =1  2859    PRN:
                =1  2860    ;       Pop top of arithmetic expression stack (AES),
                =1  2861    ;       convert to decimal number,
                =1  2862    ;       and print to console output device, suppressing leading zeroes.
                =1  2863    ;
0894 C25A       =1  2864            CLR     SGN_FLG
0896 120437     =1  2865            CALL    IABS
0899 1201C1     =1  2866            CALL    POP_TOS
089C D258       =1  2867    PRNTOS: SETB    ZERSUP          ;Set zero suppression flag.
089E E4         =1  2868            CLR     A
089F F508       =1  2869            MOV     TMP0,A
LILBASIC        LilBasic (c)2002                                                                              PAGE 50

08A1 7D10       =1  2870            MOV     LP_CNT,#16      ;Conversion precision.
                =1  2871    
08A3 20541E     =1  2872            JB      HEXMOD,PRNHEX   ;If in hexmode, then jump to ...
                =1  2873    
08A6 305A04     =1  2874            JNB     SGN_FLG,PRN_1   ;Skip ahead if positive number.
08A9 12018B     =1  2875            CALL    STROUT          ;Output minus sign if negative.
08AC AD         =1  2876            DB      ('-' OR 80H)
                =1  2877    
08AD CE         =1  2878    PRN_1:  XCH     A,TOS_L
08AE 33         =1  2879            RLC     A
08AF CE         =1  2880            XCH     A,TOS_L
08B0 CF         =1  2881            XCH     A,TOS_H
08B1 33         =1  2882            RLC     A
08B2 CF         =1  2883            XCH     A,TOS_H
08B3 C508       =1  2884            XCH     A,TMP0
08B5 35E0       =1  2885            ADDC    A,ACC
08B7 D4         =1  2886            DA      A
08B8 C508       =1  2887            XCH     A,TMP0
08BA 35E0       =1  2888            ADDC    A,ACC
08BC D4         =1  2889            DA      A
08BD DDEE       =1  2890            DJNZ    LP_CNT,PRN_1
08BF FF         =1  2891            MOV     TOS_H,A
08C0 EE         =1  2892            MOV     A,TOS_L
08C1 33         =1  2893            RLC     A
08C2 AE08       =1  2894            MOV     TOS_L,TMP0
                =1  2895    
08C4 12015C     =1  2896    PRNHEX: CALL    NIBOUT
08C7 EF         =1  2897            MOV     A,TOS_H
08C8 C4         =1  2898            SWAP    A
08C9 12015C     =1  2899            CALL    NIBOUT          ;Print second digit.
08CC EF         =1  2900            MOV     A,TOS_H
08CD 12015C     =1  2901            CALL    NIBOUT          ;Print third digit.
08D0 305402     =1  2902            JNB     HEXMOD,PRNH_1
08D3 C258       =1  2903            CLR     ZERSUP          ;Print out last two chars. (at least) in hex.
                =1  2904    
08D5 EE         =1  2905    PRNH_1: MOV     A,TOS_L         ;Read into Acc.
08D6 C4         =1  2906            SWAP    A               ;Interchange nibbles.
08D7 12015C     =1  2907            CALL    NIBOUT          ;Print fourth digit.
08DA C258       =1  2908            CLR     ZERSUP
08DC EE         =1  2909            MOV     A,TOS_L         ;Reload byte.
08DD 12015C     =1  2910            CALL    NIBOUT          ;Print last digit.
08E0 305404     =1  2911            JNB     HEXMOD,PRNRET
08E3 12018B     =1  2912            CALL    STROUT          ;Print trailing "H".
08E6 C8         =1  2913            DB      ('H' OR 80H)
08E7 22         =1  2914    PRNRET: RET
                =1  2915    ;
                    2916    ;===============
                    2917    ;LSTLIN:
                    2918    ;       Check Label of Program line pointed to by Cursor.
                    2919    ;       If legal, print line number, source line, and <CR><LF> to console,
                    2920    ;       adjust Cursor to start of next line,
                    2921    ;       and return with carry set.
                    2922    ;       Else return with carry cleared.
                    2923    ;
                =1  2924    $INCLUDE(AES\LSTLIN.ASM)
08E8            =1  2925    LSTLIN:
                =1  2926    ;       Check Label of Program line pointed to by Cursor.
                =1  2927    ;       If legal, print line number, source line, and <CR><LF> to console,
LILBASIC        LilBasic (c)2002                                                                              PAGE 51

                =1  2928    ;       adjust Cursor to start of next line,
                =1  2929    ;       and return with carry set.
                =1  2930    ;       Else return with carry cleared.
                =1  2931    ;
08E8 1109       =1  2932            CALL    READ_LABEL
08EA 4015       =1  2933            JC      LSTL_1
08EC AF19       =1  2934            MOV     TOS_H,LABL_H
08EE AE18       =1  2935            MOV     TOS_L,LABL_L
08F0 C25A       =1  2936            CLR     SGN_FLG
08F2 119C       =1  2937            CALL    PRNTOS
08F4 12018B     =1  2938            CALL    STROUT          ;Insert space before user's source line.
08F7 A0         =1  2939            DB      (' ' OR 80H)
08F8 1205E5     =1  2940    LSTL_2: CALL    READ_CHAR
08FB 12012A     =1  2941            CALL    C_OUT
08FE B40DF7     =1  2942            CJNE    A,#CR,LSTL_2
0901 22         =1  2943    LSTL_1: RET
                =1  2944    ;
                    2945    ;===============
                    2946    ;LST
                    2947    ;       List the contents of the program memory area.
                    2948    ;
                =1  2949    $INCLUDE(AES\LST.ASM)
                =1  2950    ;LST
                =1  2951    ;       List the contents of the program memory area.
                =1  2952    ;
                =1  2953    ;
0902 D253       =1  2954    LST:    SETB    RUNMOD
0904 12058F     =1  2955            CALL    REWIND          ;Point to first char of external buffer.
0907 120147     =1  2956    LST_1:  CALL    CNTRL
090A 4004       =1  2957            JC      LSTRET
090C 11E8       =1  2958            CALL    LSTLIN          ;Print out current line if present.
090E 50F7       =1  2959            JNC     LST_1           ;Repeat if successful.
0910 C253       =1  2960    LSTRET: CLR     RUNMOD
0912 22         =1  2961            RET
                =1  2962    ;
                    2963    ;===============
                    2964    ;INNUM:
                    2965    ;       Read a numeric character string from the console input device.
                    2966    ;       Convert to binary value and push onto arithmetic expression stack.
                    2967    ;       Report error if illegal characters read.
                =1  2968    $INCLUDE(AES\INUM.ASM)
0913            =1  2969    INNUM:
                =1  2970    ;       Read a numeric character string from the console input device.
                =1  2971    ;       Convert to binary value and push onto arithmetic expression stack.
                =1  2972    ;       Report error if illegal characters read.
                =1  2973    ;
0913 C25A       =1  2974            CLR     SGN_FLG         ;Assume number will be positive.
0915 12018B     =1  2975            CALL    STROUT
0918 3AA0       =1  2976            DB      ':',(' ' OR 80H);Print input prompt.
091A 120119     =1  2977    INUM_0: CALL    C_IN
091D 12012A     =1  2978            CALL    C_OUT           ;Echo input
0920 B42002     =1  2979            CJNE    A,#' ',INUM_3
0923 80F5       =1  2980            SJMP    INUM_0
                =1  2981    ;
0925 B42B02     =1  2982    INUM_3: CJNE    A,#'+',INUM_4
0928 80F0       =1  2983            SJMP    INUM_0
                =1  2984    ;
092A B42D04     =1  2985    INUM_4: CJNE    A,#'-',INUM_5
LILBASIC        LilBasic (c)2002                                                                              PAGE 52

092D B25A       =1  2986            CPL     SGN_FLG
092F 80E9       =1  2987            SJMP    INUM_0
                =1  2988    ;
0931 120390     =1  2989    INUM_5: CALL    CREATE          ;Create value on stack if legal decimal digit.
0934 5009       =1  2990            JNC     INUM_2          ;Abort if first character received not legal.
0936 120119     =1  2991    INUM_1: CALL    C_IN            ;Get additional characters.
0939 12012A     =1  2992            CALL    C_OUT           ;Echo input.
093C B47F07     =1  2993            CJNE    A,#7FH,INUM_6   ;Start over if delete char detected.
093F 12018B     =1  2994    INUM_2: CALL    STROUT
0942 238D       =1  2995            DB      '#',(CR OR 80H)
0944 80CD       =1  2996            SJMP    INNUM
                =1  2997    ;
0946 12039D     =1  2998    INUM_6: CALL    APPEND          ;Incorporate into stack entry.
0949 40EB       =1  2999            JC      INUM_1          ;Loop while legal characters arrive.
094B 1201DF     =1  3000            CALL    PUSH_TOS
094E 020444     =1  3001            JMP     NEG_IF_NEG
                =1  3002    ;
                    3003    ;===============
                    3004    ;INIT
                    3005    ;       Perform global initialization:
                    3006    ;       Clear program memory, empty all I/O buffers, reset all stack
                    3007    ;       pointers, etc.
                =1  3008    $INCLUDE(AES\INIT.ASM)
                =1  3009    ;INIT
                =1  3010    ;       Perform global initialization:
                =1  3011    ;       Clear program memory, empty all I/O buffers, reset all stack
                =1  3012    ;       pointers, etc.
                =1  3013    ;
                =1  3014    ;
0951 120954     =1  3015    INIT:   CALL    RAM_INIT
0954            =1  3016    RAM_INIT:
0954 E4         =1  3017            CLR     A               ;Quick & easy version of 00H
0955 F52A       =1  3018            MOV     MODE,A          ;Interactive mode, decimal radix.
0957 F52B       =1  3019            MOV     FLAGS,A         ;Interroutine flags.
                =1  3020    
                =1  3021    
                =1  3022                                    ;Wipe all System memory
0959 900000     =1  3023            MOV     DPTR,#0000H     ;Set DPTR to 0000H
095C            =1  3024    INIT_LOOP_1:
095C F0         =1  3025            MOVX    @DPTR,A         ;Clear a byte
095D A3         =1  3026            INC     DPTR            ;Bump to next byte
095E A883       =1  3027            MOV     R0,DPH          ;Check if Highbyte at RAMLIMit yet?
0960 B87FF9     =1  3028            CJNE    R0,#HIGH(RAMLIM),INIT_LOOP_1
0963 A882       =1  3029            MOV     R0,DPL          ;Check if Lowbyte at RAMLIMit yet?
0965 B8FFF4     =1  3030            CJNE    R0,#LOW(RAMLIM),INIT_LOOP_1
                =1  3031    
0968 902000     =1  3032            MOV     DPTR,#EXTRAM    ;Set pointer to beginning of program mem
096B 7480       =1  3033            MOV     A,#080H
096D F0         =1  3034            MOVX    @DPTR,A         ;Store 80H at beginning of program
096E 22         =1  3035            RET
                    3036    
                    3037    ;=====================================================================================
                    3038    ;                      BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
                    3039    ;=====================================================================================;
                    3040    
                    3041    ;XINIT
                    3042    ;       Perform initialization needed before starting sequential execution.
                    3043    ;       Empty stacks, set BASIC line number to 1, etc.
LILBASIC        LilBasic (c)2002                                                                              PAGE 53

                    3044    
                =1  3045    $INCLUDE(AES\XINIT.ASM)
                =1  3046    ;XINIT
                =1  3047    ;       Perform initialization needed before starting sequential execution.
                =1  3048    ;       Empty stacks, set BASIC line number to 1, etc.
                =1  3049    ;
                =1  3050    ;
096F 751D00     =1  3051    XINIT:  MOV     AESP,#00H     ;Initialize AE Stack.
0972 12058F     =1  3052            CALL    REWIND
0975 D253       =1  3053            SETB    RUNMOD
0977 22         =1  3054            RET                     ;Begin execution.
                =1  3055    ;
                    3056    ;===============
                    3057    ;FNDLBL:
                    3058    ;       Search program buffer for line with label passed on AES (Pop AES).
                    3059    ;       If found, return with CURSOR pointing to start of line (before label)
                    3060    ;       and carry cleared.
                    3061    ;       If not found return with carry set and pointer at start of first
                    3062    ;       line with a greater label value (possible EOF).
                =1  3063    $INCLUDE(AES\FNDLBL.ASM)
0978            =1  3064    FNDLBL:
                =1  3065    ;       Search program buffer for line with label passed on AES (Pop AES).
                =1  3066    ;       If found, return with CURSOR pointing to start of line (before label)
                =1  3067    ;       and carry cleared.
                =1  3068    ;       If not found return with carry set and pointer at start of first
                =1  3069    ;       line with a greater label value (possible EOF).
                =1  3070    ;
0978 D253       =1  3071            SETB    RUNMOD          ;Kludge to make GET_C fetch from prog. buffer.
097A 12058F     =1  3072            CALL    REWIND
097D 1201C1     =1  3073            CALL    POP_TOS
0980 1205AD     =1  3074    FND_1:  CALL    SAVE_PNTR       ;Store position of beginning of line.
0983 1109       =1  3075            CALL    READ_LABEL
0985 4013       =1  3076            JC      FNDDON
0987 EE         =1  3077            MOV     A,TOS_L
0988 9518       =1  3078            SUBB    A,LABL_L
098A F518       =1  3079            MOV     LABL_L,A        ;Save non-zero bits.
098C EF         =1  3080            MOV     A,TOS_H
098D 9519       =1  3081            SUBB    A,LABL_H
098F 4518       =1  3082            ORL     A,LABL_L        ;Test for non-zero bits.
0991 6007       =1  3083            JZ      FNDDON
0993 4005       =1  3084            JC      FNDDON          ;Carry=1 if a greater label value found.
0995 12061D     =1  3085            CALL    SKPTXT          ;Skip over remaining text portion of line.
0998 80E6       =1  3086            SJMP    FND_1
                =1  3087    ;
099A 0205B4     =1  3088    FNDDON: JMP     LOAD_PNTR
                =1  3089    ;
                    3090    ;=======
                    3091    ;KILL_L:
                    3092    ;       Kill (delete) line from code buffer indicated by pointer.
                    3093    ;       When called, CURSOR and POINTER hold the address of first LABEL byte of
                    3094    ;       line to be deleted.
                =1  3095    $INCLUDE(AES\KILL_L.ASM)
099D            =1  3096    KILL_L:
                =1  3097    ;       Kill (delete) line from code buffer indicated by pointer.
                =1  3098    ;       When called, CURSOR and POINTER hold the address of first LABEL byte of
                =1  3099    ;       line to be deleted.
                =1  3100    ;
099D A915       =1  3101            MOV     DEST_L,CURS_L
LILBASIC        LilBasic (c)2002                                                                              PAGE 54

099F AB16       =1  3102            MOV     DEST_H,CURS_H
09A1 120619     =1  3103            CALL    SKPLIN          ;Pass pointer over full text line.
                =1  3104    ;
                =1  3105    ;       Pointer now indicates first label byte of following line.
                =1  3106    ;       Cursor and DEST still indicate first label byte of obsolete line.
                =1  3107    ;
09A4 1205E5     =1  3108    KILL_2: CALL    READ_CHAR       ;Copy down first label byte.
09A7 120607     =1  3109            CALL    WRITE_CHAR      ;Transfer first byte of label number.
09AA 20E711     =1  3110            JB      ACC.7,KILL_9    ;Quit when End of Code sentinel reached.
09AD 1205E5     =1  3111            CALL    READ_CHAR       ;Copy down second label byte.
09B0 120607     =1  3112            CALL    WRITE_CHAR      ;Store second byte of label number.
09B3 1205E5     =1  3113    KILL_3: CALL    READ_CHAR       ;Transfer text character.
09B6 120607     =1  3114            CALL    WRITE_CHAR
09B9 B40DF7     =1  3115            CJNE    A,#CR,KILL_3    ;Loop until full line moved.
09BC 80E6       =1  3116            SJMP    KILL_2          ;Continue until all code moved forward.
                =1  3117    ;
09BE 22         =1  3118    KILL_9: RET                     ;Full line now deleted.
                =1  3119    ;
                    3120    ;=======
                    3121    ;OPEN_L:
                    3122    ;       Open space for new line in code buffer starting at Cursor.
                =1  3123    $INCLUDE(AES\OPEN_L.ASM)
09BF            =1  3124    OPEN_L:
                =1  3125    ;       Open space for new line in code buffer starting at Cursor.
                =1  3126    ;
09BF 1205B4     =1  3127            CALL    LOAD_PNTR       ;Load address of point for insertion.
09C2 C259       =1  3128            CLR     CHAR_FLG
09C4 1205E5     =1  3129    OPEN_3: CALL    READ_CHAR       ;Test first label byte of following line.
09C7 20E70B     =1  3130            JB      ACC.7,OPEN_4
09CA 1205E5     =1  3131            CALL    READ_CHAR       ;Pass over next LABEL byte.
09CD 1205E5     =1  3132    OPEN_5: CALL    READ_CHAR
09D0 B40DFA     =1  3133            CJNE    A,#CR,OPEN_5
09D3 80EF       =1  3134            SJMP    OPEN_3
                =1  3135    ;
                =1  3136    ;       Pointer now indicates end-of-buffer sentinel.
                =1  3137    ;
09D5 E512       =1  3138    OPEN_4: MOV     A,STRLEN        ;Number of bytes needed for BASIC text.
09D7 2403       =1  3139            ADD     A,#3            ;Space needed for for label and <CR>.
09D9 28         =1  3140            ADD     A,R0            ;Low-order byte of old pointer.
09DA F9         =1  3141            MOV     DEST_L,A
09DB E4         =1  3142            CLR     A
09DC 3A         =1  3143            ADDC    A,PNTR_H
09DD FB         =1  3144            MOV     DEST_H,A
09DE B47F03     =1  3145            CJNE    A,#HIGH(RAMLIM),OPEN_1
09E1 021017     =1  3146            JMP     AES_ER
                =1  3147    ;
                =1  3148    ;       Transfer characters from source back to destination
                =1  3149    ;       until pointer at original CURSOR value.
                =1  3150    ;
09E4 1205C3     =1  3151    OPEN_1: CALL    GET_BUF         ;Move back next character.
09E7 1205F3     =1  3152            CALL    PUT_BUF
09EA E8         =1  3153            MOV     A,PNTR_L
09EB B51505     =1  3154            CJNE    A,CURS_L,OPEN_2
09EE EA         =1  3155            MOV     A,PNTR_H
09EF B51601     =1  3156            CJNE    A,CURS_H,OPEN_2
                =1  3157    ;
                =1  3158    ;       All bytes have been moved back.
                =1  3159    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 55

09F2 22         =1  3160            RET
                =1  3161    ;
09F3            =1  3162    OPEN_2:
                =1  3163    ;       Decrement src. and dest. pointers and repeat.
                =1  3164    ;
09F3 18         =1  3165            DEC     PNTR_L
09F4 B8FF01     =1  3166            CJNE    PNTR_L,#0FFH,OPEN_6
09F7 1A         =1  3167            DEC     PNTR_H
09F8 19         =1  3168    OPEN_6: DEC     DEST_L
09F9 B9FFE8     =1  3169            CJNE    DEST_L,#0FFH,OPEN_1
09FC 1B         =1  3170            DEC     DEST_H
09FD 80E5       =1  3171            SJMP    OPEN_1          ;Repeat for next character.
                =1  3172    ;
                    3173    ;=======
                    3174    ;INSR_L:
                    3175    ;       Insert program line label (still held in <TOS_H><TOS_L> from earlier
                    3176    ;       call to FNDLBL)
                    3177    ;       and character string in line buffer (pointed at by L_CURS)
                    3178    ;       into program buffer gap created by OPEN_L routine
                    3179    ;       (still pointed at by CURSOR).
                =1  3180    $INCLUDE(AES\INSER_L.ASM)
09FF            =1  3181    INSR_L:
                =1  3182    ;       Insert program line label (still held in <TOS_H><TOS_L> from earlier
                =1  3183    ;       call to FNDLBL)
                =1  3184    ;       and character string in line buffer (pointed at by L_CURS)
                =1  3185    ;       into program buffer gap created by OPEN_L routine
                =1  3186    ;       (still pointed at by CURSOR).
                =1  3187    ;
09FF A915       =1  3188            MOV     DEST_L,CURS_L
0A01 AB16       =1  3189            MOV     DEST_H,CURS_H
0A03 EF         =1  3190            MOV     A,TOS_H
0A04 120607     =1  3191            CALL    WRITE_CHAR
0A07 EE         =1  3192            MOV     A,TOS_L
0A08 120607     =1  3193            CALL    WRITE_CHAR
0A0B A813       =1  3194            MOV     PNTR_L,L_CURS
                =1  3195 +1         PAGE    #0H             ;ZERO PAGE for AES
0A0D 75A000     =1  3196 +1         MOV     P2,#0H
0A10 E2         =1  3198    INSL_1: MOVX     A,@PNTR_L
0A11 120607     =1  3199            CALL    WRITE_CHAR
0A14 08         =1  3200            INC     PNTR_L
0A15 B40DF8     =1  3201            CJNE    A,#CR,INSL_1
0A18 22         =1  3202            RET
                =1  3203    ;
                    3204    ;=======
                    3205    ;INSRT:
                    3206    ;       Pop line number from top of arithmetic expression stack.
                    3207    ;       Search BASIC source program for corresponding line number.
                    3208    ;       If found, delete old line.
                    3209    ;       Otherwise position cursor before next sequential line number.
                    3210    ;       If line buffer is not empty then insert line number, contents of
                    3211    ;       line buffer, and line terminator.
                =1  3212    $INCLUDE(AES\INSRT.ASM)
0A19            =1  3213    INSRT:
                =1  3214    ;       Pop line number from top of arithmetic expression stack.
                =1  3215    ;       Search BASIC source program for corresponding line number.
                =1  3216    ;       If found, delete old line.
                =1  3217    ;       Otherwise position cursor before next sequential line number.
                =1  3218    ;       If line buffer is not empty then insert line number, contents of
LILBASIC        LilBasic (c)2002                                                                              PAGE 56

                =1  3219    ;       line buffer, and line terminator.
                =1  3220    ;
0A19 18         =1  3221            DEC     PNTR_L          ;Since previous D_BLNK passed over first char.
0A1A 8813       =1  3222            MOV     L_CURS,PNTR_L
0A1C 3178       =1  3223            CALL    FNDLBL          ;Check to see if line # in Program
0A1E 4002       =1  3224            JC      INSR_1
0A20 319D       =1  3225            CALL    KILL_L          ;Delete line if label found in buffer.
0A22 A913       =1  3226    INSR_1: MOV     R1,L_CURS
0A24 19         =1  3227            DEC     R1
0A25 09         =1  3228    INSR_2: INC     R1
                =1  3229 +1         PAGE    #0H             ;ZERO PAGE for AES
0A26 75A000     =1  3230 +1         MOV     P2,#0H
0A29 E3         =1  3232            MOVX    A,@R1
0A2A B40DF8     =1  3233            CJNE    A,#CR,INSR_2
0A2D E9         =1  3234            MOV     A,R1
0A2E C3         =1  3235            CLR     C
0A2F 9513       =1  3236            SUBB    A,L_CURS
0A31 F512       =1  3237            MOV     STRLEN,A
0A33 6004       =1  3238            JZ      INSR_4
0A35 31BF       =1  3239            CALL    OPEN_L
0A37 31FF       =1  3240            CALL    INSR_L
0A39 C253       =1  3241    INSR_4: CLR     RUNMOD
0A3B 22         =1  3242            RET
                =1  3243    ;
                    3244    ;===============
0A3C                3245    COND:
0A3C 1201C1         3246            CALL    POP_TOS
0A3F EE             3247            MOV     A,TOS_L
0A40 13             3248            RRC     A
0A41 22             3249            RET
                    3250    ;
                    3251    ;=======
                    3252    ;XFER
                    3253    ;       Pop the value from the top of the arithmetic expression stack (AES).
                    3254    ;       Position cursor at beginning of the BASIC source program line
                    3255    ;       with that label and begin source interpretation.
                    3256    ;       (Report error if corresponding source line not found.)
                =1  3257    $INCLUDE(AES\XFER.ASM)
                =1  3258    ;XFER
                =1  3259    ;       Pop the value from the top of the arithmetic expression stack (AES).
                =1  3260    ;       Position cursor at beginning of the BASIC source program line
                =1  3261    ;       with that label and begin source interpretation.
                =1  3262    ;       (Report error if corresponding source line not found.)
                =1  3263    ;
                =1  3264    ;
0A42 3178       =1  3265    XFER:   CALL    FNDLBL
0A44 4003       =1  3266            JC      XFERNG
0A46 020AB8     =1  3267            JMP     STMT            ;Begin execution of source line.
                =1  3268    ;
0A49 020FF7     =1  3269    XFERNG: JMP     EXP_ER
                =1  3270    ;
                    3271    ;===============
                    3272    ;SAV:
                    3273    ;       Push BASIC line number of current source line onto AES.
                =1  3274    $INCLUDE(AES\SAV.ASM)
0A4C            =1  3275    SAV:
                =1  3276    ;       Push BASIC line number of current source line onto AES.
                =1  3277    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 57

0A4C AF19       =1  3278            MOV     TOS_H,LABL_H
0A4E AE18       =1  3279            MOV     TOS_L,LABL_L
0A50 0201DF     =1  3280            JMP     PUSH_TOS
                =1  3281    ;
                    3282    ;===============
                    3283    ;RSTR:
                    3284    ;       If AES is empty report a nesting error.
                    3285    ;       Otherwise, pop AES into current BASIC souce program line number.
                =1  3286    $INCLUDE(AES\RSTR.ASM)
0A53            =1  3287    RSTR:
                =1  3288    ;       If AES is empty report a nesting error.
                =1  3289    ;       Otherwise, pop AES into current BASIC souce program line number.
                =1  3290    ;
0A53 3178       =1  3291            CALL    FNDLBL
0A55 120619     =1  3292            CALL    SKPLIN          ;Pass over statement initiating transfer.
0A58 020AB8     =1  3293            JMP     STMT
                =1  3294    ;
                    3295    ;=======
                    3296    ;FIN
                    3297    ;       Return to line collection routine.
                    3298    ;
                =1  3299    $INCLUDE(AES\FIN.ASM)
                =1  3300    ;FIN
                =1  3301    ;       Return to line collection routine.
                =1  3302    ;
                =1  3303    ;
0A5B C253       =1  3304    FIN:    CLR     RUNMOD
0A5D 020A82     =1  3305            JMP     CONT            ;Return to line collection mode.
                =1  3306    ;
                    3307    ;======================================================================================
                    3308    ;               IL SEQUENCE CONTROL INSTRUCTIONS:
                    3309    ;======================================================================================;
                    3310    ;MLCALL
                    3311    ;       Call the ML subroutine starting at the address on top of AES.
                    3312    ;
                    3313    ;
                =1  3314    $INCLUDE(AES\MLCALL.ASM)
                =1  3315    ;MLCALL
                =1  3316    ;       Call the ML subroutine starting at the address on top of AES.
                =1  3317    ;
                =1  3318    ;
                =1  3319 +1 MLCALL: PAGE    #0H             ;ZERO PAGE for AES
0A60 75A000     =1  3320 +1         MOV     P2,#0H
0A63 A91D       =1  3322            MOV     R1,AESP
0A65 C5F0       =1  3323            XCH     A,B
0A67 E3         =1  3324            MOVX     A,@R1
0A68 C5F0       =1  3325            XCH     A,B
0A6A 19         =1  3326            DEC     R1
0A6B E3         =1  3327            MOVX     A,@R1
0A6C 19         =1  3328            DEC     R1
0A6D 891D       =1  3329            MOV     AESP,R1
0A6F C0E0       =1  3330            PUSH    ACC
0A71 C0F0       =1  3331            PUSH    B
0A73 43D018     =1  3332            ORL     PSW,#00011000B  ;Select RB3.
                =1  3333 +1         PAGE    #0FFH            ;Move to  User Page!
0A76 75A0FF     =1  3334 +1         MOV     P2,#0FFH
0A79 22         =1  3336            RET                     ;Branch to user routine.
                =1  3337    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 58

                    3338    
                    3339    
                    3340    ;===========================================================================================
                                                                               ===============
                    3341    ;       LIL'BASIC STATEMENT EXECUTION
                    3342    
0A7A                3343    START:
                    3344    
0A7A                3345    ERRENT:
0A7A C253           3346            CLR     RUNMOD
0A7C 75812B         3347            MOV     SP,#SP_BASE             ;Re-initialize hardware stack.
0A7F 751D00         3348            MOV     AESP,#00H               ;Initialize AES pointer.
0A82                3349    CONT:
0A82 205231         3350            JB      XAUTO, XEC              ;If in Auto or Xauto run mode,
0A85 10512E         3351            JBC     AUTO, XEC               ;Do not allow for command line input!
0A88 12018B         3352            CALL    STROUT
0A8B 0D576861       3353            DB      CR,'What next boss?   ',(CR OR 80H)
0A8F 74206E65   
0A93 78742062   
0A97 6F73733F   
0A9B 2020208D   
0A9F 751800         3354            MOV     LABL_L,#0H              ;
0AA2 751900         3355            MOV     LABL_H,#0H
0AA5                3356    CONT_1:
0AA5 112E           3357            CALL    GETLN                   ;Receive interactive command line.
0AA7 12060F         3358            CALL    D_BLNK
0AAA 1207B6         3359            CALL    TSTN
0AAD 500D           3360            JNC     TOKEN
0AAF 5119           3361            CALL    INSRT
0AB1 80F2           3362            JMP    CONT_1
                    3363    ;
                    3364    
                    3365    ;
0AB3 1207F0         3366    ARUN:   CALL    LNDONE                  ;Clear pointer to end of line
0AB6 316F           3367    XEC:    CALL    XINIT                   ;Initialize for sequential execution.
                    3368 +1 STMT:   LINIT_                          ;Initialize for line execution.
0AB8 1118           3369 +1         CALL   L_INIT
0ABA 40BE           3370 +1         JC      ERRENT
0ABC 120147         3372    TOKEN:  CALL    CNTRL
                    3373    
0ABF 12060F         3374            CALL    D_BLNK                  ;Remove leading blanks from BASIC source line, updat
                                                                               e cursor,
                    3375                                            ;load first non-blank character into CHAR, and leave
                                                                                pointer
                    3376                                            ;loaded with its address.
                    3377    
                    3378 +1         TSTV_   BASCMD                  ;Test if first non-blank string is a legal variable 
                                                                               symbol.
0AC2 120654         3379 +1         CALL    TSTV
0AC5 5014           3380 +1         JNC     BASCMD
                    3382                                            ;If not, Jump to process BASic CoMmanDs
                    3383    
                    3384                                            ;If so, move cursor over string and any trailing bla
                                                                               nks,
                    3385                                            ;compute variable index value, push onto arithmetic 
                                                                               expression
                    3386                                            ;stack, and continue with following IL instruction.
                                                                               
LILBASIC        LilBasic (c)2002                                                                              PAGE 59

                    3387                                            ;Otherwise branch to IL instruction at LBL with curs
                                                                               or unaffected.
                    3388    
                =1  3389    $INCLUDE(AES\CMDS\IMPLIED.ASM)              ;Execute Implied commands
                =1  3390    
0AC7            =1  3391     IMPLST:                               ;Implied LET Basic Command
                =1  3392    
0AC7 120623     =1  3393            call   tst                      ;Test for 'var=' command
0ACA BD         =1  3394            db      ('=' OR 80H)
0ACB 500E       =1  3395            jnc     IMPLEXT                  ;If no '=' in CMD line, then Exit
                =1  3396    
                =1  3397 +1         ICALL_  EXPR                    ;Push Expression into AES
0ACD 121064     =1  3398 +1         CALL    EXPR
                =1  3400    
                =1  3401    ;        call   tst
                =1  3402    ;        db      (',' OR 80H)           ;Removed implied command A=1,2,3,4
                =1  3403    ;        jnc     se3a                   ;                        (A=1, B=2, C=3, ...ETC)
                =1  3404    ;        CALL    SEQ_STORE
                =1  3405    ;        CALL    IINC
                =1  3406    ;        HOP_    SE3
                =1  3407    
0AD0 1207EA     =1  3408            CALL    DONE                    ;Clear pointer to next Command
0AD3 1202DA     =1  3409            CALL    STORE                   ;Store result of AES into Variable
0AD6 0122       =1  3410            JMP     NXT                     ;Process next command
                =1  3411    
0AD8 02102E     =1  3412    CMD_NG: JMP     SYN_ER                  ;Invalid Implied Command; Jump To Syntax Error
                =1  3413    
0ADB            =1  3414    IMPLEXT:
                    3415    ;-----
0ADB                3416    BASCMD:                                 ;Process Basic Token Commands.
                =1  3417    $INCLUDE(AES\CMDS\LET.ASM)
                =1  3418    
                =1  3419    
0ADB            =1  3420    STLET:                                  ;Parse explicit LET command.
0ADB 120623     =1  3421            call   tst                      ;Test if 'LET' Command
0ADE 4C45D4     =1  3422            db      'LE',('T' OR 80H)
0AE1 5013       =1  3423            jnc     ENDLET                  ;if not 'LET' command process next command
                =1  3424    
                =1  3425 +1         TSTV_   CMD_NG                  ;Test for 'var='
0AE3 120654     =1  3426 +1         CALL    TSTV
0AE6 50F0       =1  3427 +1         JNC     CMD_NG
0AE8 BD         =1  3429            db      ('=' OR 80H)
0AE9 50ED       =1  3430            jnc     cmd_ng                  ;If not exizts branch to jump to Syntax Error
                =1  3431 +1         ICALL_  EXPR                    ;Push expressions into AES
0AEB 121064     =1  3432 +1         CALL    EXPR
0AEE 1207EA     =1  3434            CALL    DONE                    ;Move IL pointer past rest of command
0AF1 1202DA     =1  3435            CALL    STORE                   ;Put Value into Variable
                =1  3436                                            ;       When STORE is called, AES contains
                =1  3437                                            ;       (TOS:)  2 byte VALUE to be stored,
                =1  3438                                            ;               2 byte INDEX of destination variable
                                                                               ,
                =1  3439                                            ;               1 byte TYPE code for variable space.
                                                                               
                =1  3440                                            ;                       (0=BASIC variable,
                =1  3441                                            ;                        1=DBYTE,
                =1  3442                                            ;                        2=RBIT,
                =1  3443                                            ;                        3=XBYTE,
                =1  3444                                            ;                        4=CBYTE.)
LILBASIC        LilBasic (c)2002                                                                              PAGE 60

                =1  3445                                            ;       Store (VAR_1) into appropriate variable memo
                                                                               ry at location of (INDEX).
                =1  3446    
0AF4 0122       =1  3447            JMP     NXT                     ;Process next Command
                =1  3448    
0AF6            =1  3449    ENDLET:
                =1  3450    $INCLUDE(AES\CMDS\GO.ASM)
0AF6            =1  3451    GO_ST:
0AF6 120623     =1  3452            CALL    TST                     ;See if 'GO' command
0AF9 47CF       =1  3453            DB      'G',('O' OR 80H)
0AFB 501F       =1  3454            JNC     GO_END                  ;If not Try next command
0AFD            =1  3455    GOSUB_ST:
0AFD 120623     =1  3456            call   tst                      ;Test For 'GO SUB' Command
0B00 5355C2     =1  3457            db      'SU',('B' OR 80H)
0B03 5005       =1  3458            jnc     GOTO_ST                 ;If Not 'GO SUB' Then try 'GO TO'
0B05 514C       =1  3459            CALL    SAV                     ;Push return addr onto AES stack
0B07 020B11     =1  3460            JMP     GO_COMMON
0B0A            =1  3461    GOTO_ST:
0B0A 120623     =1  3462            call   tst                      ;Test for 'GO TO' command
0B0D 54CF       =1  3463            db      'T',('O' OR 80H)
0B0F 5008       =1  3464            jnc     GO_ERR                  ;If Not Must be a syntax Error
                =1  3465    
0B11            =1  3466    GO_COMMON:
                =1  3467 +1         ICALL_  EXPR                    ;Load expression into AES
0B11 121064     =1  3468 +1         CALL    EXPR
0B14 1207F0     =1  3470            CALL    LNDONE                  ;Move Command Pointer to end of line
                =1  3471    
0B17 4142       =1  3472            JMP     XFER                    ;Pop the value from the top of the arithmetic expres
                                                                               sion stack (AES).
                =1  3473                                            ;Position cursor at beginning of the BASIC source pr
                                                                               ogram line
                =1  3474                                            ;with that label and begin source interpretation.
                =1  3475                                            ;(Report error if corresponding source line not foun
                                                                               d.)
0B19            =1  3476    GO_ERR:
0B19 02102E     =1  3477            JMP     SYN_ER
                =1  3478    
                =1  3479    
                =1  3480    
0B1C            =1  3481    GO_END:
                =1  3482    
                =1  3483    
                =1  3484    ;
                =1  3485    $INCLUDE(AES\CMDS\PRINT.ASM)
0B1C            =1  3486    PRINT_START:
0B1C 120623     =1  3487            call   tst                      ;Test for 'PRINT' TOKEN
0B1F 5052494E   =1  3488            db      'PRIN',('T' OR 80H)
0B23 D4         
0B24 4008       =1  3489            JC      PRINT_LOOP              ;if so, then goto print command
                =1  3490    
0B26 120623     =1  3491            call   tst                      ;Test for '?' TOKEN (PRINT)
0B29 BF         =1  3492            db      ('?' OR 80H)
0B2A 4002       =1  3493            JC      PRINT_LOOP              ;if so, then goto print command
                =1  3494 +1         HOP_    PRINT_EXIT               ;If not, try next Command.
0B2C 8030       =1  3495 +1         SJMP    PRINT_EXIT
                =1  3497    
0B2E            =1  3498    PRINT_LOOP:                              ;Process PRINT Command
                =1  3499    
LILBASIC        LilBasic (c)2002                                                                              PAGE 61

                =1  3500 +1         IFDONE_  PRINT_END              ;If empty print statment, EXIT
0B2E 1207FB     =1  3501 +1         CALL    IFDONE
0B31 5027       =1  3502 +1         JNC     PRINT_END
                =1  3504    
0B33 120623     =1  3505            call   tst                      ;if PRINT starts with a ';' Skip over it
0B36 BB         =1  3506            db      (';' OR 80H)
0B37 401A       =1  3507            jc     PRINT_CHECK_SEMI
                =1  3508    
0B39 120623     =1  3509            call   tst
0B3C AC         =1  3510            db      (',' OR 80H)            ;If PRINT starts with a ','
0B3D 4011       =1  3511            jc     PRINT_COMMA              ;Space out tab fields
                =1  3512    
                =1  3513 +1         IFDONE_ PRINT_EXIT              ;If end of PRINT cmd, goto PRINT EXIT
0B3F 1207FB     =1  3514 +1         CALL    IFDONE
0B42 501A       =1  3515 +1         JNC     PRINT_EXIT
                =1  3517 +1         TSTS_   PRINT_LOOP              ;Output LITERAL string ("") if Exists and continue P
                                                                               RINT_LOOP
0B44 1207CB     =1  3518 +1         CALL    TSTS
0B47 40E5       =1  3519 +1         JC      PRINT_LOOP
                =1  3521                                            ;Else
                =1  3522 +1         ICALL_  EXPR                    ;Push Expression onto AES stack
0B49 121064     =1  3523 +1         CALL    EXPR
0B4C 1194       =1  3525            CALL    PRN                     ;Print It
                =1  3526 +1         HOP_    PRINT_LOOP              ;Continue Print Loop
0B4E 80DE       =1  3527 +1         SJMP    PRINT_LOOP
                =1  3529    ;-------------------------
0B50            =1  3530    PRINT_COMMA:
0B50 120155     =1  3531    CALL    SPC                             ;output sapces, Continue with Print Command
                =1  3532                                            ;Check to see if last command in print Loop (same as
                                                                                ';')
0B53            =1  3533    PRINT_CHECK_SEMI:
                =1  3534 +1         IFDONE_  PRINT_SEMI              ;If ';' or ',' is last character in print loop, the
                                                                               n exit w/o NewLine
0B53 1207FB     =1  3535 +1         CALL    IFDONE
0B56 5004       =1  3536 +1         JNC     PRINT_SEMI
                =1  3538 +1         HOP_    PRINT_LOOP              ;Else Continue Loop
0B58 80D4       =1  3539 +1         SJMP    PRINT_LOOP
                =1  3541    ;-------------------------
0B5A            =1  3542    PRINT_END:
0B5A 011F       =1  3543           JMP      NL_NXT                   ;Send NewLine and exit.
                =1  3544    
0B5C            =1  3545    PRINT_SEMI:
0B5C 0122       =1  3546           JMP      NXT                      ;Exit Without NewLine
                =1  3547    
0B5E            =1  3548    PRINT_EXIT:                             ;Continue with checking next Command
                =1  3549    ;
                =1  3550    $INCLUDE(AES\CMDS\IFTHEN.ASM)
0B5E            =1  3551    IFST:
0B5E 120623     =1  3552    s8:     call   tst
0B61 49C6       =1  3553            db      'I',('F' OR 80H)        ;Check for 'IF' Command
0B63 5017       =1  3554            jnc     IFEXIT                  ;If not check next command
                =1  3555 +1         ICALL_  EXPR                    ;Push expressionon on AES stack
0B65 121064     =1  3556 +1         CALL    EXPR
0B68 120623     =1  3558            call   tst
0B6B 544845CE   =1  3559            db      'THE',('N' OR 80H)      ;Check for 'THEN' command
0B6F 5000       =1  3560            jnc     IF_TF                     ; NEEDS changed to jnc ERROR
                =1  3561    
0B71            =1  3562    IF_TF:
LILBASIC        LilBasic (c)2002                                                                              PAGE 62

                =1  3563 +1         COND_   IF_FALSE
0B71 513C       =1  3564 +1         CALL   COND
0B73 5002       =1  3565 +1         JNC    IF_FALSE
                =1  3567 +1         IJMP_   TOKEN                   ;If True Continue parsing command.
0B75 41BC       =1  3568 +1         JMP     TOKEN
                =1  3570    
0B77            =1  3571    IF_FALSE:
0B77 12061D     =1  3572            CALL    SKPTXT                  ;If False Skip rest of line
                =1  3573 +1         IJMP_   STMT
0B7A 41B8       =1  3574 +1         JMP     STMT
                =1  3576    
0B7C            =1  3577    IFEXIT:
                =1  3578    $INCLUDE(AES\CMDS\INPUT.ASM)
0B7C            =1  3579    INPUTST:
0B7C 120623     =1  3580            call   tst
0B7F 494E5055   =1  3581            db      'INPU',('T' OR 80H)     ;Check if Input Command
0B83 D4         
0B84 5028       =1  3582            jnc     INPEXIT                 ;If not exit
0B86            =1  3583    INPUT_LOOP:
                =1  3584 +1         TSTS_   INPUT_SEMI              ;If Followed by String Literal Print it,
0B86 1207CB     =1  3585 +1         CALL    TSTS
0B89 400A       =1  3586 +1         JC      INPUT_SEMI
                =1  3588                                            ;and Check if followed by semi or comma.
                =1  3589 +1         TSTV_   INPUT_ERR               ;If not followed by variable exit with error
0B8B 120654     =1  3590 +1         CALL    TSTV
0B8E 5016       =1  3591 +1         JNC     INPUT_ERR
0B90 3113       =1  3593            CALL    INNUM                   ;Get value from 232port
0B92 1202DA     =1  3594            CALL    STORE                   ;Put value into var
                =1  3595                                            ;Need to check here to verify we are done.
0B95            =1  3596    INPUT_SEMI:
0B95 120623     =1  3597            call   tst                      ;If next char is a ';'
0B98 BB         =1  3598            db      (';' OR 80H)
0B99 40EB       =1  3599            jc     INPUT_LOOP               ;Continue with input command
                =1  3600                                            ;Else Check if it is a comma
                =1  3601    
0B9B            =1  3602    INPUT_COMMA:
0B9B 120623     =1  3603            call   tst                      ;If next char is not a','
0B9E AC         =1  3604            db      (',' OR 80H)
0B9F 5008       =1  3605            jnc     INPUT_END               ;Then must be end of command, so exit
0BA1 120155     =1  3606            CALL    SPC                     ;Else Space out tabfield
                =1  3607 +1         HOP_    INPUT_LOOP              ;continue input command
0BA4 80E0       =1  3608 +1         SJMP    INPUT_LOOP
                =1  3610    ;
0BA6            =1  3611    INPUT_ERR:
                =1  3612 +1        IJMP_   SYN_NG                  ;Jump to Syntax Error
0BA6 021154     =1  3613 +1         JMP     SYN_NG
                =1  3615    ;
0BA9            =1  3616    INPUT_END:
0BA9 1207EA     =1  3617            CALL    DONE
0BAC 011F       =1  3618            JMP     NL_NXT
                =1  3619    ;
0BAE            =1  3620    INPEXIT:
                =1  3621    $INCLUDE(AES\CMDS\RETURN.ASM)
0BAE            =1  3622    RETURN_START:
0BAE 120623     =1  3623            call   tst                      ;If Not 'RETURN' command
0BB1 52455455   =1  3624            db      'RETUR',('N' OR 80H)
0BB5 52CE       
0BB7 5005       =1  3625            jnc     RETURN_END              ;Then try next command
LILBASIC        LilBasic (c)2002                                                                              PAGE 63

0BB9 1207F0     =1  3626            CALL    LNDONE                  ;Else through with this line.
0BBC 4153       =1  3627            JMP     RSTR                    ;Pop of of AES new LINE #
0BBE            =1  3628    RETURN_END:
                =1  3629    $INCLUDE(AES\CMDS\CALL.ASM)  ; call machine subroutine
0BBE            =1  3630    CALL_START:
0BBE 120623     =1  3631            call   tst
0BC1 43414CCC   =1  3632            db      'CAL',('L' OR 80H)      ;Check if 'CALL' command
0BC5 500D       =1  3633            jnc     CALL_END                ;If not try next command
                =1  3634 +1         ICALL_  EXPR                    ;Else push Expresson on AES
0BC7 121064     =1  3635 +1         CALL    EXPR
0BCA 1207F0     =1  3637            CALL    LNDONE                  ;move pointer to end of stmt
                =1  3638 +1         MLCALL_                         ;Gosub Machine Lang. Subrutine.
0BCD 5160       =1  3639 +1         CALL    MLCALL
0BCF 53D0E7     =1  3640 +1         ANL     PSW,#11100111B
0BD2 0122       =1  3642            JMP     NXT                     ;Execute next command
0BD4            =1  3643    CALL_END:
                =1  3644    $INCLUDE(AES\CMDS\END.ASM)   ; end program
0BD4            =1  3645    END_START:
0BD4 120623     =1  3646            call   tst                      ;Check to see if next token is 'END'
0BD7 454EC4     =1  3647            db      'EN',('D' OR 80H)
0BDA 5005       =1  3648            jnc     END_END                 ;If not try next command
0BDC 1207F0     =1  3649            CALL    LNDONE                  ;Clear pointer to end of line
0BDF 415B       =1  3650            JMP     FIN                     ;End Program
0BE1            =1  3651    END_END:
                =1  3652    $INCLUDE(AES\CMDS\LIST.ASM)   ; list program
0BE1            =1  3653    LISTSTART:
0BE1 120623     =1  3654            call   tst
0BE4 4C4953D4   =1  3655            db      'LIS',('T' OR 80H)              ;Check to see if 'LIST' Commans
0BE8 5012       =1  3656            jnc     LISTEND                         ;If not, then check next command
                =1  3657 +1         IFDONE_ FULLLIST                        ;If nothing after 'LIST' command then list w
                                                                               hole program
0BEA 1207FB     =1  3658 +1         CALL    IFDONE
0BED 5009       =1  3659 +1         JNC     FULLLIST
                =1  3661 +1         ICALL_  EXPR                            ;Else get line no.
0BEF 121064     =1  3662 +1         CALL    EXPR
0BF2 3178       =1  3664            CALL    FNDLBL                          ;Find line in code
0BF4 3107       =1  3665            CALL    LST_1                           ;Display it
                =1  3666 +1         IJMP_   CONT                            ;exit
0BF6 4182       =1  3667 +1         JMP     CONT
                =1  3669    ;
0BF8            =1  3670    FULLLIST:
0BF8 3102       =1  3671            CALL    LST                             ;Gosub list whole program
                =1  3672 +1         IJMP_   CONT                            ;exit
0BFA 4182       =1  3673 +1         JMP     CONT
0BFC            =1  3675    LISTEND:
                =1  3676    $INCLUDE(AES\CMDS\RUN.ASM)   ; run program
0BFC            =1  3677    RUNSTART:
0BFC 120623     =1  3678            call   tst                      ;Check to see if it is 'RUN'command
0BFF 5255CE     =1  3679            db      'RU',('N' OR 80H)
0C02 5002       =1  3680            jnc     RUNEND                  ;If not, check next command
0C04 41B3       =1  3681            JMP     ARUN                   ;Else clear pointer to end of line and run program
0C06            =1  3682    RUNEND:
                =1  3683    $INCLUDE(AES\CMDS\NEW.ASM)   ; clear out program
0C06            =1  3684    NEWSTART:
0C06 120623     =1  3685            call   tst                      ;Check to see if 'NEW' command
0C09 4E45D7     =1  3686            db      'NE',('W' OR 80H)
0C0C 500E       =1  3687            jnc     NEWEND                  ;If not, try next command
0C0E 1207EA     =1  3688            CALL    DONE                    ;Clear pointer to end of line
LILBASIC        LilBasic (c)2002                                                                              PAGE 64

0C11 758200     =1  3689            MOV     DPL,#LOW(EXTRAM)        ;Move DPTR to beginning of program
0C14 758320     =1  3690            MOV     DPH,#HIGH(EXTRAM)
0C17 74FF       =1  3691            MOV     A,#0FFH                 ;Token for end of basic program
0C19 F0         =1  3692            MOVX    @DPTR,A                 ;Put END token at start of program
                =1  3693    
                =1  3694 +1         IJMP_   START                   ;Start at beginning
0C1A 417A       =1  3695 +1         JMP     START
0C1C            =1  3697    NEWEND:
                =1  3698    $INCLUDE(AES\CMDS\BREAK.ASM)  ; simulate reset
0C1C            =1  3699    BREAK_START:
0C1C 120623     =1  3700            call   tst                      ;Check if 'BREAK' command
0C1F 42524541   =1  3701            db      'BREA',('K' OR 80H)
0C23 CB         
0C24 5006       =1  3702            jnc     BREAK_END               ;If not check next command
0C26 1207EA     =1  3703            CALL    DONE                    ;Clear pointer
0C29 020000     =1  3704            JMP     0000H                   ;Reset CPU
0C2C            =1  3705    BREAK_END:
                =1  3706    $INCLUDE(AES\CMDS\PROG.ASM)
0C2C            =1  3707    FILE_START:
                =1  3708    
0C2C 120623     =1  3709            call tst                        ;Check to see if 'FILE' command
0C2F 50524FC7   =1  3710            DB      'PRO',('G'or 80H)
0C33 5036       =1  3711            JNC     FILE_END                ;If not, try next command
                =1  3712    ;----
0C35            =1  3713    ROM_PROGRAM:                            ; ROM
0C35 120623     =1  3714            call tst                        ;Check to see if 'ROM' command
0C38 44454DCF   =1  3715            DB     'DEM',('O'or 80H)
0C3C 5009       =1  3716            JNC     TEST_PROGRAM
0C3E 1207EA     =1  3717            CALL    DONE
0C41 D251       =1  3718            SETB    AUTO
0C43 D252       =1  3719            SETB    XAUTO
0C45 0122       =1  3720            JMP     NXT
                =1  3721    
                =1  3722    ;----
0C47            =1  3723    TEST_PROGRAM:
0C47 120623     =1  3724            call tst                        ;Check to see if 'TEST' command
0C4A 415554CF   =1  3725            DB     'AUT',('O'or 80H)
0C4E 5009       =1  3726            JNC     RAM_PROGRAM
0C50 1207EA     =1  3727            CALL    DONE                    ;clear pointer.
0C53 D251       =1  3728            SETB    AUTO                  ;Set PROGRAM MODE
0C55 C252       =1  3729            CLR     XAUTO
0C57 0122       =1  3730            JMP     NXT                     ;Execute next line of code (if any)
                =1  3731    
                =1  3732    ;----
0C59            =1  3733    RAM_PROGRAM:
0C59 120623     =1  3734            call tst                        ;Check to see if 'RAM' command
0C5C 5241CD     =1  3735            DB     'RA',('M'or 80H)
0C5F 5007       =1  3736            JNC    FILE_ERROR
0C61 1207EA     =1  3737            CALL    DONE                    ;clear pointers
0C64 C251       =1  3738            CLR     AUTO                    ;Set Program Mode to RAM, no auto run
0C66 0122       =1  3739            JMP     NXT                     ;Execute any further code if present.
                =1  3740    
                =1  3741    ;----
0C68            =1  3742    FILE_ERROR:
0C68 020FF7     =1  3743             JMP     EXP_ER
                =1  3744    ;----
0C6B            =1  3745    FILE_END:
                =1  3746    $INCLUDE(AES\CMDS\HEXDECI.ASM) ; set oytput mode decimal or Hex
LILBASIC        LilBasic (c)2002                                                                              PAGE 65

0C6B            =1  3747    HEXDECIMAL:
0C6B 120623     =1  3748             call   tst                     ;Check if 'HEX' command
0C6E 4845D8     =1  3749            db      'HE',('X' OR 80H)
0C71 5007       =1  3750            jnc     DECIMAL                 ;If not, goto DECIMAL
0C73 1207EA     =1  3751            CALL    DONE                    ;Else ignore rest of line
0C76 D254       =1  3752            SETB    HEXMOD                  ;Set Output mode to HEX
0C78 0122       =1  3753            JMP     NXT                     ;continue with next line
                =1  3754    
0C7A            =1  3755    DECIMAL:
0C7A 120623     =1  3756            call   tst                      ;Check if 'DEC' command
0C7D 4445C3     =1  3757            db      'DE',('C' OR 80H)
0C80 5007       =1  3758            jnc     HEXDEC_END              ;If not, try next command
0C82 1207EA     =1  3759            CALL    DONE                    ;Else ignore rest of line
0C85 C254       =1  3760            CLR     HEXMOD                  ;Set Output to Decimal
0C87 0122       =1  3761            JMP     NXT                     ;Continue execution with next command
0C89            =1  3762    HEXDEC_END:
                =1  3763    $INCLUDE(AES\CMDS\REMARK.ASM); remark stmt
0C89            =1  3764    REMARK_START:
0C89 120623     =1  3765            call   tst                      ;Check to see if 'REM' command
0C8C 5245CD     =1  3766            db      'RE',('M' OR 80H)
0C8F 5010       =1  3767            jnc     REMARK_END              ;If not try short version
0C91 12061D     =1  3768            CALL    SKPTXT                  ;Skip over rest of line.
                =1  3769 +1         IJMP_   STMT                    ;Execute neext stmt
0C94 41B8       =1  3770 +1         JMP     STMT
0C96            =1  3772    APOSTRO:
0C96 120623     =1  3773            call   tst                      ;Check to see if (') command
0C99 A7         =1  3774            db      (''''OR 80H)            ;(')
0C9A 5005       =1  3775            jnc     REMARK_END              ;If not try Next command
0C9C 12061D     =1  3776            CALL    SKPTXT                  ;Skip over rest of line
                =1  3777 +1         IJMP_   STMT                    ;Execute next stmt
0C9F 41B8       =1  3778 +1         JMP     STMT
                =1  3780    
0CA1            =1  3781    REMARK_END:
                =1  3782    $INCLUDE(AES\CMDS\CLS.ASM)   ; send clear screen command
0CA1            =1  3783    CLS_START:
                =1  3784    
0CA1 120623     =1  3785            call tst                        ;Check to see if 'FILE' command
0CA4 434CD3     =1  3786            DB      'CL',('S'or 80H)
0CA7 500D       =1  3787            JNC     CLS_END                ;If not, try next command
0CA9 12018B     =1  3788            CALL    STROUT                 ;Send String Below
0CAC 1B5B324A   =1  3789            DB      ESC,'[2J',80H          ;Ansi Escape code for Clear Screan
0CB0 80         
0CB1 1207EA     =1  3790            CALL    DONE                   ;Get ready for next command
0CB4 0122       =1  3791            JMP     NXT                    ;Execute next command
0CB6            =1  3792    CLS_END:
                =1  3793    $INCLUDE(AES\CMDS\HELP.ASM)  ; display help file
0CB6            =1  3794    HELP_START:
                =1  3795    
                =1  3796    
0CB6            =1  3797    HELP_1:
0CB6 120623     =1  3798            CALL    TST                        ;Check to see if 'HELP' command
0CB9 48454CD0   =1  3799            DB      'HEL',('P'or 80H)
0CBD 5014       =1  3800            JNC     JMP2_HELP_END                ;If not help command, try next command
                =1  3801    
0CBF 120623     =1  3802            CALL    TST                     ;Check to see if 'Help CMDS' command
0CC2 434D44D3   =1  3803            DB      'CMD',('S'or 80H)
0CC6 500E       =1  3804            JNC     HELP_2                  ;If not, try next command
0CC8 9013FE     =1  3805            MOV     DPTR,#HELPTEXTCMD       ;Set pointer to Help text commands
LILBASIC        LilBasic (c)2002                                                                              PAGE 66

0CCB 12019D     =1  3806            CALL    STROUT2                 ;Output Help Text
0CCE 1207EA     =1  3807            CALL    DONE                    ;Get ready for next command
0CD1 0122       =1  3808            JMP     NXT                     ;Execute next command
                =1  3809    
0CD3            =1  3810    JMP2_HELP_END:                          ; Jump to end of help
0CD3 020D47     =1  3811            JMP HELP_END
                =1  3812    
                =1  3813    
0CD6            =1  3814    HELP_2:
0CD6 120623     =1  3815            call tst                        ;Check to see if 'HELP FUNC' command
0CD9 46554EC3   =1  3816            DB      'FUN',('C'or 80H)
0CDD 500B       =1  3817            JNC     HELP_3                  ;If not, try next command
0CDF 90190E     =1  3818            MOV     DPTR,#HELPTEXTFUNC      ;Set pointer to Help text functions
0CE2 12019D     =1  3819            CALL    STROUT2                 ;Output Help Text
0CE5 1207EA     =1  3820            CALL    DONE                    ;Get ready for next command
0CE8 0122       =1  3821            JMP     NXT                     ;Execute next command
                =1  3822    
0CEA            =1  3823    HELP_3:
0CEA 120623     =1  3824            call tst                        ;Check to see if 'HELP OPER' command
0CED 4F5045D2   =1  3825            DB      'OPE',('R'or 80H)
0CF1 500B       =1  3826            JNC     HELP_4                  ;If not, try next command
0CF3 9019CF     =1  3827            MOV     DPTR,#HELPTEXTOPER      ;Set pointer to Help text operators
0CF6 12019D     =1  3828            CALL    STROUT2                 ;Output Help Text
0CF9 1207EA     =1  3829            CALL    DONE                    ;Get ready for next command
0CFC 0122       =1  3830            JMP     NXT                     ;Execute next command
                =1  3831    
0CFE            =1  3832    HELP_4:
0CFE 120623     =1  3833            call tst                        ;Check to see if 'VARS' command
0D01 5641D2     =1  3834            DB      'VA',('R'or 80H)
0D04 5036       =1  3835            JNC     HELP_0                  ;If not, try next command
0D06 901CE1     =1  3836            MOV     DPTR,#HELPTEXTVARS      ;Set pointer to Help text operators
0D09 12019D     =1  3837            CALL    STROUT2                 ;Output Help Text
0D0C 1207EA     =1  3838            CALL    DONE                    ;Get ready for next command
0D0F 0122       =1  3839            JMP     NXT                     ;Execute next command
                =1  3840    
0D11            =1  3841    HELP_5:
0D11 120623     =1  3842            call tst                        ;Check to see if 'ALL' command
0D14 414CCC     =1  3843            DB      'AL',('L'or 80H)
0D17 5023       =1  3844            JNC     HELP_0                  ;If not, try next command
                =1  3845    
0D19 9012BC     =1  3846            MOV     DPTR,#HELPTEXT         ;Set pointer to Help text part 1
0D1C 12019D     =1  3847            CALL    STROUT2                 ;Output Help Text
                =1  3848    
0D1F 9013FE     =1  3849            MOV     DPTR,#HELPTEXTCMD       ;Set pointer to Help text commands
0D22 12019D     =1  3850            CALL    STROUT2                 ;Output Help Text
                =1  3851    
0D25 90190E     =1  3852            MOV     DPTR,#HELPTEXTFUNC      ;Set pointer to Help text functions
0D28 12019D     =1  3853            CALL    STROUT2                 ;Output Help Text
                =1  3854    
0D2B 9019CF     =1  3855            MOV     DPTR,#HELPTEXTOPER      ;Set pointer to Help text operators
0D2E 12019D     =1  3856            CALL    STROUT2                 ;Output Help Text
                =1  3857    
0D31 901CE1     =1  3858            MOV     DPTR,#HELPTEXTVARS      ;Set pointer to Help text operators
0D34 12019D     =1  3859            CALL    STROUT2                 ;Output Help Text
0D37 1207EA     =1  3860            CALL    DONE                    ;Get ready for next command
0D3A 0122       =1  3861            JMP     NXT                     ;Execute next command
                =1  3862    
                =1  3863    
LILBASIC        LilBasic (c)2002                                                                              PAGE 67

                =1  3864    
0D3C            =1  3865    HELP_0:                                 ; Not 1, 2, or 3. So send help on help
0D3C 9012BC     =1  3866            MOV     DPTR,#HELPTEXT         ;Set pointer to Help text part 1
0D3F 12019D     =1  3867            CALL    STROUT2                 ;Output Help Text
0D42 1207EA     =1  3868                    CALL    DONE                    ;Get ready for next command
0D45 0122       =1  3869            JMP     NXT                     ;Execute next command
                =1  3870    
                =1  3871    
                =1  3872    
0D47            =1  3873    HELP_END:
                =1  3874    $INCLUDE(AES\CMDS\VER.ASM)   ; display version
0D47            =1  3875    VER_ST:
0D47 120623     =1  3876            call tst                        ;Check to see if 'VER' command
0D4A 5645D2     =1  3877            DB      'VE',('R'or 80H)
0D4D 5067       =1  3878            JNC     VER_END                 ;If not, try next command
0D4F 120D57     =1  3879            CALL    VER_MSG                 ;Send Version
0D52 1207EA     =1  3880            CALL    DONE                    ;Get ready for next command
0D55 0122       =1  3881            JMP     NXT                     ;Execute next command
                =1  3882    
0D57            =1  3883    VER_MSG:
0D57 12018B     =1  3884            CALL    STROUT
0D5A 1B5B324A   =1  3885            DB      ESC,'[2J',80H    ;CLS
0D5E 80         
0D5F 12018B     =1  3886            CALL    STROUT
0D62 20204C69   =1  3887            DB      '  Lil''Basic ver ',('0'+VERS/10H),'.',('0'+(VERS AND 0FH)),(CR OR 80H)
0D66 6C274261   
0D6A 73696320   
0D6E 76657220   
0D72 332E328D   
0D76 12018B     =1  3888            CALL    STROUT
0D79 28632931   =1  3889            DB      '(c)13/JAN/2002    -NQR',CR,(CR OR 80H)
0D7D 332F4A41   
0D81 4E2F3230   
0D85 30322020   
0D89 20202D4E   
0D8D 51520D8D   
0D91 12018B     =1  3890            CALL    STROUT
0D94 54797065   =1  3891            DB      'Type HELP for more information.',CR,(CR OR 80H)
0D98 2048454C   
0D9C 5020666F   
0DA0 72206D6F   
0DA4 72652069   
0DA8 6E666F72   
0DAC 6D617469   
0DB0 6F6E2E0D   
0DB4 8D         
0DB5 22         =1  3892            RET
                =1  3893    
0DB6            =1  3894    VER_END:
                =1  3895    $INCLUDE(AES\CMDS\FILES.ASM) ; display program saved
0DB6            =1  3896    FILES_START:
                =1  3897    
0DB6 120623     =1  3898            call tst                        ;Check to see if 'FILE' command
0DB9 46494C45   =1  3899            DB      'FILE',('S'or 80H)
0DBD D3         
0DBE 5078       =1  3900            JNC     FILES_END               ;If not, try next command
0DC0 12018B     =1  3901            CALL    STROUT                 ;Send String Below
0DC3 0D0D2046   =1  3902            DB      CR,CR,' Files in memory ',CR,'=================',CR,80H
LILBASIC        LilBasic (c)2002                                                                              PAGE 68

0DC7 696C6573   
0DCB 20696E20   
0DCF 6D656D6F   
0DD3 7279200D   
0DD7 3D3D3D3D   
0DDB 3D3D3D3D   
0DDF 3D3D3D3D   
0DE3 3D3D3D3D   
0DE7 3D0D80     
0DEA 901E8A     =1  3903            MOV     DPTR,#START_OF_PROGRAMS ;Initilize DATA pointer
                =1  3904    
0DED            =1  3905     FILES_LOOK:
0DED 12119E     =1  3906            CALL    FIND_NEXT_TAG           ;Look for next TAG
0DF0 502A       =1  3907            JNC     FILES_EXIT              ;If end found, then end
0DF2 7400       =1  3908            MOV     A,#0H                   ;Clear A
0DF4 93         =1  3909            MOVC    A,@A+DPTR               ;Get File type
0DF5 F509       =1  3910            MOV     TMP1,A                  ;Save File type
0DF7 A3         =1  3911            INC     DPTR                    ;Step over file type
0DF8 7420       =1  3912            MOV     A,#SPACE                 ;Load A with a space
0DFA 12012A     =1  3913            CALL    C_OUT                   ;Send 2 spaces
0DFD 12019D     =1  3914            CALL    STROUT2                 ;Output file name
0E00 7420       =1  3915            MOV     A,#SPACE                 ;Load A with a space
0E02 12012A     =1  3916            CALL    C_OUT                   ;Send 2 spaces
0E05 12012A     =1  3917            CALL    C_OUT
0E08 7428       =1  3918            MOV     A,#'('                  ;
0E0A 12012A     =1  3919            CALL    C_OUT
0E0D E509       =1  3920            MOV     A,TMP1                  ;Move FILE TYPE into A
0E0F 12012A     =1  3921            CALL    C_OUT                   ;Send File Type to display
0E12 7429       =1  3922            MOV     A,#')'                  ;
0E14 12012A     =1  3923            CALL    C_OUT
                =1  3924    
0E17 120128     =1  3925            CALL    NLINE                   ;Send Line feed
0E1A 80D1       =1  3926            SJMP    FILES_LOOK              ;Look for next file in memory
                =1  3927    
                =1  3928    
                =1  3929    
                =1  3930    
0E1C            =1  3931     FILES_EXIT:
0E1C 12018B     =1  3932            CALL    STROUT                 ;Send String Below
0E1F 3D3D3D3D   =1  3933            DB      '=================',CR,CR,80H
0E23 3D3D3D3D   
0E27 3D3D3D3D   
0E2B 3D3D3D3D   
0E2F 3D0D0D80   
                =1  3934    
0E33 1207EA     =1  3935            CALL    DONE                    ;Get ready for next command
0E36 0122       =1  3936            JMP     NXT                     ;Execute next command
0E38            =1  3937    FILES_END:
                =1  3938    
                =1  3939    $INCLUDE(AES\CMDS\LOAD.ASM)  ; load program
0E38            =1  3940    LOAD_START:
                =1  3941    
0E38 120623     =1  3942            call tst                        ; Check to see if 'FILE' command
0E3B 4C4F41C4   =1  3943            DB      'LOA',('D'or 80H)
0E3F 503A       =1  3944            JNC     LOAD_END                ; If not, try next command
0E41 18         =1  3945            DEC     PNTR_L                  ; Back up pointer to start of FN
0E42 B8FF01     =1  3946            CJNE    PNTR_L,#0FFH,LOAD_CARY
0E45 1A         =1  3947            DEC     PNTR_H
LILBASIC        LilBasic (c)2002                                                                              PAGE 69

0E46            =1  3948    LOAD_CARY:
0E46 D259       =1  3949            SETB    CHAR_FLG                ; Reset read Char flag
0E48 7450       =1  3950            MOV     A,#'P'                  ; Set filetype to Program
0E4A 1211C8     =1  3951            CALL    FIND_FILE               ; Find file in memory
0E4D 4015       =1  3952            JC      LOAD_BADFN              ; Exit if filename invalid!
                =1  3953    
0E4F 750900     =1  3954            MOV     TMP1,#LOW(EXTRAM)       ; Setup To ADDR
0E52 750A20     =1  3955            MOV     TMP2,#HIGH(EXTRAM)      ;
0E55 85820B     =1  3956            MOV     TMP3,DPL                ; Setup From Addr
0E58 85830C     =1  3957            MOV     TMP4,DPH
                =1  3958    
0E5B D25E       =1  3959            SETB    RAMROM                  ; Move from ROM to XRAM
0E5D 1211FD     =1  3960            Call    MOVE_P                  ; Move program in memory
                =1  3961    
0E60            =1  3962     LOAD_EXIT:
0E60 C251       =1  3963            CLR     AUTO                  ; Set Program Mode TO RAM, no autorun
0E62 417A       =1  3964            JMP     START
                =1  3965    
                =1  3966    
                =1  3967    
0E64            =1  3968    LOAD_BADFN:
0E64 12018B     =1  3969            CALL    STROUT                   ; Send String Below
0E67 0D46696C   =1  3970            DB      CR,'File not found',CR,80H
0E6B 65206E6F   
0E6F 7420666F   
0E73 756E640D   
0E77 80         
                =1  3971    
0E78 020FF7     =1  3972            JMP     EXP_ER
                =1  3973    
                =1  3974    
0E7B            =1  3975    LOAD_END:
                =1  3976    $INCLUDE(AES\CMDS\SAVE.ASM)  ; save program
0E7B            =1  3977    SAVE_START:
0E7B 120623     =1  3978            call tst                        ; Check to see if 'SAVE' command
0E7E 534156C5   =1  3979            DB      'SAV',('E'or 80H)
0E82 504B       =1  3980            JNC     SAVE_END                ; If not, try next command
0E84 18         =1  3981            DEC     PNTR_L                  ; Back up pointer to start of FN
0E85 B8FF01     =1  3982            CJNE    PNTR_L,#0FFH,SAVE_CARY
0E88 1A         =1  3983            DEC     PNTR_H
0E89            =1  3984    SAVE_CARY:
0E89 D259       =1  3985            SETB    CHAR_FLG                ; Reset read Char flag
0E8B 7450       =1  3986            MOV     A,#'P'                  ; Set filetype to Program
0E8D 1211C8     =1  3987            CALL    FIND_FILE               ; Find file in memory
0E90 50D2       =1  3988            JNC     LOAD_BADFN              ; Exit if filename found!
                =1  3989    
                =1  3990    
0E92 1212AF     =1  3991            CALL    GET_XTOP                ; Set Datapointer to Top of Xram
                =1  3992    
                =1  3993    
0E95 7450       =1  3994            MOV     A,#'P'                  ; Set filetype to Program
0E97 121237     =1  3995            call SET_TAG                    ; Put header in memory
                =1  3996    
                =1  3997    
0E9A 858209     =1  3998            MOV     TMP1,DPL                ; SET MOVE_P TO Addr
0E9D 85830A     =1  3999            MOV     TMP2,DPH
                =1  4000    
0EA0 750B00     =1  4001            MOV     TMP3,#LOW(EXTRAM)       ; SET MOVE_P FROM Addr
LILBASIC        LilBasic (c)2002                                                                              PAGE 70

0EA3 750C20     =1  4002            MOV     TMP4,#HIGH(EXTRAM)      ;
                =1  4003    
0EA6 C25E       =1  4004            CLR     RAMROM                  ; Set flag to move from XRAM to XRAM
0EA8 1211FD     =1  4005            CALL    MOVE_P                  ; Move PROGRAM in Memory
                =1  4006    
0EAB 121295     =1  4007            CALL    SAVE_XTOP               ; Save new Top of Xram
                =1  4008    
                =1  4009    
                =1  4010    
0EAE            =1  4011     SAVE_EXIT:
                =1  4012    
0EAE 417A       =1  4013            JMP     START
                =1  4014    
                =1  4015    
                =1  4016    
0EB0            =1  4017    SAVE_BADFN:
0EB0 12018B     =1  4018            CALL    STROUT                   ;Send String Below
0EB3 0D44656C   =1  4019            DB      CR,'Delete old file first!',CR,80H
0EB7 65746520   
0EBB 6F6C6420   
0EBF 66696C65   
0EC3 20666972   
0EC7 7374210D   
0ECB 80         
                =1  4020    
0ECC 020FF7     =1  4021            JMP     EXP_ER
0ECF            =1  4022    SAVE_END:
                =1  4023    $INCLUDE(AES\CMDS\WIPEALL.ASM) ; Wipe all programs
0ECF            =1  4024    WIPEALL_START:
                =1  4025    
0ECF 120623     =1  4026            call tst                        ;Check to see if 'WIPEALL' command
0ED2 57495045   =1  4027            DB      'WIPEAL',('L'or 80H)
0ED6 414CCC     
0ED9 5033       =1  4028            JNC     WIPEALL_END             ;If not, try next command
                =1  4029    
0EDB 908002     =1  4030            MOV     DPTR,#XRAM              ;Set pointer to start of MFS mem
0EDE 121295     =1  4031            CALL    SAVE_XTOP               ;Reset top of mem pointer
                =1  4032            ;MOV     DPTR,#XRAM              ;Set pointer to start of MFS mem
                =1  4033    
0EE1            =1  4034    WIPEALL_LOOP:
0EE1 7400       =1  4035            MOV     A,#0                    ;Set A to byte to wipe memory with
0EE3 F0         =1  4036            MOVX    @DPTR,A                 ;Clear memory
                =1  4037    
0EE4 E0         =1  4038            MOVX    A,@DPTR                 ;Check to see if memory Wiped
0EE5 70FA       =1  4039            JNZ     WIPEALL_LOOP            ;Try again if we fail
                =1  4040    
0EE7 E583       =1  4041            MOV     A, DPH                  ;   Get High byte
0EE9 12017B     =1  4042            call    hexout
0EEC E582       =1  4043            MOV     A, DPL                  ;   Get low byte
0EEE 12017B     =1  4044            call    hexout
0EF1 740D       =1  4045            MOV     A, #CR                  ;   Send LF
0EF3 12012A     =1  4046            call    c_out
                =1  4047    
                =1  4048    
                =1  4049                                            ; Handle EEprom Page limitations
0EF6 E582       =1  4050            MOV     A, DPL                  ;   Get low byte
0EF8 541F       =1  4051            ANL     A,#01fh                 ;   Compute 32bit page boundry
0EFA 7007       =1  4052            JNZ     WIPEALL_CONT            ;   Check
LILBASIC        LilBasic (c)2002                                                                              PAGE 71

                =1  4053    
0EFC E0         =1  4054            MOVX     A,@DPTR                ; Force end of write cycle on EEPROM
0EFD 1201B6     =1  4055            CALL    WAIT5MS                 ;  Wait to complete
0F00 1201B6     =1  4056            CALL    WAIT5MS
                =1  4057    
0F03            =1  4058    WIPEALL_CONT:
0F03 A3         =1  4059            INC     DPTR                    ;Bump pointer to next address
0F04 7400       =1  4060            MOV     A,#0
0F06 B583D8     =1  4061            CJNE    A,DPH,WIPEALL_LOOP      ;Continue until end of memory.
                =1  4062    
0F09 1207EA     =1  4063            CALL    DONE                    ;Get ready for next command
0F0C 0122       =1  4064            JMP     NXT                     ;Execute next command
                =1  4065    
                =1  4066    
                =1  4067    
                =1  4068    
                =1  4069    
                =1  4070    
0F0E            =1  4071    WIPEALL_END:
                =1  4072    $INCLUDE(AES\CMDS\LOCK.ASM)    ; lock & Unlock memory
                =1  4073    
                =1  4074    
0F0E            =1  4075    STUNLOCK:                               ;Parse explicit UNLCOK command.
0F0E 120623     =1  4076            call   tst                      ;Test if 'UNLOCK' Command
0F11 2E554E4C   =1  4077            db      '.UNLOC',('K' OR 80H)
0F15 4F43CB     
0F18 5008       =1  4078            jnc     ENDUNLOCK              ;if not 'UNLOCK' command process next command
0F1A 120F47     =1  4079            CALL    UNLOCK
0F1D 1207EA     =1  4080            CALL    DONE                    ;Get ready for next command
0F20 0122       =1  4081            JMP     NXT                     ;Execute next command
                =1  4082    
                =1  4083    
0F22            =1  4084    ENDUNLOCK:
                =1  4085    
0F22            =1  4086    STLOCK:                               ;Parse explicit LOCK command.
0F22 120623     =1  4087            call   tst                      ;Test if 'LOCK' Command
0F25 2E4C4F43   =1  4088            db      '.LOC',('K' OR 80H)
0F29 CB         
0F2A 5008       =1  4089            jnc     ENDLOCK              ;if not 'LOCK' command process next command
0F2C 120F6C     =1  4090            CALL   LOCK
0F2F 1207EA     =1  4091            CALL    DONE                    ;Get ready for next command
0F32 0122       =1  4092            JMP     NXT                     ;Execute next command
                =1  4093    
                =1  4094    
0F34            =1  4095    ENDLOCK:
                =1  4096    
0F34            =1  4097    STCLEAR:                               ;Parse explicit CLEAR command.
0F34 120623     =1  4098            call   tst                      ;Test if 'CLEAR' Command
0F37 2E434C45   =1  4099            db      '.CLEA',('R' OR 80H)
0F3B 41D2       
0F3D 5008       =1  4100            jnc     ENDCLEAR              ;if not 'CLEAR' command process next command
0F3F 120F85     =1  4101            CALL    CLEAR
0F42 1207EA     =1  4102            CALL    DONE                    ;Get ready for next command
0F45 0122       =1  4103            JMP     NXT                     ;Execute next command
                =1  4104    
                =1  4105    
0F47            =1  4106    ENDCLEAR:
                =1  4107    
LILBASIC        LilBasic (c)2002                                                                              PAGE 72

0F47            =1  4108    UNLOCK:
0F47 74AA       =1  4109            mov A,#0AAh
0F49 90D555     =1  4110            mov DPTR,#0D555h                ; Write AA to D555
0F4C F0         =1  4111            MOVX @DPTR,A
                =1  4112    
0F4D 7455       =1  4113            mov A,#55h
0F4F 90AAAA     =1  4114            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F52 F0         =1  4115            MOVX @DPTR,A
                =1  4116    
0F53 7480       =1  4117            mov A,#80h
0F55 90D555     =1  4118            mov DPTR,#0D555h                ; Write 80 to D5555
0F58 F0         =1  4119            MOVX @DPTR,A
                =1  4120    
0F59 74AA       =1  4121            mov A,#0AAh
0F5B 90D555     =1  4122            mov DPTR,#0D555h                ; Write AA to D555
0F5E F0         =1  4123            MOVX @DPTR,A
                =1  4124    
0F5F 7455       =1  4125            mov A,#55h
0F61 90AAAA     =1  4126            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F64 F0         =1  4127            MOVX @DPTR,A
                =1  4128    
0F65 7420       =1  4129            mov A,#20h
0F67 90D555     =1  4130            mov DPTR,#0d555h                ; Write 20 to D5555
0F6A F0         =1  4131            MOVX @DPTR,A
0F6B 22         =1  4132            RET
0F6C            =1  4133    LOCK:
0F6C 74AA       =1  4134            mov A,#0AAh
0F6E 90D555     =1  4135            mov DPTR,#0D555h                ; Write AA to D555
0F71 F0         =1  4136            MOVX @DPTR,A
                =1  4137    
0F72 7455       =1  4138            mov A,#55h
0F74 90AAAA     =1  4139            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F77 F0         =1  4140            MOVX @DPTR,A
                =1  4141    
0F78 74A0       =1  4142            mov A,#0A0h
0F7A 90D555     =1  4143            mov DPTR,#0D555h                ; Write A0 to D5555
0F7D F0         =1  4144            MOVX @DPTR,A
                =1  4145    
0F7E 74AA       =1  4146            mov A,#0AAh
0F80 90D555     =1  4147            mov DPTR,#0D555h                ; Write AA to D555
0F83 F0         =1  4148            MOVX @DPTR,A
0F84 22         =1  4149            RET
0F85            =1  4150    CLEAR:
0F85 74AA       =1  4151            mov A,#0AAh
0F87 90D555     =1  4152            mov DPTR,#0D555h                ; Write AA to D555
0F8A F0         =1  4153            MOVX @DPTR,A
                =1  4154    
0F8B 7455       =1  4155            mov A,#55h
0F8D 90AAAA     =1  4156            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0F90 F0         =1  4157            MOVX @DPTR,A
                =1  4158    
0F91 7480       =1  4159            mov A,#080h
0F93 90D555     =1  4160            mov DPTR,#0D555h                ; Write 80 to D5555
0F96 F0         =1  4161            MOVX @DPTR,A
                =1  4162    
0F97 74AA       =1  4163            mov A,#0AAh
0F99 90D555     =1  4164            mov DPTR,#0D555h                ; Write AA to D555
0F9C F0         =1  4165            MOVX @DPTR,A
LILBASIC        LilBasic (c)2002                                                                              PAGE 73

                =1  4166    
0F9D 7455       =1  4167            mov A,#55h
0F9F 90AAAA     =1  4168            mov DPTR,#0AAAAh                ; Write 55 to AAAA
0FA2 F0         =1  4169            MOVX @DPTR,A
                =1  4170    
0FA3 7410       =1  4171            mov A,#010h
0FA5 90D555     =1  4172            mov DPTR,#0D555h                ; Write 10 to D555
0FA8 F0         =1  4173            MOVX @DPTR,A
                =1  4174    
0FA9 1201B6     =1  4175            CALL WAIT5MS                     ;Wait 30 MS and return
0FAC 1201B6     =1  4176            CALL WAIT5MS
0FAF 1201B6     =1  4177            CALL WAIT5MS
0FB2 1201B6     =1  4178            CALL WAIT5MS
0FB5 1201B6     =1  4179            CALL WAIT5MS
0FB8 0201B6     =1  4180            JMP  WAIT5MS
                =1  4181    
                =1  4182    
                    4183    ;$INCLUDE(AES\CMDS\FORNEXT.ASM)
                    4184    
0FBB 02102E         4185    JMP   SYN_ER           ;If not a command, then Syntax Error
                    4186    
                =1  4187    $INCLUDE(AES\ERROR.ASM)
                =1  4188    
                =1  4189    
0FBE            =1  4190    ERROUT:
                =1  4191    ;       Error handling routine common entry point.
                =1  4192    ;       (Could retype bad line, etc.)
                =1  4193    ;
0FBE AE18       =1  4194            MOV     TOS_L,LABL_L
0FC0 AF19       =1  4195            MOV     TOS_H,LABL_H
0FC2 8E1B       =1  4196            MOV     ELN_L,TOS_L             ;Save Line # of error for later use
0FC4 8F1C       =1  4197            MOV     ELN_H,TOS_H
0FC6 BE0005     =1  4198            CJNE    TOS_L,#0H,ERROR_PR      ;Jump to print routine if Error was from line #
0FC9 BF0002     =1  4199            CJNE    TOS_H,#0H,ERROR_PR
                =1  4200    
0FCC            =1  4201    ERROR_NP:
0FCC 417A       =1  4202            JMP     ERRENT          ;Return to executive.
                =1  4203    
                =1  4204    
0FCE            =1  4205    ERROR_PR:                       ;Print Basic line number of Error
0FCE 12018B     =1  4206            CALL    STROUT
0FD1 4572726F   =1  4207            DB      'Error in line number ',(80H)
0FD5 7220696E   
0FD9 206C696E   
0FDD 65206E75   
0FE1 6D626572   
0FE5 2080       
0FE7 751D00     =1  4208            MOV     AESP,#00H               ;Initialize AES pointer.
0FEA 1201DF     =1  4209            CALL    PUSH_TOS        ;Push Error Line number on stack
0FED 1194       =1  4210            CALL PRN                ;Print it
0FEF 12018B     =1  4211            CALL    STROUT          ;Output error message.
0FF2 2E208D     =1  4212            DB      '. ',(CR OR 80H)
0FF5 80D5       =1  4213            SJMP    ERROR_NP
                =1  4214    ;
                =1  4215    ;=======
                =1  4216    ;
                =1  4217    ;EXP_ER Expression evaluation error.
0FF7 12018B     =1  4218    EXP_ER: CALL    STROUT          ;Output error message.
LILBASIC        LilBasic (c)2002                                                                              PAGE 74

0FFA 4E6F7420   =1  4219            DB      'Not within my means.  ',07,(CR OR 80H)
0FFE 77697468   
1002 696E206D   
1006 79206D65   
100A 616E732E   
100E 2020078D   
1012 751A01     =1  4220            MOV     ERROR,#01
1015 80A7       =1  4221            JMP     ERROUT          ;Return to executive.
                =1  4222    ;
                =1  4223    ;=======
                =1  4224    ;
                =1  4225    ;AES_ER Arithmetic expression stack error handling routine.
1017 12018B     =1  4226    AES_ER: CALL    STROUT          ;Output error message.
101A 53746163   =1  4227            DB      'Stack error. ',07,(CR OR 80H)
101E 6B206572   
1022 726F722E   
1026 20078D     
1029 751A02     =1  4228            MOV     ERROR,#02
102C 8090       =1  4229            JMP     ERROUT          ;Return to executive.
                =1  4230    ;
                =1  4231    ;
                =1  4232    ;=======
                =1  4233    ;
                =1  4234    ;SYN_ER Syntax error handling routine.
102E 12018B     =1  4235    SYN_ER: CALL    STROUT          ;Output error message.
1031 0D53796E   =1  4236            DB      CR,'Syntax error. ',07,(CR OR 80H)
1035 74617820   
1039 6572726F   
103D 722E2007   
1041 8D         
1042 751A01     =1  4237            MOV     ERROR,#01
1045 020FBE     =1  4238            JMP     ERROUT          ;Process error.
                =1  4239    ;
                =1  4240    ;=======
                =1  4241    ;
                =1  4242    ;OV_ER overflow error handling routine.
1048 12018B     =1  4243    OV_ER: CALL    STROUT          ;Output error message.
104B 0D4F7665   =1  4244           DB      CR,'Overflow error. ',07,(CR OR 80H)
104F 72666C6F   
1053 77206572   
1057 726F722E   
105B 20078D     
105E 751A04     =1  4245           MOV     ERROR,#04
1061 020FBE     =1  4246           JMP    ERROUT          ;Process error.
                =1  4247    ;
                =1  4248    
                =1  4249    ;=======
                    4250    ;EXP_ER
                    4251    ;       Expression evaluation error.
                    4252    ;AES_ER
                    4253    ;       Arithmetic expression stack error handling routine.
                    4254    ;SYN_ER
                    4255    ;       Syntax error handling routine.
                    4256    ;OV_ER
                    4257    ;       Overflow error handling routine.
                    4258    ;===========================================================================================
                                                                               ===============
                    4259    ;
LILBASIC        LilBasic (c)2002                                                                              PAGE 75

                    4260    ;
                    4261    ;       INTERPRETIVE LANGUAGE SUBROUTINES:
                    4262    ;       ============ ======== ===========
                    4263    ;
1064 121074         4264    EXPR:   CALL    AR_EXP
1067 121157         4265    E0:     CALL    RELOP
106A 5046           4266            JNC     E5
106C 121074         4267            CALL    AR_EXP
106F 120554         4268            CALL    CMPR
1072 80F3           4269            JMP    E0
                    4270    
1074 1210B3         4271    AR_EXP: CALL  TERM
                    4272    
                    4273    
                    4274    ;*E1:     %TST    (E2,+)
1077 120623         4275    e1:     call   tst
107A AB             4276            db      ('+' OR 80H)
107B 5008           4277            jnc     e2
107D 1210B3         4278            CALL   TERM
1080 1203EF         4279            CALL    IADD
1083 80F2           4280            JMP    E1
                    4281    ;
                    4282    ;*E2:     %TST    (E3,-)
1085 120623         4283    e2:     call   tst
1088 AD             4284            db      ('-' OR 80H)
1089 5008           4285            jnc     e3
108B 1210B3         4286            CALL  TERM
108E 120401         4287            CALL    ISUB
1091 80E4           4288            JMP    E1
                    4289    ;
                    4290    ;*E3:     %TST    (E4,OR)
1093 120623         4291    e3:     call   tst
1096 4FD2           4292            db      'O',('R' OR 80H)
1098 5008           4293            jnc     e4
109A 1210B3         4294            CALL  TERM
109D 12041D         4295            CALL    IOR
10A0 80D5           4296            JMP    E1
                    4297    ;
                    4298    ;*E4:     %TST    (E5,XOR)
10A2 120623         4299    e4:     call   tst
10A5 584FD2         4300            db      'XO',('R' OR 80H)
10A8 5008           4301            jnc     e5
10AA 1210B3         4302            CALL  TERM
10AD 12042A         4303            CALL    IXOR
10B0 80C5           4304            JMP    E1
                    4305    
10B2 22             4306    E5:     RET
                    4307    ;
                    4308    ;
                    4309    ;=======
                    4310    ;
10B3 1210F3         4311    TERM:   CALL  FACT
                    4312    ;*TERM_0: %TST    (TERM_1,*)
10B6 120623         4313    term_0: call   tst
10B9 AA             4314            db      ('*' OR 80H)
10BA 5008           4315            jnc     term_1
10BC 1210F3         4316            CALL  FACT
10BF 1204AD         4317            CALL    IMUL
LILBASIC        LilBasic (c)2002                                                                              PAGE 76

10C2 80F2           4318            JMP    TERM_0
                    4319    ;
                    4320    ;*TERM_1: %TST    (TERM_2,/)
10C4 120623         4321    term_1: call   tst
10C7 AF             4322            db      ('/' OR 80H)
10C8 5008           4323            jnc     term_2
10CA 1210F3         4324            CALL  FACT
10CD 1204C0         4325            CALL    IDIV
10D0 80E4           4326            JMP    TERM_0
                    4327    ;
                    4328    ;*TERM_2: %TST    (TERM_3,AND)
10D2 120623         4329    term_2: call   tst
10D5 414EC4         4330            db      'AN',('D' OR 80H)
10D8 5008           4331            jnc     term_3
10DA 1210F3         4332            CALL  FACT
10DD 120410         4333            CALL    IAND
10E0 80D4           4334            JMP    TERM_0
                    4335    ;
                    4336    ;*TERM_3: %TST    (TERM_4,MOD)
10E2 120623         4337    term_3: call   tst
10E5 4D4FC4         4338            db      'MO',('D' OR 80H)
10E8 5008           4339            jnc     term_4
10EA 1210F3         4340            CALL  FACT
10ED 1204BC         4341            CALL    IMOD
10F0 80C4           4342            JMP    TERM_0
                    4343    ;
10F2 22             4344    TERM_4: RET
                    4345    ;
                    4346    ;=======
                    4347    ;
                    4348    ;*FACT:   %TST    (FACT_1,-)
10F3 120623         4349    fact:   call   tst
10F6 AD             4350            db      ('-' OR 80H)
10F7 5007           4351            jnc     fact_1
10F9 12110F         4352            CALL  VAR
10FC 12044B         4353            CALL    NEG
10FF 22             4354            RET
                    4355    ;
                    4356    ;*FACT_1: %TST    (VAR,NOT)
1100 120623         4357    fact_1: call   tst
1103 4E4FD4         4358            db      'NO',('T' OR 80H)
1106 5007           4359            jnc     var
1108 12110F         4360            CALL  VAR
110B 120448         4361            CALL    ICPL
110E 22             4362            RET
                    4363    ;
                    4364    ;
                    4365    ;=======
                    4366    ;
                    4367 +1 VAR:    TSTV_   VAR_0
110F 120654         4368 +1         CALL    TSTV
1112 5004           4369 +1         JNC     VAR_0
1114 120339         4371            CALL    FETCH
1117 22             4372            RET
                    4373    ;
                    4374 +1 VAR_0:  TSTN_   VAR_1
1118 1207B6         4375 +1         CALL    TSTN
111B 5001           4376 +1         JNC     VAR_1
LILBASIC        LilBasic (c)2002                                                                              PAGE 77

111D 22             4378            RET
                    4379    ;
                    4380    ;*VAR_1:  %TST    (VAR_1A,RND)
111E 120623         4381    var_1:  call   tst
1121 524EC4         4382            db      'RN',('D' OR 80H)
1124 5010           4383            jnc     var_1a
1126 12052C         4384            CALL    RND
1129 121145         4385            CALL  VAR_2
112C 1204BC         4386            CALL    IMOD
112F 120437         4387            CALL    IABS
1132 120465         4388            CALL    IINC
1135 22             4389            RET
                    4390    ;
                    4391    ;*VAR_1A: %TST    (VAR_2,ABS)
1136 120623         4392    var_1a: call   tst
1139 4142D3         4393            db      'AB',('S' OR 80H)
113C 5007           4394            jnc     var_2
113E 121145         4395            CALL  VAR_2
1141 120437         4396            CALL    IABS
1144 22             4397            RET
                    4398    ;
                    4399    ;*VAR_2:  %TST    (SYN_NG,%1()
1145 120623         4400    var_2:  call   tst
1148 A8             4401            db      ('(' OR 80H)            ;to match lil'basic.LST
1149 5009           4402            jnc     syn_ng
114B 1164           4403            CALL  EXPR
                    4404    ;*        %TST    (SYN_NG,%1))
114D 120623         4405            call   tst
1150 A9             4406            db      (')' OR 80H)            ;to match lil'basic.LST
1151 5001           4407            jnc     syn_ng
1153 22             4408            RET
                    4409    ;
                    4410    ;=======
                    4411    ;
1154 020AD8         4412    SYN_NG: JMP   CMD_NG
                    4413    ;
                    4414    
                    4415    ;
1157                4416    RELOP:
                    4417    ;       Search for relational operator in text string.
                    4418    ;       If found, push appropriate operator code on AES and return with
                    4419    ;       carry set.
                    4420    ;       Otherwise restore cursor and return with carry=0.
                    4421    ;
                    4422    ;*        %TST    (REL_1,=)
1157 120623         4423            call   tst
115A BD             4424            db      ('=' OR 80H)
115B 5005           4425            jnc     rel_1
115D 120210         4426            CALL    LIT
1160 02             4427            DB      010B            ;Test for _=_
1161 22             4428            RET
                    4429    ;
                    4430    ;*REL_1:  %TST    (REL_2,<=)
1162 120623         4431    rel_1:  call   tst
1165 3CBD           4432            db      '<',('=' OR 80H)
1167 5005           4433            jnc     rel_2
1169 120210         4434            CALL    LIT
116C 06             4435            DB      110B            ;Test for <=_
LILBASIC        LilBasic (c)2002                                                                              PAGE 78

116D 22             4436            RET
                    4437    ;
                    4438    ;*REL_2:  %TST    (REL_3,<>)
116E 120623         4439    rel_2:  call   tst
1171 3CBE           4440            db      '<',('>' OR 80H)
1173 5005           4441            jnc     rel_3
1175 120210         4442            CALL    LIT
1178 05             4443            DB      101B            ;Test for <_>
1179 22             4444            RET
                    4445    ;
                    4446    ;*REL_3:  %TST    (REL_4,<)
117A 120623         4447    rel_3:  call   tst
117D BC             4448            db      ('<' OR 80H)
117E 5005           4449            jnc     rel_4
1180 120210         4450            CALL    LIT
1183 04             4451            DB      100B            ;Test for <__
1184 22             4452            RET
                    4453    ;
                    4454    ;*REL_4:  %TST    (REL_5,>=)
1185 120623         4455    rel_4:  call   tst
1188 3EBD           4456            db      '>',('=' OR 80H)
118A 5005           4457            jnc     rel_5
118C 120210         4458            CALL    LIT
118F 03             4459            DB      011B            ;Test for _=>
1190 22             4460            RET
                    4461    ;
                    4462    ;*REL_5:  %TST    (REL_6,>)
1191 120623         4463    rel_5:  call   tst
1194 BE             4464            db      ('>' OR 80H)
1195 5005           4465            jnc     rel_6
1197 120210         4466            CALL    LIT
119A 01             4467            DB      001B            ;Test for __>
119B 22             4468            RET
                    4469    ;
119C C3             4470    REL_6:  CLR     C
119D 22             4471            RET
                    4472    ;
                    4473    ;======================================================================================
                    4474    ;       Memory File System
                    4475    ;======================================================================================
                    4476    
                    4477    ; FIND_NEXT_TAG
                    4478    ;
                    4479    ; SERCH FOR NEXT TAG IN MEMORY
                    4480    ; TAG = 029H,0EEH,0F1H,0F2H
                    4481    ; Uses ACC,DPTR,C
                    4482    ; Set:          DPTR --> start location
                    4483    ; Returns:      DPTR --> end of TAG   C --> 1 Found TAG   0 No TAG found
                =1  4484    $INCLUDE(MFS\TAG.asm)
                =1  4485    ; FIND_NEXT_TAG
                =1  4486    ;
                =1  4487    ; SERCH FOR NEXT TAG IN MEMORY
                =1  4488    ; TAG = 029H,0EEH,0F1H,0F2H
                =1  4489    ;
                =1  4490    ; Uses ACC,DPTR,C
                =1  4491    ; Set:          DPTR --> start location
                =1  4492    ; Returns:      DPTR --> end of TAG   C --> 1 Found TAG   0 No TAG found
                =1  4493    
LILBASIC        LilBasic (c)2002                                                                              PAGE 79

119E            =1  4494    FIND_NEXT_TAG:
119E E583       =1  4495            MOV     A,DPH           ; Get highbyte of current pointer address
11A0 6024       =1  4496            JZ      NOT_TAG          ; TAG not allowed in first 256 bytes of mem, so exit with f
                                                                               alse if we are there.
11A2 1211AC     =1  4497            CALL    IS_TAG          ; Check to see if DPTR --> TAG
11A5 A3         =1  4498            INC     DPTR            ; Increment DPRT to next byte
11A6 50F6       =1  4499            JNC     FIND_NEXT_TAG   ; If tag not found then try again.
11A8            =1  4500    TAG_FOUND:
11A8 A3         =1  4501            INC     DPTR            ;Increment DPRT past tag
11A9 A3         =1  4502            INC     DPTR
11AA A3         =1  4503            INC     DPTR
11AB 22         =1  4504            RET
                =1  4505    
                =1  4506    
                =1  4507    
                =1  4508    ; Check if current location DPTR in memory is a TAG.
                =1  4509    ; C flag = 1 if true 0 if false.
11AC            =1  4510    IS_TAG:
                =1  4511    
11AC 7400       =1  4512            MOV     A,#00H          ; Check first byte
11AE 93         =1  4513            MOVC    A,@A+DPTR
11AF B42914     =1  4514            CJNE    A,#029H,NOT_TAG ; Exit if fail
                =1  4515    
11B2 7401       =1  4516            MOV     A,#01H          ; Check second byte
11B4 93         =1  4517            MOVC    A,@A+DPTR
11B5 B4EE0E     =1  4518            CJNE    A,#0EEH,NOT_TAG ; Exit if fail
                =1  4519    
11B8 7402       =1  4520            MOV     A,#02H          ; Check third byte
11BA 93         =1  4521            MOVC    A,@A+DPTR
11BB B4F108     =1  4522            CJNE    A,#0F1H,NOT_TAG
                =1  4523    
11BE 7403       =1  4524            MOV     A,#03H          ; Check forth byte
11C0 93         =1  4525            MOVC    A,@A+DPTR
11C1 B4F202     =1  4526            CJNE    A,#0F2H,NOT_TAG ; Exit if fail else TAG=valid !!!
                =1  4527    
11C4            =1  4528    YES_TAG:
11C4 D3         =1  4529            SETB    C               ; Set flag for True
11C5 22         =1  4530            RET
                =1  4531    
11C6            =1  4532    NOT_TAG:
11C6 C3         =1  4533            CLR     C               ; Clear flag for False
11C7 22         =1  4534            RET
                =1  4535    
                    4536    
                    4537    
                    4538    
                    4539    ;=======
                    4540    ;FIND_FILE
                    4541    ;Find file pointed ontop of AES stack
                    4542    ; then point to program in memory!
                    4543    ; Uses A,DPTR,TMP1,TMP5,TMP6,TMP7
                    4544    ; Needs:        AESP --> Filename
                    4545    ;               A    --> Filetype
                    4546    ;
                    4547    ; Returns :     DPTR --> Start of program
                    4548    ;               C    --> Set if File not found.
                =1  4549    $INCLUDE(MFS\FIND.asm)
                =1  4550    ;FIND_FILE
LILBASIC        LilBasic (c)2002                                                                              PAGE 80

                =1  4551    ;Find file pointed ontop of AES stack
                =1  4552    ; then point to program in memory!
                =1  4553    ; Needs:        PNTR_L --> Filename
                =1  4554    ;               PNTR_H -^
                =1  4555    ;               A      --> Filetype
                =1  4556    ;
                =1  4557    ; Returns :     DPTR  --> Start of program
                =1  4558    ;               C     --> SET = File name not found
                =1  4559    ;
                =1  4560    ; Uses:         TMP1  --> File Type
                =1  4561    ;               TMP2  --> Char in FN pointer/counter
                =1  4562    ;               TMP3  --> AES Pointer as is was when entered subroutine.
                =1  4563    ;               TMP4  -^
                =1  4564    ;               TMP5  --> Current char in AES FN being processed
                =1  4565    
                =1  4566    
                =1  4567    
                =1  4568    
11C8            =1  4569    FIND_FILE:
11C8 F509       =1  4570            MOV     TMP1,A                  ;Save Filetype
11CA 880B       =1  4571            MOV     TMP3,PNTR_L             ;Save Pointer
11CC 8A0C       =1  4572            MOV     TMP4,PNTR_H             ;Save Pointer
11CE 1205E5     =1  4573            CALL    READ_CHAR               ;Clear read char if needed
11D1 901E8A     =1  4574            MOV     DPTR,#START_OF_PROGRAMS ;Initilize DATA pointer
                =1  4575    
11D4            =1  4576    FIND_LOOP:
11D4 319E       =1  4577            CALL    FIND_NEXT_TAG           ;Get next tag in memory
11D6 5021       =1  4578            JNC     FIND_NO_FILE            ;If end found, then end
11D8 7400       =1  4579            MOV     A,#0H                   ;Clear A
11DA 93         =1  4580            MOVC    A,@A+DPTR               ;Get File type
11DB A3         =1  4581            INC     DPTR                    ;Step over tag
11DC B509F5     =1  4582            CJNE    A,TMP1,FIND_LOOP        ;If not the right file type, then try again.
11DF A80B       =1  4583            MOV     PNTR_L,TMP3             ;Restore Pointer
11E1 AA0C       =1  4584            MOV     PNTR_H,TMP4             ;Restore Pointer
                =1  4585    
11E3            =1  4586    FIND_COMP_C:
                =1  4587    
11E3 1205E5     =1  4588            CALL    READ_CHAR
11E6 12010C     =1  4589            CALL    UPPER                   ;Convert  to uppercase
11E9 F50D       =1  4590            MOV     TMP5,A                  ;Save Char for later use
11EB 7400       =1  4591            MOV     A,#0                    ;Clear Out A
11ED 93         =1  4592            MOVC    A,@A+DPTR               ;Get character in DPRT string
11EE A3         =1  4593            INC     DPTR
11EF 12010C     =1  4594            CALL    UPPER                   ;Convert to uppercase
11F2 6007       =1  4595            JZ      FOUND_FILE              ;If at the end of FN then exit
11F4            =1  4596    FIND_CONT:
11F4 B50DDD     =1  4597            CJNE    A,TMP5,FIND_LOOP        ;if chars not equal, Try next tag
11F7 80EA       =1  4598            SJMP    FIND_COMP_C             ;Else check next char
                =1  4599    
11F9            =1  4600    FIND_NO_FILE:                           ;File dosn't exist
11F9 D3         =1  4601            SETB    C                       ;Flag invalid name
11FA 22         =1  4602            RET
                =1  4603    
11FB            =1  4604    FOUND_FILE:                              ;Found File !!!!!
                =1  4605    
11FB C3         =1  4606            CLR     C                        ;Flag valid name
11FC 22         =1  4607            RET
                    4608    
LILBASIC        LilBasic (c)2002                                                                              PAGE 81

                    4609    
                    4610    ;=======
                    4611    ; Move Program
                    4612    ; Move Basic program in memory FROM,TO
                    4613    ; Uses A,DPTR
                    4614    ; NEEDS         TMP1,TMP2 --> TO   L,H
                    4615    ;               TMP3,TMP4 --> FROM L,H
                    4616    ;               RAMROM    --> Set = ROM to XRAM
                    4617    ;                             Clr = XRAM to XRAM
                    4618    ; RETURNS       DPTR      --> END of moved file +1
                =1  4619    $INCLUDE(MFS\MOVE_P.asm)
                =1  4620    
                =1  4621    
                =1  4622    ; Move Program
                =1  4623    ; Move Basic program in memory FROM TMP1,2 TO TMP3,4
                =1  4624    ; Uses A,DPTR
                =1  4625    ; NEEDS         TMP1,TMP2 --> TO   L,H
                =1  4626    ;               TMP3,TMP4 --> FROM L,H
                =1  4627    ;               RAMROM    --> Set = ROM to XRAM
                =1  4628    ;                             Clr = XRAM to XRAM
                =1  4629    ;
                =1  4630    ;RETURNS        DPTR      --> End of file +1 address
                =1  4631    
11FD            =1  4632    MOVE_P:
11FD 850B82     =1  4633            MOV     DPL,TMP3                ; Get from addr
1200 850C83     =1  4634            MOV     DPH,TMP4
                =1  4635    
1203 205E03     =1  4636            JB      RAMROM,MOVE_ROM         ; Fetch from RAM/ROM ?  Set = ROM
                =1  4637    
1206            =1  4638    MOVE_XRAM:                              ; Get byte from XRAM
1206 E0         =1  4639            MOVX    A,@DPTR
1207 8002       =1  4640            SJMP    MOVE_CONT
                =1  4641    
1209            =1  4642    MOVE_ROM:                               ; Get byte from ROM
1209 E4         =1  4643            CLR     A
120A 93         =1  4644            MOVC    A,@A+DPTR               ; Get Byte
                =1  4645    
120B            =1  4646    MOVE_CONT:
120B A3         =1  4647            INC     DPTR                    ; Bump to next byte
120C 85820B     =1  4648            MOV     TMP3,DPL                ; Save From Addr
120F 85830C     =1  4649            MOV     TMP4,DPH
                =1  4650    
1212 850982     =1  4651            MOV     DPL,TMP1                ; Get To Addr
1215 850A83     =1  4652            Mov     DPH,TMP2
1218 F0         =1  4653            MOVX    @DPTR,A                 ; Store Byte
1219 A3         =1  4654            INC     DPTR
                =1  4655    
                =1  4656                                            ; Handle EEprom Page limitations
121A C0E0       =1  4657            PUSH ACC                        ; Save reg
121C E582       =1  4658            MOV     A, DPL                  ;   Get low byte
121E 541F       =1  4659            ANL     A,#01fh                 ;   Compute 32bit page boundry
1220 7007       =1  4660            JNZ     MOVE_CONT_2             ;   Check
                =1  4661    
1222 E0         =1  4662            MOVX    A,@DPTR         ; Force end of write cycle on EEPROM
1223 1201B6     =1  4663            CALL    WAIT5MS                 ;  Wait to complete
1226 1201B6     =1  4664            CALL    WAIT5MS
                =1  4665    
1229            =1  4666    MOVE_CONT_2:                            ; Restore Registers
LILBASIC        LilBasic (c)2002                                                                              PAGE 82

1229 D0E0       =1  4667            POP ACC
                =1  4668    
122B 858209     =1  4669            MOV     TMP1,DPL                ; Save To Addr
122E 85830A     =1  4670            MOV     TMP2,DPH
1231 5480       =1  4671            ANL     A,#80H                  ; Mask of all but MSB
1233 B480C7     =1  4672            CJNE    A,#80H,MOVE_P           ; If MSB not not set, move Next Byte
1236 22         =1  4673            RET                             ; Else we have moved the program
                    4674    
                    4675    ;=======
                    4676    
                    4677    ;SET_TAG
                    4678    ; Store  in memory
                    4679    ;029H,0EEH,0F1H,0F2H,'P',NAME,00H
                    4680    ; NEEDS         DPTR    --> Start Address in RAM
                    4681    
                    4682    ;               A       --> FILE TYPE
                    4683    ;               PNTR_L  --> Poiner to filename
                    4684    ;               PNTR_H
                    4685    ; USES          TMP1, TMP2
                =1  4686    $INCLUDE(MFS\SETTAG.asm)
                =1  4687    ;SET_TAG
                =1  4688    ; Store  in memory
                =1  4689    ;029H,0EEH,0F1H,0F2H,'P',NAME,00H
                =1  4690    ; NEEDS         DPTR    --> Start Address in RAM
                =1  4691    ;               A       --> FILE TYPE
                =1  4692    ;               PNTR_L  --> Poiner to filename
                =1  4693    ;               PNTR_H
                =1  4694    ;USES           TMP1,2
                =1  4695    
1237            =1  4696    SET_TAG:
                =1  4697    
1237 F509       =1  4698            MOV    TMP1,A           ; Save file type
                =1  4699    
1239 7429       =1  4700            MOV     A,#029H         ; Store 029H,0EEH,0F1H,0F2H in Xmem
123B F0         =1  4701            MOVX    @DPTR,A
123C E0         =1  4702            MOVX    A,@DPTR         ; Force end of write cycle on EEPROM
123D 1201B6     =1  4703            CALL    WAIT5MS                 ;  Wait to complete
1240 1201B6     =1  4704            CALL    WAIT5MS
1243 A3         =1  4705            INC     DPTR
                =1  4706    
1244 74EE       =1  4707            MOV     A,#0EEH
1246 F0         =1  4708            MOVX    @DPTR,A
1247 E0         =1  4709            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1248 1201B6     =1  4710            CALL    WAIT5MS                 ;  Wait to complete
124B 1201B6     =1  4711            CALL    WAIT5MS
124E A3         =1  4712            INC     DPTR
                =1  4713    
124F 74F1       =1  4714            MOV     A,#0F1H
1251 F0         =1  4715            MOVX    @DPTR,A
1252 E0         =1  4716            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1253 1201B6     =1  4717            CALL    WAIT5MS                 ;  Wait to complete
1256 1201B6     =1  4718            CALL    WAIT5MS
1259 A3         =1  4719            INC     DPTR
                =1  4720    
125A 74F2       =1  4721            MOV     A,#0F2H
125C F0         =1  4722            MOVX    @DPTR,A
125D E0         =1  4723            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
125E 1201B6     =1  4724            CALL    WAIT5MS                 ;  Wait to complete
LILBASIC        LilBasic (c)2002                                                                              PAGE 83

1261 1201B6     =1  4725            CALL    WAIT5MS
1264 A3         =1  4726            INC     DPTR
                =1  4727    
1265 E509       =1  4728            MOV     A,TMP1          ; Store File Type in Xmem
1267 F0         =1  4729            MOVX    @DPTR,A
1268 E0         =1  4730            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
1269 1201B6     =1  4731            CALL    WAIT5MS                 ;  Wait to complete
126C 1201B6     =1  4732            CALL    WAIT5MS
                =1  4733    
126F 18         =1  4734            DEC     PNTR_L          ; Back up pointer to start of FN
1270 B8FF00     =1  4735            CJNE    PNTR_L,#0FFH,SET_TAG_JMP
1273            =1  4736    SET_TAG_JMP:
1273 1A         =1  4737            DEC     PNTR_H
                =1  4738    
                =1  4739    
1274            =1  4740    SET_TAG_LOOP:                   ; Move File Name into Xmem
1274 A3         =1  4741            INC DPTR                ; Bump pointer to next Char
1275 C082       =1  4742            PUSH    DPL             ; Save DPTR
1277 C083       =1  4743            PUSH    DPH
                =1  4744    
                =1  4745    
1279 1205E5     =1  4746            CALL    READ_CHAR       ; Get char from AES
127C 12010C     =1  4747            CALL    UPPER           ; Convert  to uppercase
                =1  4748    
127F D083       =1  4749            POP DPH                 ; Store char from FN in Xmem
1281 D082       =1  4750            POP DPL
1283 F0         =1  4751            MOVX    @DPTR,A
1284 1200E6     =1  4752            CALL    ISALPHANUM      ; check to see if char is AlphaNumeric
1287 40EB       =1  4753            JC      SET_TAG_LOOP    ; Continue as long as char between A and Z
                =1  4754    
1289            =1  4755    SET_TAG_EOFN:
1289 7400       =1  4756            MOV     A,#00H          ; Store 00 in mem to mark end of FN
128B F0         =1  4757            MOVX    @DPTR,A
128C E0         =1  4758            MOVX    A,@DPTR                 ; Force end of write cycle on EEPROM
128D 1201B6     =1  4759            CALL    WAIT5MS                 ;  Wait to complete
1290 1201B6     =1  4760            CALL    WAIT5MS
1293 A3         =1  4761            INC     DPTR
                =1  4762    
                =1  4763    
1294 22         =1  4764            RET
                    4765    
                    4766    
                    4767    ;=======
                    4768    
                    4769    
                    4770    ; XTOP
                    4771    ; Maintance for top of Xternal Memory File System
                    4772    ; Value is stored in Xram so it is not lost when
                    4773    ; power is lost!
                    4774    ;
                    4775    ; SAVE_XTOP
                    4776    ; Needs:        DPRT  --> New top of Xram
                    4777    ; Uses          A
                    4778    ;
                    4779    ;
                    4780    ; GET_XTOP
                    4781    ; Returns:      DPRT  --> New top of Xram
                    4782    ; Uses          A
LILBASIC        LilBasic (c)2002                                                                              PAGE 84

                =1  4783    $INCLUDE(MFS\XTOP.asm)
                =1  4784    ; XTOP
                =1  4785    ; Maintance for top of Xternal Memory File System
                =1  4786    ; Value is stored in Xram so it is not lost when
                =1  4787    ; power is lost!
                =1  4788    ;
                =1  4789    ; SAVE_XTOP
                =1  4790    ; Needs:        DPRT  --> New top of Xram
                =1  4791    ; Uses          A
                =1  4792    ;
                =1  4793    ;
                =1  4794    ; GET_XTOP
                =1  4795    ; Returns:      DPRT  --> New top of Xram
                =1  4796    ; Uses          A
                =1  4797    
                =1  4798    
                =1  4799    
                =1  4800    
1295            =1  4801    SAVE_XTOP:
1295 C082       =1  4802            PUSH    DPL                             ;Save Xtop Value
1297 C083       =1  4803            PUSH    DPH
1299 E582       =1  4804            MOV     A,DPL                           ;Get Low Byte
129B 908000     =1  4805            MOV     DPTR,#XTOP                      ;Point to first address
129E F0         =1  4806            MOVX    @DPTR,A                         ;Store Low Byte
129F A3         =1  4807            INC     DPTR                            ;Bump Pointer to next addr
12A0 D0E0       =1  4808            POP     ACC                             ;Get High Byte
12A2 F0         =1  4809            MOVX    @DPTR,A                         ;Store High Byte
                =1  4810    
12A3 E0         =1  4811            MOVX    A,@DPTR                         ; Flush Eprom
12A4 1201B6     =1  4812            CALL    WAIT5MS
12A7 1201B6     =1  4813            CALL    WAIT5MS
                =1  4814    
12AA F583       =1  4815            MOV     DPH,A                           ;Move High Byte to DPTR
12AC D082       =1  4816            POP     DPL                             ;Move Low Byte to DPTR
12AE 22         =1  4817            RET
                =1  4818    
                =1  4819    
                =1  4820    
                =1  4821    
12AF            =1  4822    GET_XTOP:
12AF 908000     =1  4823            MOV     DPTR,#XTOP                      ;Point to first address
12B2 E0         =1  4824            MOVX    A,@DPTR                         ;Get Low Byte
12B3 C0E0       =1  4825            PUSH    ACC                               ;Save Low Byte
12B5 A3         =1  4826            INC     DPTR                            ;Bump Pointer to next addr
12B6 E0         =1  4827            MOVX    A,@DPTR                         ;Get High Byte
12B7 F583       =1  4828            MOV     DPH,A                           ;Move High Byte to DPTR
12B9 D082       =1  4829            POP     DPL                             ;Move Low Byte to DPTR
12BB 22         =1  4830            RET
                    4831    
                    4832    
                    4833    
                    4834    ;End Of Basic code
                    4835    ;======================================================================================
                    4836    ;       Basic Help Files
                    4837    ;======================================================================================
                    4838    
                    4839    
                    4840    
LILBASIC        LilBasic (c)2002                                                                              PAGE 85

                =1  4841    $INCLUDE(AES\CMDS\HELPTEXT.ASM)         ;Text Help FILE
12BC            =1  4842    HELPTEXT:      ;Help file to be displayed when 'HELP' command typed. END w/00HEX
                =1  4843    
12BC 1B5B324A   =1  4844            DB      ESC,'[2J'       ;(CLS)
                =1  4845    
12C0 204C696C   =1  4846            DB      ' Lil''Basic HELP (c)2002  -NQR',CR
12C4 27426173   
12C8 69632048   
12CC 454C5020   
12D0 28632932   
12D4 30303220   
12D8 202D4E51   
12DC 520D       
12DE 2D2D2D2D   =1  4847            DB      '-------------------------------------------------------------------',CR
12E2 2D2D2D2D   
12E6 2D2D2D2D   
12EA 2D2D2D2D   
12EE 2D2D2D2D   
12F2 2D2D2D2D   
12F6 2D2D2D2D   
12FA 2D2D2D2D   
12FE 2D2D2D2D   
1302 2D2D2D2D   
1306 2D2D2D2D   
130A 2D2D2D2D   
130E 2D2D2D2D   
1312 2D2D2D2D   
1316 2D2D2D2D   
131A 2D2D2D2D   
131E 2D2D2D0D   
1322 0D         =1  4848            DB      CR
1323 48656C70   =1  4849            DB      'Help On HELP command',CR
1327 204F6E20   
132B 48454C50   
132F 20636F6D   
1333 6D616E64   
1337 0D         
1338 2D2D2D2D   =1  4850            DB      '--------------',CR
133C 2D2D2D2D   
1340 2D2D2D2D   
1344 2D2D0D     
1347 48454C50   =1  4851            DB      'HELP CMDS .......... Help on Basic commands',CR
134B 20434D44   
134F 53202E2E   
1353 2E2E2E2E   
1357 2E2E2E2E   
135B 2048656C   
135F 70206F6E   
1363 20426173   
1367 69632063   
136B 6F6D6D61   
136F 6E64730D   
1373 48454C50   =1  4852            DB      'HELP FUNC .......... Help on Basic functions',CR
1377 2046554E   
137B 43202E2E   
137F 2E2E2E2E   
1383 2E2E2E2E   
1387 2048656C   
LILBASIC        LilBasic (c)2002                                                                              PAGE 86

138B 70206F6E   
138F 20426173   
1393 69632066   
1397 756E6374   
139B 696F6E73   
139F 0D         
13A0 48454C50   =1  4853            DB      'HELP OPER .......... Help on Basic operators',CR
13A4 204F5045   
13A8 52202E2E   
13AC 2E2E2E2E   
13B0 2E2E2E2E   
13B4 2048656C   
13B8 70206F6E   
13BC 20426173   
13C0 6963206F   
13C4 70657261   
13C8 746F7273   
13CC 0D         
13CD 48454C50   =1  4854            DB      'HELP VARS .......... Help on Basic variables',CR
13D1 20564152   
13D5 53202E2E   
13D9 2E2E2E2E   
13DD 2E2E2E2E   
13E1 2048656C   
13E5 70206F6E   
13E9 20426173   
13ED 69632076   
13F1 61726961   
13F5 626C6573   
13F9 0D         
13FA 0D         =1  4855            DB      CR
13FB 0D         =1  4856            DB      CR
13FC 0000       =1  4857            DB      00H,00H
                =1  4858    
13FE            =1  4859    HELPTEXTCMD:
13FE 1B5B324A   =1  4860            DB      ESC,'[2J'       ;(CLS)
1402 204C696C   =1  4861            DB      ' Lil''Basic HELP (c)2002  -NQR',CR
1406 27426173   
140A 69632048   
140E 454C5020   
1412 28632932   
1416 30303220   
141A 202D4E51   
141E 520D       
1420 2D2D2D2D   =1  4862            DB      '-------------------------------------------------------------------',CR
1424 2D2D2D2D   
1428 2D2D2D2D   
142C 2D2D2D2D   
1430 2D2D2D2D   
1434 2D2D2D2D   
1438 2D2D2D2D   
143C 2D2D2D2D   
1440 2D2D2D2D   
1444 2D2D2D2D   
1448 2D2D2D2D   
144C 2D2D2D2D   
1450 2D2D2D2D   
1454 2D2D2D2D   
LILBASIC        LilBasic (c)2002                                                                              PAGE 87

1458 2D2D2D2D   
145C 2D2D2D2D   
1460 2D2D2D0D   
1464 0D         =1  4863            DB      CR
1465 42617369   =1  4864            DB      'Basic Commands',CR
1469 6320436F   
146D 6D6D616E   
1471 64730D     
1474 2D2D2D2D   =1  4865            DB      '--------------',CR
1478 2D2D2D2D   
147C 2D2D2D2D   
1480 2D2D0D     
1483 46494C45   =1  4866            DB      'FILES  ............. List files in memory',CR
1487 5320202E   
148B 2E2E2E2E   
148F 2E2E2E2E   
1493 2E2E2E2E   
1497 204C6973   
149B 74206669   
149F 6C657320   
14A3 696E206D   
14A7 656D6F72   
14AB 790D       
14AD 4C4F4144   =1  4867            DB      'LOAD  .............. Load a program',CR
14B1 20202E2E   
14B5 2E2E2E2E   
14B9 2E2E2E2E   
14BD 2E2E2E2E   
14C1 204C6F61   
14C5 64206120   
14C9 70726F67   
14CD 72616D0D   
14D1 53415645   =1  4868            DB      'SAVE ............... Save program ',CR
14D5 202E2E2E   
14D9 2E2E2E2E   
14DD 2E2E2E2E   
14E1 2E2E2E2E   
14E5 20536176   
14E9 65207072   
14ED 6F677261   
14F1 6D200D     
14F4 57495045   =1  4869            DB      'WIPEALL ............ Wipe All saved programs'
14F8 414C4C20   
14FC 2E2E2E2E   
1500 2E2E2E2E   
1504 2E2E2E2E   
1508 20576970   
150C 6520416C   
1510 6C207361   
1514 76656420   
1518 70726F67   
151C 72616D73   
1520 434C5320   =1  4870            DB      'CLS  ............... Send Escape code to clear the screen',CR
1524 202E2E2E   
1528 2E2E2E2E   
152C 2E2E2E2E   
1530 2E2E2E2E   
1534 2053656E   
LILBASIC        LilBasic (c)2002                                                                              PAGE 88

1538 64204573   
153C 63617065   
1540 20636F64   
1544 6520746F   
1548 20636C65   
154C 61722074   
1550 68652073   
1554 63726565   
1558 6E0D       
155A 4C455420   =1  4871            DB      'LET  ............... Assign value to a variable ',CR
155E 202E2E2E   
1562 2E2E2E2E   
1566 2E2E2E2E   
156A 2E2E2E2E   
156E 20417373   
1572 69676E20   
1576 76616C75   
157A 6520746F   
157E 20612076   
1582 61726961   
1586 626C6520   
158A 0D         
158B 474F544F   =1  4872            DB      'GOTO ............... Continue execution on new line of code',CR
158F 202E2E2E   
1593 2E2E2E2E   
1597 2E2E2E2E   
159B 2E2E2E2E   
159F 20436F6E   
15A3 74696E75   
15A7 65206578   
15AB 65637574   
15AF 696F6E20   
15B3 6F6E206E   
15B7 6577206C   
15BB 696E6520   
15BF 6F662063   
15C3 6F64650D   
15C7 474F5355   =1  4873            DB      'GOSUB  ............. Go to a subroutine',CR
15CB 4220202E   
15CF 2E2E2E2E   
15D3 2E2E2E2E   
15D7 2E2E2E2E   
15DB 20476F20   
15DF 746F2061   
15E3 20737562   
15E7 726F7574   
15EB 696E650D   
15EF 52455455   =1  4874            DB      'RETURN  ............ Return from a subroutine',CR
15F3 524E2020   
15F7 2E2E2E2E   
15FB 2E2E2E2E   
15FF 2E2E2E2E   
1603 20526574   
1607 75726E20   
160B 66726F6D   
160F 20612073   
1613 7562726F   
1617 7574696E   
LILBASIC        LilBasic (c)2002                                                                              PAGE 89

161B 650D       
161D 5052494E   =1  4875            DB      'PRINT or ? ......... Display information via. 232 port',CR
1621 54206F72   
1625 203F202E   
1629 2E2E2E2E   
162D 2E2E2E2E   
1631 20446973   
1635 706C6179   
1639 20696E66   
163D 6F726D61   
1641 74696F6E   
1645 20766961   
1649 2E203233   
164D 3220706F   
1651 72740D     
1654 49462028   =1  4876            DB      'IF () THEN  ........ Conditional branch',CR
1658 29205448   
165C 454E2020   
1660 2E2E2E2E   
1664 2E2E2E2E   
1668 20436F6E   
166C 64697469   
1670 6F6E616C   
1674 20627261   
1678 6E63680D   
167C 494E5055   =1  4877            DB      'INPUT  ............. Get a number from 232 port',CR
1680 5420202E   
1684 2E2E2E2E   
1688 2E2E2E2E   
168C 2E2E2E2E   
1690 20476574   
1694 2061206E   
1698 756D6265   
169C 72206672   
16A0 6F6D2032   
16A4 33322070   
16A8 6F72740D   
16AC 43414C4C   =1  4878            DB      'CALL  .............. Execute machine code',CR
16B0 20202E2E   
16B4 2E2E2E2E   
16B8 2E2E2E2E   
16BC 2E2E2E2E   
16C0 20457865   
16C4 63757465   
16C8 206D6163   
16CC 68696E65   
16D0 20636F64   
16D4 650D       
                =1  4879    ;        DB      'FOR / NEXT  ........ Conditional loop',CR
16D6 52454D20   =1  4880            DB      'REM  ............... Insert comments into program',CR
16DA 202E2E2E   
16DE 2E2E2E2E   
16E2 2E2E2E2E   
16E6 2E2E2E2E   
16EA 20496E73   
16EE 65727420   
16F2 636F6D6D   
16F6 656E7473   
LILBASIC        LilBasic (c)2002                                                                              PAGE 90

16FA 20696E74   
16FE 6F207072   
1702 6F677261   
1706 6D0D       
1708 454E4420   =1  4881            DB      'END  ............... Stop execution of program',CR
170C 202E2E2E   
1710 2E2E2E2E   
1714 2E2E2E2E   
1718 2E2E2E2E   
171C 2053746F   
1720 70206578   
1724 65637574   
1728 696F6E20   
172C 6F662070   
1730 726F6772   
1734 616D0D     
1737 4C495354   =1  4882            DB      'LIST  .............. Display program',CR
173B 20202E2E   
173F 2E2E2E2E   
1743 2E2E2E2E   
1747 2E2E2E2E   
174B 20446973   
174F 706C6179   
1753 2070726F   
1757 6772616D   
175B 0D         
175C 52554E20   =1  4883            DB      'RUN  ............... Execute program',CR
1760 202E2E2E   
1764 2E2E2E2E   
1768 2E2E2E2E   
176C 2E2E2E2E   
1770 20457865   
1774 63757465   
1778 2070726F   
177C 6772616D   
1780 0D         
1781 4E455720   =1  4884            DB      'NEW  ............... Erase program & variables',CR
1785 202E2E2E   
1789 2E2E2E2E   
178D 2E2E2E2E   
1791 2E2E2E2E   
1795 20457261   
1799 73652070   
179D 726F6772   
17A1 616D2026   
17A5 20766172   
17A9 6961626C   
17AD 65730D     
17B0 42524541   =1  4885            DB      'BREAK  ............. Restart CPU same as Reset button',CR
17B4 4B20202E   
17B8 2E2E2E2E   
17BC 2E2E2E2E   
17C0 2E2E2E2E   
17C4 20526573   
17C8 74617274   
17CC 20435055   
17D0 2073616D   
17D4 65206173   
LILBASIC        LilBasic (c)2002                                                                              PAGE 91

17D8 20526573   
17DC 65742062   
17E0 7574746F   
17E4 6E0D       
17E6 48455820   =1  4886            DB      'HEX  ............... Change to Base 16 for Input & Output',CR
17EA 202E2E2E   
17EE 2E2E2E2E   
17F2 2E2E2E2E   
17F6 2E2E2E2E   
17FA 20436861   
17FE 6E676520   
1802 746F2042   
1806 61736520   
180A 31362066   
180E 6F722049   
1812 6E707574   
1816 2026204F   
181A 75747075   
181E 740D       
1820 44454320   =1  4887            DB      'DEC  ............... Change to Base 10 for Input & Output',CR
1824 202E2E2E   
1828 2E2E2E2E   
182C 2E2E2E2E   
1830 2E2E2E2E   
1834 20436861   
1838 6E676520   
183C 746F2042   
1840 61736520   
1844 31302066   
1848 6F722049   
184C 6E707574   
1850 2026204F   
1854 75747075   
1858 740D       
185A 56455220   =1  4888            DB      'VER  ............... Display Lil''Basic version',CR
185E 202E2E2E   
1862 2E2E2E2E   
1866 2E2E2E2E   
186A 2E2E2E2E   
186E 20446973   
1872 706C6179   
1876 204C696C   
187A 27426173   
187E 69632076   
1882 65727369   
1886 6F6E0D     
1889 2E4C4F43   =1  4889            DB      '.LOCK  ............. Lock NVRAM (inhibit changes to saved files)',CR
188D 4B20202E   
1891 2E2E2E2E   
1895 2E2E2E2E   
1899 2E2E2E2E   
189D 204C6F63   
18A1 6B204E56   
18A5 52414D20   
18A9 28696E68   
18AD 69626974   
18B1 20636861   
18B5 6E676573   
LILBASIC        LilBasic (c)2002                                                                              PAGE 92

18B9 20746F20   
18BD 73617665   
18C1 64206669   
18C5 6C657329   
18C9 0D         
18CA 2E554E4C   =1  4890            DB      '.UNLOCK  ........... Unlock NVRAM (allow changes to saved files)',CR
18CE 4F434B20   
18D2 202E2E2E   
18D6 2E2E2E2E   
18DA 2E2E2E2E   
18DE 20556E6C   
18E2 6F636B20   
18E6 4E565241   
18EA 4D202861   
18EE 6C6C6F77   
18F2 20636861   
18F6 6E676573   
18FA 20746F20   
18FE 73617665   
1902 64206669   
1906 6C657329   
190A 0D         
190B 0D         =1  4891            DB      CR
190C 0000       =1  4892            DB      00H,00H
                =1  4893    
190E            =1  4894    HELPTEXTFUNC:
190E 1B5B324A   =1  4895            DB      ESC,'[2J'       ;(CLS)
1912 204C696C   =1  4896            DB      ' Lil''Basic HELP (c)2002  -NQR',CR
1916 27426173   
191A 69632048   
191E 454C5020   
1922 28632932   
1926 30303220   
192A 202D4E51   
192E 520D       
1930 2D2D2D2D   =1  4897            DB      '-------------------------------------------------------------------',CR
1934 2D2D2D2D   
1938 2D2D2D2D   
193C 2D2D2D2D   
1940 2D2D2D2D   
1944 2D2D2D2D   
1948 2D2D2D2D   
194C 2D2D2D2D   
1950 2D2D2D2D   
1954 2D2D2D2D   
1958 2D2D2D2D   
195C 2D2D2D2D   
1960 2D2D2D2D   
1964 2D2D2D2D   
1968 2D2D2D2D   
196C 2D2D2D2D   
1970 2D2D2D0D   
1974 0D         =1  4898            DB      CR
1975 42617369   =1  4899            DB      'Basic Functions',CR
1979 63204675   
197D 6E637469   
1981 6F6E730D   
1985 2D2D2D2D   =1  4900            DB      '---------------',CR
LILBASIC        LilBasic (c)2002                                                                              PAGE 93

1989 2D2D2D2D   
198D 2D2D2D2D   
1991 2D2D2D0D   
                =1  4901            ;DB      'RND()  ............. Returns a Random number from 1 to Number',CR
1995 41425328   =1  4902            DB      'ABS()  ............. Returns Absolute value of Number',CR
1999 2920202E   
199D 2E2E2E2E   
19A1 2E2E2E2E   
19A5 2E2E2E2E   
19A9 20526574   
19AD 75726E73   
19B1 20416273   
19B5 6F6C7574   
19B9 65207661   
19BD 6C756520   
19C1 6F66204E   
19C5 756D6265   
19C9 720D       
19CB 0D         =1  4903            DB      CR
19CC 0D         =1  4904            DB      CR
19CD 0000       =1  4905            DB      00H,00H
                =1  4906    
19CF            =1  4907    HELPTEXTOPER:
19CF 1B5B324A   =1  4908            DB      ESC,'[2J'       ;(CLS)
19D3 204C696C   =1  4909            DB      ' Lil''Basic HELP file   (c)2002  -NQR',CR
19D7 27426173   
19DB 69632048   
19DF 454C5020   
19E3 66696C65   
19E7 20202028   
19EB 63293230   
19EF 30322020   
19F3 2D4E5152   
19F7 0D         
19F8 2D2D2D2D   =1  4910            DB      '-------------------------------------------------------------------',CR
19FC 2D2D2D2D   
1A00 2D2D2D2D   
1A04 2D2D2D2D   
1A08 2D2D2D2D   
1A0C 2D2D2D2D   
1A10 2D2D2D2D   
1A14 2D2D2D2D   
1A18 2D2D2D2D   
1A1C 2D2D2D2D   
1A20 2D2D2D2D   
1A24 2D2D2D2D   
1A28 2D2D2D2D   
1A2C 2D2D2D2D   
1A30 2D2D2D2D   
1A34 2D2D2D2D   
1A38 2D2D2D0D   
1A3C 0D         =1  4911            DB      CR
1A3D 42617369   =1  4912            DB      'Basic Operators',CR
1A41 63204F70   
1A45 65726174   
1A49 6F72730D   
1A4D 2D2D2D2D   =1  4913            DB      '---------------',CR
1A51 2D2D2D2D   
LILBASIC        LilBasic (c)2002                                                                              PAGE 94

1A55 2D2D2D2D   
1A59 2D2D2D0D   
1A5D 2B20202E   =1  4914            DB      '+  ................  Addition',CR
1A61 2E2E2E2E   
1A65 2E2E2E2E   
1A69 2E2E2E2E   
1A6D 2E2E2E20   
1A71 20416464   
1A75 6974696F   
1A79 6E0D       
1A7B 2D20202E   =1  4915            DB      '-  ................  Subtraction',CR
1A7F 2E2E2E2E   
1A83 2E2E2E2E   
1A87 2E2E2E2E   
1A8B 2E2E2E20   
1A8F 20537562   
1A93 74726163   
1A97 74696F6E   
1A9B 0D         
1A9C 2A20202E   =1  4916            DB      '*  ................  Multiplication',CR
1AA0 2E2E2E2E   
1AA4 2E2E2E2E   
1AA8 2E2E2E2E   
1AAC 2E2E2E20   
1AB0 204D756C   
1AB4 7469706C   
1AB8 69636174   
1ABC 696F6E0D   
1AC0 2F20202E   =1  4917            DB      '/  ................  Division',CR
1AC4 2E2E2E2E   
1AC8 2E2E2E2E   
1ACC 2E2E2E2E   
1AD0 2E2E2E20   
1AD4 20446976   
1AD8 6973696F   
1ADC 6E0D       
1ADE 4D4F4420   =1  4918            DB      'MOD  ..............  Modules ( Remainder from division )',CR
1AE2 202E2E2E   
1AE6 2E2E2E2E   
1AEA 2E2E2E2E   
1AEE 2E2E2E20   
1AF2 204D6F64   
1AF6 756C6573   
1AFA 20282052   
1AFE 656D6169   
1B02 6E646572   
1B06 2066726F   
1B0A 6D206469   
1B0E 76697369   
1B12 6F6E2029   
1B16 0D         
1B17 3D20202E   =1  4919            DB      '=  ................  Compare if Equal',CR
1B1B 2E2E2E2E   
1B1F 2E2E2E2E   
1B23 2E2E2E2E   
1B27 2E2E2E20   
1B2B 20436F6D   
1B2F 70617265   
LILBASIC        LilBasic (c)2002                                                                              PAGE 95

1B33 20696620   
1B37 45717561   
1B3B 6C0D       
1B3D 3E20202E   =1  4920            DB      '>  ................  Compare if Greater than',CR
1B41 2E2E2E2E   
1B45 2E2E2E2E   
1B49 2E2E2E2E   
1B4D 2E2E2E20   
1B51 20436F6D   
1B55 70617265   
1B59 20696620   
1B5D 47726561   
1B61 74657220   
1B65 7468616E   
1B69 0D         
1B6A 3C20202E   =1  4921            DB      '<  ................  Compare if Less than',CR
1B6E 2E2E2E2E   
1B72 2E2E2E2E   
1B76 2E2E2E2E   
1B7A 2E2E2E20   
1B7E 20436F6D   
1B82 70617265   
1B86 20696620   
1B8A 4C657373   
1B8E 20746861   
1B92 6E0D       
1B94 3C3E2020   =1  4922            DB      '<>  ...............  Compare if Not Equal',CR
1B98 2E2E2E2E   
1B9C 2E2E2E2E   
1BA0 2E2E2E2E   
1BA4 2E2E2E20   
1BA8 20436F6D   
1BAC 70617265   
1BB0 20696620   
1BB4 4E6F7420   
1BB8 45717561   
1BBC 6C0D       
1BBE 3E3D2020   =1  4923            DB      '>=  ...............  Compair if Grater than or Equal',CR
1BC2 2E2E2E2E   
1BC6 2E2E2E2E   
1BCA 2E2E2E2E   
1BCE 2E2E2E20   
1BD2 20436F6D   
1BD6 70616972   
1BDA 20696620   
1BDE 47726174   
1BE2 65722074   
1BE6 68616E20   
1BEA 6F722045   
1BEE 7175616C   
1BF2 0D         
1BF3 3C3D2020   =1  4924            DB      '<=  ...............  Compair if Less than or Equal',CR
1BF7 2E2E2E2E   
1BFB 2E2E2E2E   
1BFF 2E2E2E2E   
1C03 2E2E2E20   
1C07 20436F6D   
1C0B 70616972   
LILBASIC        LilBasic (c)2002                                                                              PAGE 96

1C0F 20696620   
1C13 4C657373   
1C17 20746861   
1C1B 6E206F72   
1C1F 20457175   
1C23 616C0D     
1C26 4E4F5420   =1  4925            DB      'NOT  ..............  Bit-wise logical complement',CR
1C2A 202E2E2E   
1C2E 2E2E2E2E   
1C32 2E2E2E2E   
1C36 2E2E2E20   
1C3A 20426974   
1C3E 2D776973   
1C42 65206C6F   
1C46 67696361   
1C4A 6C20636F   
1C4E 6D706C65   
1C52 6D656E74   
1C56 0D         
1C57 414E4420   =1  4926            DB      'AND  ..............  Bit-wise logical AND',CR
1C5B 202E2E2E   
1C5F 2E2E2E2E   
1C63 2E2E2E2E   
1C67 2E2E2E20   
1C6B 20426974   
1C6F 2D776973   
1C73 65206C6F   
1C77 67696361   
1C7B 6C20414E   
1C7F 440D       
1C81 4F522020   =1  4927            DB      'OR  ...............  Bit-wise logical OR',CR
1C85 2E2E2E2E   
1C89 2E2E2E2E   
1C8D 2E2E2E2E   
1C91 2E2E2E20   
1C95 20426974   
1C99 2D776973   
1C9D 65206C6F   
1CA1 67696361   
1CA5 6C204F52   
1CA9 0D         
1CAA 584F5220   =1  4928            DB      'XOR  ..............  Bit-wise logical Exclusive OR',CR
1CAE 202E2E2E   
1CB2 2E2E2E2E   
1CB6 2E2E2E2E   
1CBA 2E2E2E20   
1CBE 20426974   
1CC2 2D776973   
1CC6 65206C6F   
1CCA 67696361   
1CCE 6C204578   
1CD2 636C7573   
1CD6 69766520   
1CDA 4F520D     
1CDD 0D         =1  4929            DB      CR
1CDE 0D         =1  4930            DB      CR
1CDF 0000       =1  4931            DB      00H,00H
                =1  4932    
LILBASIC        LilBasic (c)2002                                                                              PAGE 97

1CE1            =1  4933    HELPTEXTVARS:
1CE1 1B5B324A   =1  4934            DB      ESC,'[2J'       ;(CLS)
1CE5 204C696C   =1  4935            DB      ' Lil''Basic HELP file   (c)2002  -NQR',CR
1CE9 27426173   
1CED 69632048   
1CF1 454C5020   
1CF5 66696C65   
1CF9 20202028   
1CFD 63293230   
1D01 30322020   
1D05 2D4E5152   
1D09 0D         
1D0A 2D2D2D2D   =1  4936            DB      '-------------------------------------------------------------------',CR
1D0E 2D2D2D2D   
1D12 2D2D2D2D   
1D16 2D2D2D2D   
1D1A 2D2D2D2D   
1D1E 2D2D2D2D   
1D22 2D2D2D2D   
1D26 2D2D2D2D   
1D2A 2D2D2D2D   
1D2E 2D2D2D2D   
1D32 2D2D2D2D   
1D36 2D2D2D2D   
1D3A 2D2D2D2D   
1D3E 2D2D2D2D   
1D42 2D2D2D2D   
1D46 2D2D2D2D   
1D4A 2D2D2D0D   
1D4E 0D         =1  4937            DB      CR
1D4F 42617369   =1  4938            DB      'Basic Variables',CR
1D53 63205661   
1D57 72696162   
1D5B 6C65730D   
1D5F 2D2D2D2D   =1  4939            DB      '---------------',CR
1D63 2D2D2D2D   
1D67 2D2D2D2D   
1D6B 2D2D2D0D   
1D6F 4120746F   =1  4940            DB      'A to Z .............  Basic Program variables',CR
1D73 205A202E   
1D77 2E2E2E2E   
1D7B 2E2E2E2E   
1D7F 2E2E2E2E   
1D83 20204261   
1D87 73696320   
1D8B 50726F67   
1D8F 72616D20   
1D93 76617269   
1D97 61626C65   
1D9B 730D       
1D9D 504F5254   =1  4941            DB      'PORT  .............  8 bit user Port on PCB',CR
1DA1 20202E2E   
1DA5 2E2E2E2E   
1DA9 2E2E2E2E   
1DAD 2E2E2E20   
1DB1 20382062   
1DB5 69742075   
1DB9 73657220   
LILBASIC        LilBasic (c)2002                                                                              PAGE 98

1DBD 506F7274   
1DC1 206F6E20   
1DC5 5043420D   
1DC9 44425954   =1  4942            DB      'DBYTE()  ...........  On board CPU Memory location',CR
1DCD 45282920   
1DD1 202E2E2E   
1DD5 2E2E2E2E   
1DD9 2E2E2E2E   
1DDD 20204F6E   
1DE1 20626F61   
1DE5 72642043   
1DE9 5055204D   
1DED 656D6F72   
1DF1 79206C6F   
1DF5 63617469   
1DF9 6F6E0D     
1DFC 52424954   =1  4943            DB      'RBIT()  ............  On board CPU Bit location',CR
1E00 28292020   
1E04 2E2E2E2E   
1E08 2E2E2E2E   
1E0C 2E2E2E2E   
1E10 20204F6E   
1E14 20626F61   
1E18 72642043   
1E1C 50552042   
1E20 6974206C   
1E24 6F636174   
1E28 696F6E0D   
1E2C 58425954   =1  4944            DB      'XBYTE()  ...........  External Memory location',CR
1E30 45282920   
1E34 202E2E2E   
1E38 2E2E2E2E   
1E3C 2E2E2E2E   
1E40 20204578   
1E44 7465726E   
1E48 616C204D   
1E4C 656D6F72   
1E50 79206C6F   
1E54 63617469   
1E58 6F6E0D     
1E5B 43425954   =1  4945            DB      'CBYTE()  ...........  Code Memory location',CR
1E5F 45282920   
1E63 202E2E2E   
1E67 2E2E2E2E   
1E6B 2E2E2E2E   
1E6F 2020436F   
1E73 6465204D   
1E77 656D6F72   
1E7B 79206C6F   
1E7F 63617469   
1E83 6F6E0D     
                =1  4946         ;   DB      'PWM1() .............  Pulse With Modulation Pin 1 duration = (x)',CR
                =1  4947         ;   DB      'PWM2() .............  Pulse With Modulation Pin 2 duration = (x)',CR
                =1  4948         ;   DB      'PWM3() .............  Pulse With Modulation Pin 3 duration = (x)',CR
                =1  4949         ;   DB      'PWM4() .............  Pulse With Modulation Pin 4 duration = (x)',CR
                =1  4950         ;   DB      'PWM5() .............  Pulse With Modulation Pin 5 duration = (x)',CR
                =1  4951         ;   DB      'PWM6() .............  Pulse With Modulation Pin 6 duration = (x)',CR
                =1  4952         ;   DB      'PWM7() .............  Pulse With Modulation Pin 7 duration = (x)',CR
LILBASIC        LilBasic (c)2002                                                                              PAGE 99

                =1  4953         ;   DB      'PWM8() .............  Pulse With Modulation Pin 8 duration = (x)',CR
                =1  4954         ;   DB      'MASK  ..............  Mask for PWM pins used.  IE. 255 = all pins 0 = none
                                                                               ',CR
                =1  4955         ;   DB      'FREQ  ..............  FREQUENCY of PWM cycles  1= 36hz  75=50hz  100= 60hz
                                                                                ',CR
                =1  4956         ;   DB      '                                             165=100hz 180=120hz 255=200hz
                                                                                ',CR
1E86 0D         =1  4957            DB      CR
1E87 0D         =1  4958            DB      CR
1E88 0000       =1  4959            DB      00H,00H            ;End of Help File
                    4960    
                    4961    
                    4962    ;======================================================================================
                    4963    ;       Basic Programs stored in ROM
                    4964    ;======================================================================================
                    4965    
                    4966    
1E8A                4967    START_OF_PROGRAMS:
                    4968                                        ;PFILE = PROGRAM FILE
                    4969                                        ;DFILE = DATA FILE
                    4970    
                    4971    
                    4972    ;'PFILE 'DEMO'
                    4973    ;$INCLUDE(DEMOS\DEMO.ASM)
                    4974    ;PFILE 'WALK'
                    4975    ;$INCLUDE(DEMOS\walk.ASM)
                    4976    ;PFILE 'LED'
                    4977    ;$INCLUDE(DEMOS\LED.ASM)
                    4978 +1 PFILE 'HELLO'
1E8A 29EEF1F2       4979 +1         DB      029H,0EEH,0F1H,0F2H,'P','HELLO',00H
1E8E 5048454C   
1E92 4C4F00     
1E95                4981    DEMOPROG:                           ;Start of DEMO program buffer.
                =1  4982    $INCLUDE(DEMOS\HELLO.ASM)
                =1  4983                                 ;HELLO.BAS
                =1  4984                                 ;---------
1E95 000A       =1  4985    DW      10 
1E97 3F226865   =1  4986    DB     '?"hello  ";' ,0DH
1E9B 6C6C6F20   
1E9F 20223B0D   
1EA3 0014       =1  4987    DW      20 
1EA5 676F746F   =1  4988    DB     'goto 10' ,0DH
1EA9 2031300D   
1EAD 80         =1  4989    DB 80H
  0019          =1  4990    HELLO_LEN EQU  25 
                    4991    
                    4992    END                                 ;END of code

VERSION 1.2h ASSEMBLY COMPLETE, 0 ERRORS FOUND
LILBASIC        LilBasic (c)2002                                                                              PAGE 100

ACC. . . . . . . . . . . . . . .  D ADDR  00E0H  PREDEFINED  
ADD_16 . . . . . . . . . . . . .  C ADDR  03F6H  
ADR_ER . . . . . . . . . . . . .  C ADDR  029DH  
AESLEN . . . . . . . . . . . . .    NUMB  00FFH  NOT USED  
AESP . . . . . . . . . . . . . .  D ADDR  001DH  
AESRAM . . . . . . . . . . . . .    NUMB  0000H  NOT USED  
AES_ER . . . . . . . . . . . . .  C ADDR  1017H  
ALPHAB . . . . . . . . . . . . .  C ADDR  0663H  
APND_1 . . . . . . . . . . . . .  C ADDR  03BAH  
APND_2 . . . . . . . . . . . . .  C ADDR  03DEH  
APND_4 . . . . . . . . . . . . .  C ADDR  03B8H  
APN_ER . . . . . . . . . . . . .  C ADDR  03E0H  
APOSTRO. . . . . . . . . . . . .  C ADDR  0C96H  NOT USED  
APPEND . . . . . . . . . . . . .  C ADDR  039DH  
ARUN . . . . . . . . . . . . . .  C ADDR  0AB3H  
AR_EXP . . . . . . . . . . . . .  C ADDR  1074H  
ASCTBL . . . . . . . . . . . . .  C ADDR  016BH  
AUTO . . . . . . . . . . . . . .  B ADDR  0051H  
AUTORUN. . . . . . . . . . . . .  C ADDR  00D6H  
B. . . . . . . . . . . . . . . .  D ADDR  00F0H  PREDEFINED  
BASCMD . . . . . . . . . . . . .  C ADDR  0ADBH  
BEL. . . . . . . . . . . . . . .    NUMB  0007H  
BIG_PROBLEM. . . . . . . . . . .  C ADDR  0549H  NOT USED  
BREAK_END. . . . . . . . . . . .  C ADDR  0C2CH  
BREAK_START. . . . . . . . . . .  C ADDR  0C1CH  NOT USED  
BS . . . . . . . . . . . . . . .    NUMB  0008H  
CALL_END . . . . . . . . . . . .  C ADDR  0BD4H  
CALL_START . . . . . . . . . . .  C ADDR  0BBEH  NOT USED  
CHAR . . . . . . . . . . . . . .    REG4         
CHAR_FLG . . . . . . . . . . . .  B ADDR  0059H  
CLEAR. . . . . . . . . . . . . .  C ADDR  0F85H  
CLS_END. . . . . . . . . . . . .  C ADDR  0CB6H  
CLS_START. . . . . . . . . . . .  C ADDR  0CA1H  NOT USED  
CMD_NG . . . . . . . . . . . . .  C ADDR  0AD8H  
CMPR . . . . . . . . . . . . . .  C ADDR  0554H  
CMPR_1 . . . . . . . . . . . . .  C ADDR  057EH  
CMPR_2 . . . . . . . . . . . . .  C ADDR  0584H  
CMPR_4 . . . . . . . . . . . . .  C ADDR  0575H  
CNTRET . . . . . . . . . . . . .  C ADDR  0154H  
CNTRL. . . . . . . . . . . . . .  C ADDR  0147H  
CNTR_2 . . . . . . . . . . . . .  C ADDR  014FH  
COND . . . . . . . . . . . . . .  C ADDR  0A3CH  
CONT . . . . . . . . . . . . . .  C ADDR  0A82H  
CONT_1 . . . . . . . . . . . . .  C ADDR  0AA5H  
COUT_1 . . . . . . . . . . . . .  C ADDR  0146H  
COUT_2 . . . . . . . . . . . . .  C ADDR  013EH  
COUT_3 . . . . . . . . . . . . .  C ADDR  0142H  
CR . . . . . . . . . . . . . . .    NUMB  000DH  
CREATE . . . . . . . . . . . . .  C ADDR  0390H  
CREA_1 . . . . . . . . . . . . .  C ADDR  039CH  
CTRL_R . . . . . . . . . . . . .    NUMB  0012H  
CURS_H . . . . . . . . . . . . .  D ADDR  0016H  
CURS_L . . . . . . . . . . . . .  D ADDR  0015H  
C_IN . . . . . . . . . . . . . .  C ADDR  0119H  
C_IN_END . . . . . . . . . . . .  C ADDR  0127H  
C_OUT. . . . . . . . . . . . . .  C ADDR  012AH  
C_SAVE . . . . . . . . . . . . .  D ADDR  0017H  
DD006. . . . . . . . . . . . . .  C ADDR  012AH  NOT USED  
LILBASIC        LilBasic (c)2002                                                                              PAGE 101

DD007. . . . . . . . . . . . . .  C ADDR  012DH  NOT USED  
DD008. . . . . . . . . . . . . .  C ADDR  0134H  NOT USED  
DD009. . . . . . . . . . . . . .  C ADDR  0137H  NOT USED  
DECIMAL. . . . . . . . . . . . .  C ADDR  0C7AH  
DEL. . . . . . . . . . . . . . .    NUMB  007FH  
DEMOPROG . . . . . . . . . . . .  C ADDR  1E95H  
DEST_H . . . . . . . . . . . . .    REG3         
DEST_L . . . . . . . . . . . . .    REG1         
DIV_1. . . . . . . . . . . . . .  C ADDR  051CH  
DIV_2. . . . . . . . . . . . . .  C ADDR  0527H  
DIV_LP . . . . . . . . . . . . .  C ADDR  04E9H  
DIV_NG . . . . . . . . . . . . .  C ADDR  052AH  
DIV_RP . . . . . . . . . . . . .  C ADDR  0500H  
DONE . . . . . . . . . . . . . .  C ADDR  07EAH  
DONE_1 . . . . . . . . . . . . .  C ADDR  07F2H  
DONE_2 . . . . . . . . . . . . .  C ADDR  07F6H  
DPH. . . . . . . . . . . . . . .  D ADDR  0083H  PREDEFINED  
DPL. . . . . . . . . . . . . . .  D ADDR  0082H  PREDEFINED  
DUP. . . . . . . . . . . . . . .  C ADDR  01F6H  NOT USED  
D_BLNK . . . . . . . . . . . . .  C ADDR  060FH  
E0 . . . . . . . . . . . . . . .  C ADDR  1067H  
E1 . . . . . . . . . . . . . . .  C ADDR  1077H  
E2 . . . . . . . . . . . . . . .  C ADDR  1085H  
E3 . . . . . . . . . . . . . . .  C ADDR  1093H  
E4 . . . . . . . . . . . . . . .  C ADDR  10A2H  
E5 . . . . . . . . . . . . . . .  C ADDR  10B2H  
EA . . . . . . . . . . . . . . .  B ADDR  00AFH  PREDEFINED  
ELN_H. . . . . . . . . . . . . .  D ADDR  001CH  
ELN_L. . . . . . . . . . . . . .  D ADDR  001BH  
ENDCLEAR . . . . . . . . . . . .  C ADDR  0F47H  
ENDLET . . . . . . . . . . . . .  C ADDR  0AF6H  
ENDLOCK. . . . . . . . . . . . .  C ADDR  0F34H  
ENDUNLOCK. . . . . . . . . . . .  C ADDR  0F22H  
END_END. . . . . . . . . . . . .  C ADDR  0BE1H  
END_START. . . . . . . . . . . .  C ADDR  0BD4H  NOT USED  
ERRENT . . . . . . . . . . . . .  C ADDR  0A7AH  
ERROR. . . . . . . . . . . . . .  D ADDR  001AH  
ERROR_NP . . . . . . . . . . . .  C ADDR  0FCCH  
ERROR_PR . . . . . . . . . . . .  C ADDR  0FCEH  
ERROUT . . . . . . . . . . . . .  C ADDR  0FBEH  
ESC. . . . . . . . . . . . . . .    NUMB  001BH  
ET0. . . . . . . . . . . . . . .  B ADDR  00A9H  PREDEFINED  
EXPR . . . . . . . . . . . . . .  C ADDR  1064H  
EXP_ER . . . . . . . . . . . . .  C ADDR  0FF7H  
EXP_OV . . . . . . . . . . . . .  C ADDR  03EBH  
EXTRAM . . . . . . . . . . . . .    NUMB  2000H  
FACT . . . . . . . . . . . . . .  C ADDR  10F3H  
FACT_1 . . . . . . . . . . . . .  C ADDR  1100H  
FETBDN . . . . . . . . . . . . .  C ADDR  038BH  
FETCBY . . . . . . . . . . . . .  C ADDR  0385H  
FETCH. . . . . . . . . . . . . .  C ADDR  0339H  
FETDBY . . . . . . . . . . . . .  C ADDR  036CH  
FETDIR . . . . . . . . . . . . .  C ADDR  02AEH  
FETERR . . . . . . . . . . . . .  C ADDR  036AH  NOT USED  
FETJTB . . . . . . . . . . . . .  C ADDR  034DH  
FETRBI . . . . . . . . . . . . .  C ADDR  0372H  
FETSFR . . . . . . . . . . . . .  C ADDR  02B4H  
FETVAR . . . . . . . . . . . . .  C ADDR  0352H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 102

FETXBY . . . . . . . . . . . . .  C ADDR  037EH  
FET_0. . . . . . . . . . . . . .  C ADDR  033BH  
FET_1. . . . . . . . . . . . . .  C ADDR  0348H  
FILES_END. . . . . . . . . . . .  C ADDR  0E38H  
FILES_EXIT . . . . . . . . . . .  C ADDR  0E1CH  
FILES_LOOK . . . . . . . . . . .  C ADDR  0DEDH  
FILES_START. . . . . . . . . . .  C ADDR  0DB6H  NOT USED  
FILE_END . . . . . . . . . . . .  C ADDR  0C6BH  
FILE_ERROR . . . . . . . . . . .  C ADDR  0C68H  
FILE_START . . . . . . . . . . .  C ADDR  0C2CH  NOT USED  
FIN. . . . . . . . . . . . . . .  C ADDR  0A5BH  
FIND_COMP_C. . . . . . . . . . .  C ADDR  11E3H  
FIND_CONT. . . . . . . . . . . .  C ADDR  11F4H  NOT USED  
FIND_FILE. . . . . . . . . . . .  C ADDR  11C8H  
FIND_LOOP. . . . . . . . . . . .  C ADDR  11D4H  
FIND_NEXT_TAG. . . . . . . . . .  C ADDR  119EH  
FIND_NO_FILE . . . . . . . . . .  C ADDR  11F9H  
FLAGS. . . . . . . . . . . . . .  D ADDR  002BH  
FNDDON . . . . . . . . . . . . .  C ADDR  099AH  
FNDLBL . . . . . . . . . . . . .  C ADDR  0978H  
FND_1. . . . . . . . . . . . . .  C ADDR  0980H  
FOUND_FILE . . . . . . . . . . .  C ADDR  11FBH  
FULLLIST . . . . . . . . . . . .  C ADDR  0BF8H  
GETLN. . . . . . . . . . . . . .  C ADDR  082EH  
GETL_0 . . . . . . . . . . . . .  C ADDR  0834H  
GETL_1 . . . . . . . . . . . . .  C ADDR  083CH  
GETL_2 . . . . . . . . . . . . .  C ADDR  0884H  
GETL_3 . . . . . . . . . . . . .  C ADDR  087BH  
GETL_4 . . . . . . . . . . . . .  C ADDR  0872H  
GETL_5 . . . . . . . . . . . . .  C ADDR  085BH  
GETL_6 . . . . . . . . . . . . .  C ADDR  084CH  
GETL_7 . . . . . . . . . . . . .  C ADDR  0865H  
GETROM . . . . . . . . . . . . .  C ADDR  05D4H  
GET_BUF. . . . . . . . . . . . .  C ADDR  05C3H  
GET_C. . . . . . . . . . . . . .  C ADDR  05BBH  
GET_XTOP . . . . . . . . . . . .  C ADDR  12AFH  
GOSUB_ST . . . . . . . . . . . .  C ADDR  0AFDH  NOT USED  
GOTO_ST. . . . . . . . . . . . .  C ADDR  0B0AH  
GO_COMMON. . . . . . . . . . . .  C ADDR  0B11H  
GO_END . . . . . . . . . . . . .  C ADDR  0B1CH  
GO_ERR . . . . . . . . . . . . .  C ADDR  0B19H  
GO_ST. . . . . . . . . . . . . .  C ADDR  0AF6H  NOT USED  
HELLO_LEN. . . . . . . . . . . .    NUMB  0019H  NOT USED  
HELPTEXT . . . . . . . . . . . .  C ADDR  12BCH  
HELPTEXTCMD. . . . . . . . . . .  C ADDR  13FEH  
HELPTEXTFUNC . . . . . . . . . .  C ADDR  190EH  
HELPTEXTOPER . . . . . . . . . .  C ADDR  19CFH  
HELPTEXTVARS . . . . . . . . . .  C ADDR  1CE1H  
HELP_0 . . . . . . . . . . . . .  C ADDR  0D3CH  
HELP_1 . . . . . . . . . . . . .  C ADDR  0CB6H  NOT USED  
HELP_2 . . . . . . . . . . . . .  C ADDR  0CD6H  
HELP_3 . . . . . . . . . . . . .  C ADDR  0CEAH  
HELP_4 . . . . . . . . . . . . .  C ADDR  0CFEH  
HELP_5 . . . . . . . . . . . . .  C ADDR  0D11H  NOT USED  
HELP_END . . . . . . . . . . . .  C ADDR  0D47H  
HELP_START . . . . . . . . . . .  C ADDR  0CB6H  NOT USED  
HEXDECIMAL . . . . . . . . . . .  C ADDR  0C6BH  NOT USED  
HEXDEC_END . . . . . . . . . . .  C ADDR  0C89H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 103

HEXMOD . . . . . . . . . . . . .  B ADDR  0054H  
HEXOUT . . . . . . . . . . . . .  C ADDR  017BH  
H_FLG. . . . . . . . . . . . . .  B ADDR  005DH  
IABS . . . . . . . . . . . . . .  C ADDR  0437H  
IADD . . . . . . . . . . . . . .  C ADDR  03EFH  
IAND . . . . . . . . . . . . . .  C ADDR  0410H  
ICPL . . . . . . . . . . . . . .  C ADDR  0448H  
IDIV . . . . . . . . . . . . . .  C ADDR  04C0H  
IDIV_0 . . . . . . . . . . . . .  C ADDR  04C2H  
IFDN_1 . . . . . . . . . . . . .  C ADDR  0801H  
IFDN_2 . . . . . . . . . . . . .  C ADDR  0805H  
IFDONE . . . . . . . . . . . . .  C ADDR  07FBH  
IFEXIT . . . . . . . . . . . . .  C ADDR  0B7CH  
IFST . . . . . . . . . . . . . .  C ADDR  0B5EH  NOT USED  
IF_FALSE . . . . . . . . . . . .  C ADDR  0B77H  
IF_TF. . . . . . . . . . . . . .  C ADDR  0B71H  
IINC . . . . . . . . . . . . . .  C ADDR  0465H  
IINC_1 . . . . . . . . . . . . .  C ADDR  0475H  
IMOD . . . . . . . . . . . . . .  C ADDR  04BCH  
IMPLEXT. . . . . . . . . . . . .  C ADDR  0ADBH  
IMPLST . . . . . . . . . . . . .  C ADDR  0AC7H  NOT USED  
IMUL . . . . . . . . . . . . . .  C ADDR  04ADH  
IMUL_ERR . . . . . . . . . . . .  C ADDR  0483H  
IMUL_MUL . . . . . . . . . . . .  C ADDR  0490H  
IMUL_SWAP. . . . . . . . . . . .  C ADDR  0486H  
INDEX. . . . . . . . . . . . . .  C ADDR  07A6H  
INDTBL . . . . . . . . . . . . .  C ADDR  0260H  
INIT . . . . . . . . . . . . . .  C ADDR  0951H  NOT USED  
INIT_LOOP_1. . . . . . . . . . .  C ADDR  095CH  
INNUM. . . . . . . . . . . . . .  C ADDR  0913H  
INPEXIT. . . . . . . . . . . . .  C ADDR  0BAEH  
INPUTST. . . . . . . . . . . . .  C ADDR  0B7CH  NOT USED  
INPUT_COMMA. . . . . . . . . . .  C ADDR  0B9BH  NOT USED  
INPUT_END. . . . . . . . . . . .  C ADDR  0BA9H  
INPUT_ERR. . . . . . . . . . . .  C ADDR  0BA6H  
INPUT_LOOP . . . . . . . . . . .  C ADDR  0B86H  
INPUT_SEMI . . . . . . . . . . .  C ADDR  0B95H  
INSL_1 . . . . . . . . . . . . .  C ADDR  0A10H  
INSRT. . . . . . . . . . . . . .  C ADDR  0A19H  
INSR_1 . . . . . . . . . . . . .  C ADDR  0A22H  
INSR_2 . . . . . . . . . . . . .  C ADDR  0A25H  
INSR_4 . . . . . . . . . . . . .  C ADDR  0A39H  
INSR_L . . . . . . . . . . . . .  C ADDR  09FFH  
INUM_0 . . . . . . . . . . . . .  C ADDR  091AH  
INUM_1 . . . . . . . . . . . . .  C ADDR  0936H  
INUM_2 . . . . . . . . . . . . .  C ADDR  093FH  
INUM_3 . . . . . . . . . . . . .  C ADDR  0925H  
INUM_4 . . . . . . . . . . . . .  C ADDR  092AH  
INUM_5 . . . . . . . . . . . . .  C ADDR  0931H  
INUM_6 . . . . . . . . . . . . .  C ADDR  0946H  
IOR. . . . . . . . . . . . . . .  C ADDR  041DH  
ISALPHA. . . . . . . . . . . . .  C ADDR  00F2H  
ISALPHANUM . . . . . . . . . . .  C ADDR  00E6H  
ISALPHANUM_NO. . . . . . . . . .  C ADDR  010AH  
ISALPHANUM_YES . . . . . . . . .  C ADDR  0108H  
ISLOWER. . . . . . . . . . . . .  C ADDR  00FEH  
ISUB . . . . . . . . . . . . . .  C ADDR  0401H  
IS_TAG . . . . . . . . . . . . .  C ADDR  11ACH  
LILBASIC        LilBasic (c)2002                                                                              PAGE 104

IXOR . . . . . . . . . . . . . .  C ADDR  042AH  
JMP2_HELP_END. . . . . . . . . .  C ADDR  0CD3H  
KILL_2 . . . . . . . . . . . . .  C ADDR  09A4H  
KILL_3 . . . . . . . . . . . . .  C ADDR  09B3H  
KILL_9 . . . . . . . . . . . . .  C ADDR  09BEH  
KILL_L . . . . . . . . . . . . .  C ADDR  099DH  
LABL_H . . . . . . . . . . . . .  D ADDR  0019H  
LABL_L . . . . . . . . . . . . .  D ADDR  0018H  
LF . . . . . . . . . . . . . . .    NUMB  000AH  
LINI_1 . . . . . . . . . . . . .  C ADDR  081DH  
LISTEND. . . . . . . . . . . . .  C ADDR  0BFCH  
LISTSTART. . . . . . . . . . . .  C ADDR  0BE1H  NOT USED  
LIT. . . . . . . . . . . . . . .  C ADDR  0210H  
LIT_1. . . . . . . . . . . . . .  C ADDR  0223H  
LNDONE . . . . . . . . . . . . .  C ADDR  07F0H  
LOAD_BADFN . . . . . . . . . . .  C ADDR  0E64H  
LOAD_CARY. . . . . . . . . . . .  C ADDR  0E46H  
LOAD_END . . . . . . . . . . . .  C ADDR  0E7BH  
LOAD_EXIT. . . . . . . . . . . .  C ADDR  0E60H  NOT USED  
LOAD_PNTR. . . . . . . . . . . .  C ADDR  05B4H  
LOAD_START . . . . . . . . . . .  C ADDR  0E38H  NOT USED  
LOCK . . . . . . . . . . . . . .  C ADDR  0F6CH  
LP_CNT . . . . . . . . . . . . .    REG5         
LST. . . . . . . . . . . . . . .  C ADDR  0902H  
LSTLIN . . . . . . . . . . . . .  C ADDR  08E8H  
LSTL_1 . . . . . . . . . . . . .  C ADDR  0901H  
LSTL_2 . . . . . . . . . . . . .  C ADDR  08F8H  
LSTRET . . . . . . . . . . . . .  C ADDR  0910H  
LST_1. . . . . . . . . . . . . .  C ADDR  0907H  
L_CURS . . . . . . . . . . . . .  D ADDR  0013H  
L_INIT . . . . . . . . . . . . .  C ADDR  0818H  
MLCALL . . . . . . . . . . . . .  C ADDR  0A60H  
MODE . . . . . . . . . . . . . .  D ADDR  002AH  
MOD_FLG. . . . . . . . . . . . .  B ADDR  005CH  
MOVE_CONT. . . . . . . . . . . .  C ADDR  120BH  
MOVE_CONT_2. . . . . . . . . . .  C ADDR  1229H  
MOVE_P . . . . . . . . . . . . .  C ADDR  11FDH  
MOVE_ROM . . . . . . . . . . . .  C ADDR  1209H  
MOVE_XRAM. . . . . . . . . . . .  C ADDR  1206H  NOT USED  
MSKTBL . . . . . . . . . . . . .  C ADDR  02CEH  
MSK_PC . . . . . . . . . . . . .  C ADDR  02CBH  
MUL_16 . . . . . . . . . . . . .  C ADDR  0476H  
NEG. . . . . . . . . . . . . . .  C ADDR  044BH  
NEG_0. . . . . . . . . . . . . .  C ADDR  044EH  
NEG_IF_NEG . . . . . . . . . . .  C ADDR  0444H  
NEWEND . . . . . . . . . . . . .  C ADDR  0C1CH  
NEWSTART . . . . . . . . . . . .  C ADDR  0C06H  NOT USED  
NIBOUT . . . . . . . . . . . . .  C ADDR  015CH  
NIBO_1 . . . . . . . . . . . . .  C ADDR  0167H  
NIBO_2 . . . . . . . . . . . . .  C ADDR  0163H  
NIBO_3 . . . . . . . . . . . . .  C ADDR  016AH  
NLINE. . . . . . . . . . . . . .  C ADDR  0128H  
NL_NXT . . . . . . . . . . . . .  C ADDR  081FH  
NOTSYM . . . . . . . . . . . . .  C ADDR  07A4H  NOT USED  
NOTVAR . . . . . . . . . . . . .  C ADDR  0672H  
NOT_TAG. . . . . . . . . . . . .  C ADDR  11C6H  
NO_PROBLEM . . . . . . . . . . .  C ADDR  054DH  
NO_SFR . . . . . . . . . . . . .    NUMB  000EH  
LILBASIC        LilBasic (c)2002                                                                              PAGE 105

NXT. . . . . . . . . . . . . . .  C ADDR  0822H  
NXT_1. . . . . . . . . . . . . .  C ADDR  082BH  
OPEN_1 . . . . . . . . . . . . .  C ADDR  09E4H  
OPEN_2 . . . . . . . . . . . . .  C ADDR  09F3H  
OPEN_3 . . . . . . . . . . . . .  C ADDR  09C4H  
OPEN_4 . . . . . . . . . . . . .  C ADDR  09D5H  
OPEN_5 . . . . . . . . . . . . .  C ADDR  09CDH  
OPEN_6 . . . . . . . . . . . . .  C ADDR  09F8H  
OPEN_L . . . . . . . . . . . . .  C ADDR  09BFH  
OV . . . . . . . . . . . . . . .  B ADDR  00D2H  PREDEFINED  
OV_ER. . . . . . . . . . . . . .  C ADDR  1048H  
OV_TST . . . . . . . . . . . . .  C ADDR  03E4H  
P0 . . . . . . . . . . . . . . .  D ADDR  0080H  PREDEFINED  
P2 . . . . . . . . . . . . . . .  D ADDR  00A0H  PREDEFINED  
PNTR_H . . . . . . . . . . . . .    REG2         
PNTR_L . . . . . . . . . . . . .    REG0         
POP_ACC. . . . . . . . . . . . .  C ADDR  01D6H  
POP_TOS. . . . . . . . . . . . .  C ADDR  01C1H  
PORT1. . . . . . . . . . . . . .  C ADDR  0676H  NOT USED  
PORT1_END. . . . . . . . . . . .  C ADDR  0689H  
PRINT_CHECK_SEMI . . . . . . . .  C ADDR  0B53H  
PRINT_COMMA. . . . . . . . . . .  C ADDR  0B50H  
PRINT_END. . . . . . . . . . . .  C ADDR  0B5AH  
PRINT_EXIT . . . . . . . . . . .  C ADDR  0B5EH  
PRINT_LOOP . . . . . . . . . . .  C ADDR  0B2EH  
PRINT_SEMI . . . . . . . . . . .  C ADDR  0B5CH  
PRINT_START. . . . . . . . . . .  C ADDR  0B1CH  NOT USED  
PRN. . . . . . . . . . . . . . .  C ADDR  0894H  
PRNHEX . . . . . . . . . . . . .  C ADDR  08C4H  
PRNH_1 . . . . . . . . . . . . .  C ADDR  08D5H  
PRNRET . . . . . . . . . . . . .  C ADDR  08E7H  
PRNTOS . . . . . . . . . . . . .  C ADDR  089CH  
PRN_1. . . . . . . . . . . . . .  C ADDR  08ADH  
PRT_MSK. . . . . . . . . . . . .  D ADDR  0028H  
PSW. . . . . . . . . . . . . . .  D ADDR  00D0H  PREDEFINED  
PUSH_C . . . . . . . . . . . . .  C ADDR  0586H  
PUSH_TOS . . . . . . . . . . . .  C ADDR  01DFH  
PUTROM . . . . . . . . . . . . .  C ADDR  0604H  
PUT_BUF. . . . . . . . . . . . .  C ADDR  05F3H  
PWM0 . . . . . . . . . . . . . .  D ADDR  0020H  
PWM1 . . . . . . . . . . . . . .  D ADDR  0021H  
PWM2 . . . . . . . . . . . . . .  D ADDR  0022H  
PWM3 . . . . . . . . . . . . . .  D ADDR  0023H  
PWM4 . . . . . . . . . . . . . .  D ADDR  0024H  
PWM5 . . . . . . . . . . . . . .  D ADDR  0025H  
PWM6 . . . . . . . . . . . . . .  D ADDR  0026H  
PWM7 . . . . . . . . . . . . . .  D ADDR  0027H  
PWM_E0 . . . . . . . . . . . . .  B ADDR  0040H  NOT USED  
PWM_E1 . . . . . . . . . . . . .  B ADDR  0041H  NOT USED  
PWM_E2 . . . . . . . . . . . . .  B ADDR  0042H  NOT USED  
PWM_E3 . . . . . . . . . . . . .  B ADDR  0043H  NOT USED  
PWM_E4 . . . . . . . . . . . . .  B ADDR  0044H  NOT USED  
PWM_E5 . . . . . . . . . . . . .  B ADDR  0045H  NOT USED  
PWM_E6 . . . . . . . . . . . . .  B ADDR  0046H  NOT USED  
PWM_E7 . . . . . . . . . . . . .  B ADDR  0047H  NOT USED  
RAMLIM . . . . . . . . . . . . .    NUMB  7FFFH  
RAMROM . . . . . . . . . . . . .  B ADDR  005EH  
RAM_INIT . . . . . . . . . . . .  C ADDR  0954H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 106

RAM_PROGRAM. . . . . . . . . . .  C ADDR  0C59H  
RDCHDN . . . . . . . . . . . . .  C ADDR  05F0H  
READ_CHAR. . . . . . . . . . . .  C ADDR  05E5H  
READ_LABEL . . . . . . . . . . .  C ADDR  0809H  
RELOP. . . . . . . . . . . . . .  C ADDR  1157H  
REL_1. . . . . . . . . . . . . .  C ADDR  1162H  
REL_2. . . . . . . . . . . . . .  C ADDR  116EH  
REL_3. . . . . . . . . . . . . .  C ADDR  117AH  
REL_4. . . . . . . . . . . . . .  C ADDR  1185H  
REL_5. . . . . . . . . . . . . .  C ADDR  1191H  
REL_6. . . . . . . . . . . . . .  C ADDR  119CH  
REMARK_END . . . . . . . . . . .  C ADDR  0CA1H  
REMARK_START . . . . . . . . . .  C ADDR  0C89H  NOT USED  
REREAD . . . . . . . . . . . . .  C ADDR  05F1H  
RETURN_END . . . . . . . . . . .  C ADDR  0BBEH  
RETURN_START . . . . . . . . . .  C ADDR  0BAEH  NOT USED  
REWIND . . . . . . . . . . . . .  C ADDR  058FH  
REWIND_FIND_FILE . . . . . . . .  C ADDR  05A4H  
REWROM . . . . . . . . . . . . .  C ADDR  0599H  
RI . . . . . . . . . . . . . . .  B ADDR  0098H  PREDEFINED  
RND. . . . . . . . . . . . . . .  C ADDR  052CH  
ROM_PROGRAM. . . . . . . . . . .  C ADDR  0C35H  NOT USED  
RSTR . . . . . . . . . . . . . .  C ADDR  0A53H  
RUNEND . . . . . . . . . . . . .  C ADDR  0C06H  
RUNMOD . . . . . . . . . . . . .  B ADDR  0053H  
RUNSTART . . . . . . . . . . . .  C ADDR  0BFCH  NOT USED  
RWXROM . . . . . . . . . . . . .  C ADDR  05A1H  
S8 . . . . . . . . . . . . . . .  C ADDR  0B5EH  NOT USED  
SAV. . . . . . . . . . . . . . .  C ADDR  0A4CH  
SAVE_BADFN . . . . . . . . . . .  C ADDR  0EB0H  NOT USED  
SAVE_CARY. . . . . . . . . . . .  C ADDR  0E89H  
SAVE_END . . . . . . . . . . . .  C ADDR  0ECFH  
SAVE_EXIT. . . . . . . . . . . .  C ADDR  0EAEH  NOT USED  
SAVE_PNTR. . . . . . . . . . . .  C ADDR  05ADH  
SAVE_START . . . . . . . . . . .  C ADDR  0E7BH  NOT USED  
SAVE_XTOP. . . . . . . . . . . .  C ADDR  1295H  
SBUF . . . . . . . . . . . . . .  D ADDR  0099H  PREDEFINED  
SCON . . . . . . . . . . . . . .  D ADDR  0098H  PREDEFINED  
SEED_H . . . . . . . . . . . . .  D ADDR  0011H  
SEED_L . . . . . . . . . . . . .  D ADDR  0010H  
SEQ_FETCH. . . . . . . . . . . .  C ADDR  0335H  NOT USED  
SEQ_FLG. . . . . . . . . . . . .  B ADDR  005BH  
SEQ_STORE. . . . . . . . . . . .  C ADDR  02D6H  NOT USED  
SETRBI . . . . . . . . . . . . .  C ADDR  0328H  
SET_TAG. . . . . . . . . . . . .  C ADDR  1237H  
SET_TAG_EOFN . . . . . . . . . .  C ADDR  1289H  NOT USED  
SET_TAG_JMP. . . . . . . . . . .  C ADDR  1273H  
SET_TAG_LOOP . . . . . . . . . .  C ADDR  1274H  
SFID_1 . . . . . . . . . . . . .  C ADDR  028FH  
SFID_2 . . . . . . . . . . . . .  C ADDR  0298H  
SFRTBL . . . . . . . . . . . . .  C ADDR  0228H  
SFR_ID . . . . . . . . . . . . .  C ADDR  028AH  
SGN_FLG. . . . . . . . . . . . .  B ADDR  005AH  
SKPLIN . . . . . . . . . . . . .  C ADDR  0619H  
SKPTXT . . . . . . . . . . . . .  C ADDR  061DH  
SP . . . . . . . . . . . . . . .  D ADDR  0081H  PREDEFINED  
SPACE. . . . . . . . . . . . . .    NUMB  0020H  
SPC. . . . . . . . . . . . . . .  C ADDR  0155H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 107

SPLIT_DBA. . . . . . . . . . . .  C ADDR  02BAH  
SPLSFR . . . . . . . . . . . . .  C ADDR  02C4H  
SP_BASE. . . . . . . . . . . . .    NUMB  002BH  
SP_INI . . . . . . . . . . . . .  C ADDR  00B6H  NOT USED  
START. . . . . . . . . . . . . .  C ADDR  0A7AH  
START_COMMAND_SEG. . . . . . . .  C ADDR  00CCH  NOT USED  
START_OF_PROGRAMS. . . . . . . .  C ADDR  1E8AH  
STCLEAR. . . . . . . . . . . . .  C ADDR  0F34H  NOT USED  
STK_ER . . . . . . . . . . . . .  C ADDR  01F2H  
STLET. . . . . . . . . . . . . .  C ADDR  0ADBH  NOT USED  
STLOCK . . . . . . . . . . . . .  C ADDR  0F22H  NOT USED  
STMT . . . . . . . . . . . . . .  C ADDR  0AB8H  
STORE. . . . . . . . . . . . . .  C ADDR  02DAH  
STOR_0 . . . . . . . . . . . . .  C ADDR  02DCH  
STOR_1 . . . . . . . . . . . . .  C ADDR  02EFH  
STRCBY . . . . . . . . . . . . .  C ADDR  032DH  
STRDBY . . . . . . . . . . . . .  C ADDR  0312H  
STRDIR . . . . . . . . . . . . .  C ADDR  02A0H  
STRJTB . . . . . . . . . . . . .  C ADDR  02F4H  
STRLEN . . . . . . . . . . . . .  D ADDR  0012H  
STROUT . . . . . . . . . . . . .  C ADDR  018BH  
STROUT2. . . . . . . . . . . . .  C ADDR  019DH  
STRO_1 . . . . . . . . . . . . .  C ADDR  018FH  
STRO_2 . . . . . . . . . . . . .  C ADDR  0199H  
STRRAM . . . . . . . . . . . . .    NUMB  0100H  NOT USED  
STRRBI . . . . . . . . . . . . .  C ADDR  0318H  
STRSFR . . . . . . . . . . . . .  C ADDR  02A8H  
STRTBL . . . . . . . . . . . . .  C ADDR  0236H  
STRVAR . . . . . . . . . . . . .  C ADDR  02F9H  
STRXBY . . . . . . . . . . . . .  C ADDR  032DH  
STUNLOCK . . . . . . . . . . . .  C ADDR  0F0EH  NOT USED  
SYN_ER . . . . . . . . . . . . .  C ADDR  102EH  
SYN_NG . . . . . . . . . . . . .  C ADDR  1154H  
S_INIT . . . . . . . . . . . . .  C ADDR  008CH  
T0_EXIT. . . . . . . . . . . . .  C ADDR  0087H  
TABCNT . . . . . . . . . . . . .  D ADDR  0014H  
TABSIZ . . . . . . . . . . . . .    NUMB  0008H  
TAG_FOUND. . . . . . . . . . . .  C ADDR  11A8H  NOT USED  
TCHK0. . . . . . . . . . . . . .  C ADDR  005FH  NOT USED  
TCHK1. . . . . . . . . . . . . .  C ADDR  0064H  
TCHK2. . . . . . . . . . . . . .  C ADDR  0069H  
TCHK3. . . . . . . . . . . . . .  C ADDR  006EH  
TCHK4. . . . . . . . . . . . . .  C ADDR  0073H  
TCHK5. . . . . . . . . . . . . .  C ADDR  0078H  
TCHK6. . . . . . . . . . . . . .  C ADDR  007DH  
TCHK7. . . . . . . . . . . . . .  C ADDR  0082H  
TCLR0. . . . . . . . . . . . . .  C ADDR  0032H  NOT USED  
TCLR1. . . . . . . . . . . . . .  C ADDR  0037H  
TCLR2. . . . . . . . . . . . . .  C ADDR  003CH  
TCLR3. . . . . . . . . . . . . .  C ADDR  0041H  
TCLR4. . . . . . . . . . . . . .  C ADDR  0046H  
TCLR5. . . . . . . . . . . . . .  C ADDR  004BH  
TCLR6. . . . . . . . . . . . . .  C ADDR  0050H  
TCLR7. . . . . . . . . . . . . .  C ADDR  0055H  
TERM . . . . . . . . . . . . . .  C ADDR  10B3H  
TERM_0 . . . . . . . . . . . . .  C ADDR  10B6H  
TERM_1 . . . . . . . . . . . . .  C ADDR  10C4H  
TERM_2 . . . . . . . . . . . . .  C ADDR  10D2H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 108

TERM_3 . . . . . . . . . . . . .  C ADDR  10E2H  
TERM_4 . . . . . . . . . . . . .  C ADDR  10F2H  
TEST_PROGRAM . . . . . . . . . .  C ADDR  0C47H  
TH0. . . . . . . . . . . . . . .  D ADDR  008CH  PREDEFINED  
TH1. . . . . . . . . . . . . . .  D ADDR  008DH  PREDEFINED  
TI . . . . . . . . . . . . . . .  B ADDR  0099H  PREDEFINED  
TIMER0 . . . . . . . . . . . . .  D ADDR  001EH  
TIMER1 . . . . . . . . . . . . .  D ADDR  001FH  
TIMER_0. . . . . . . . . . . . .  C ADDR  0024H  
TMOD . . . . . . . . . . . . . .  D ADDR  0089H  PREDEFINED  
TMP0 . . . . . . . . . . . . . .  D ADDR  0008H  
TMP1 . . . . . . . . . . . . . .  D ADDR  0009H  
TMP2 . . . . . . . . . . . . . .  D ADDR  000AH  
TMP3 . . . . . . . . . . . . . .  D ADDR  000BH  
TMP4 . . . . . . . . . . . . . .  D ADDR  000CH  
TMP5 . . . . . . . . . . . . . .  D ADDR  000DH  
TMP6 . . . . . . . . . . . . . .  D ADDR  000EH  NOT USED  
TMP7 . . . . . . . . . . . . . .  D ADDR  000FH  NOT USED  
TMP_0. . . . . . . . . . . . . .  B ADDR  0048H  NOT USED  
TMP_1. . . . . . . . . . . . . .  B ADDR  0049H  NOT USED  
TMP_2. . . . . . . . . . . . . .  B ADDR  004AH  NOT USED  
TMP_3. . . . . . . . . . . . . .  B ADDR  004BH  NOT USED  
TMP_4. . . . . . . . . . . . . .  B ADDR  004CH  NOT USED  
TMP_5. . . . . . . . . . . . . .  B ADDR  004DH  NOT USED  
TMP_6. . . . . . . . . . . . . .  B ADDR  004EH  NOT USED  
TMP_7. . . . . . . . . . . . . .  B ADDR  004FH  NOT USED  
TMP_MSK. . . . . . . . . . . . .  D ADDR  0029H  
TOKEN. . . . . . . . . . . . . .  C ADDR  0ABCH  
TOS_H. . . . . . . . . . . . . .    REG7         
TOS_L. . . . . . . . . . . . . .    REG6         
TO_CHK . . . . . . . . . . . . .  C ADDR  005DH  
TO_CLR . . . . . . . . . . . . .  C ADDR  0030H  NOT USED  
TR0. . . . . . . . . . . . . . .  B ADDR  008CH  PREDEFINED  
TR1. . . . . . . . . . . . . . .  B ADDR  008EH  PREDEFINED  
TRAM_OK. . . . . . . . . . . . .  C ADDR  00A7H  
TST. . . . . . . . . . . . . . .  C ADDR  0623H  
TSTN . . . . . . . . . . . . . .  C ADDR  07B6H  
TSTN_1 . . . . . . . . . . . . .  C ADDR  07BFH  
TSTS . . . . . . . . . . . . . .  C ADDR  07CBH  
TSTS_1 . . . . . . . . . . . . .  C ADDR  07DBH  
TSTS_2 . . . . . . . . . . . . .  C ADDR  07E2H  
TSTV . . . . . . . . . . . . . .  C ADDR  0654H  
TSTV_1 . . . . . . . . . . . . .  C ADDR  07ABH  
TST_1. . . . . . . . . . . . . .  C ADDR  062FH  
TST_CBYTE. . . . . . . . . . . .  C ADDR  0798H  NOT USED  
TST_CBYTE_END. . . . . . . . . .  C ADDR  07A4H  
TST_DBYTE. . . . . . . . . . . .  C ADDR  076FH  NOT USED  
TST_DBYTE_END. . . . . . . . . .  C ADDR  077DH  
TST_ERROR. . . . . . . . . . . .  C ADDR  0689H  NOT USED  
TST_ERROR_END. . . . . . . . . .  C ADDR  069DH  
TST_FREQ . . . . . . . . . . . .  C ADDR  06B1H  NOT USED  
TST_FREQ_END . . . . . . . . . .  C ADDR  06C4H  
TST_MASK . . . . . . . . . . . .  C ADDR  06C4H  NOT USED  
TST_MASK_END . . . . . . . . . .  C ADDR  06D7H  
TST_PWM0 . . . . . . . . . . . .  C ADDR  06D7H  NOT USED  
TST_PWM1 . . . . . . . . . . . .  C ADDR  06EAH  
TST_PWM2 . . . . . . . . . . . .  C ADDR  06FDH  
TST_PWM3 . . . . . . . . . . . .  C ADDR  0710H  
LILBASIC        LilBasic (c)2002                                                                              PAGE 109

TST_PWM4 . . . . . . . . . . . .  C ADDR  0723H  
TST_PWM5 . . . . . . . . . . . .  C ADDR  0736H  
TST_PWM6 . . . . . . . . . . . .  C ADDR  0749H  
TST_PWM7 . . . . . . . . . . . .  C ADDR  075CH  
TST_PWM_END. . . . . . . . . . .  C ADDR  076FH  
TST_RBIT . . . . . . . . . . . .  C ADDR  077DH  NOT USED  
TST_RBIT_END . . . . . . . . . .  C ADDR  078AH  
TST_TIMER. . . . . . . . . . . .  C ADDR  069DH  NOT USED  
TST_TIMER_END. . . . . . . . . .  C ADDR  06B1H  
TST_XBYTE. . . . . . . . . . . .  C ADDR  078AH  NOT USED  
TST_XBYTE_END. . . . . . . . . .  C ADDR  0798H  
T_BAD. . . . . . . . . . . . . .  C ADDR  0647H  
T_GOOD . . . . . . . . . . . . .  C ADDR  0643H  
UNLOCK . . . . . . . . . . . . .  C ADDR  0F47H  
UNUSED . . . . . . . . . . . . .  B ADDR  0050H  NOT USED  
UPPER. . . . . . . . . . . . . .  C ADDR  010CH  
UPPER_EXIT . . . . . . . . . . .  C ADDR  0118H  
VAR. . . . . . . . . . . . . . .  C ADDR  110FH  
VARRAM . . . . . . . . . . . . .    NUMB  1C00H  
VAR_0. . . . . . . . . . . . . .  C ADDR  1118H  
VAR_1. . . . . . . . . . . . . .  C ADDR  111EH  
VAR_1A . . . . . . . . . . . . .  C ADDR  1136H  
VAR_2. . . . . . . . . . . . . .  C ADDR  1145H  
VERS . . . . . . . . . . . . . .    NUMB  0032H  
VER_END. . . . . . . . . . . . .  C ADDR  0DB6H  
VER_MSG. . . . . . . . . . . . .  C ADDR  0D57H  
VER_ST . . . . . . . . . . . . .  C ADDR  0D47H  NOT USED  
WAIT1MS. . . . . . . . . . . . .  C ADDR  01A6H  NOT USED  
WAIT1MS_LOOP2. . . . . . . . . .  C ADDR  01AEH  
WAIT3MS. . . . . . . . . . . . .  C ADDR  01BAH  NOT USED  
WAIT5MS. . . . . . . . . . . . .  C ADDR  01B6H  
WAITMS . . . . . . . . . . . . .  C ADDR  01A8H  
WIPEALL_CONT . . . . . . . . . .  C ADDR  0F03H  
WIPEALL_END. . . . . . . . . . .  C ADDR  0F0EH  
WIPEALL_LOOP . . . . . . . . . .  C ADDR  0EE1H  
WIPEALL_START. . . . . . . . . .  C ADDR  0ECFH  NOT USED  
WRCH_1 . . . . . . . . . . . . .  C ADDR  060EH  
WRITE_CHAR . . . . . . . . . . .  C ADDR  0607H  
XAUTO. . . . . . . . . . . . . .  B ADDR  0052H  
XEC. . . . . . . . . . . . . . .  C ADDR  0AB6H  
XFER . . . . . . . . . . . . . .  C ADDR  0A42H  
XFERNG . . . . . . . . . . . . .  C ADDR  0A49H  
XINIT. . . . . . . . . . . . . .  C ADDR  096FH  
XRAD_1 . . . . . . . . . . . . .  C ADDR  03C4H  
XRAM . . . . . . . . . . . . . .    NUMB  8002H  
XTOP . . . . . . . . . . . . . .    NUMB  8000H  
YES_TAG. . . . . . . . . . . . .  C ADDR  11C4H  NOT USED  
ZERSUP . . . . . . . . . . . . .  B ADDR  0058H  
